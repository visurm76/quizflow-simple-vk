import {
  require_react_dom
} from "./chunk-CJSRII5H.js";
import {
  Icon12Circle,
  Icon12Dropdown,
  Icon12OnlineMobile,
  Icon16Cancel,
  Icon16Chevron,
  Icon16Clear,
  Icon16Done,
  Icon16Dropdown,
  Icon16SearchOutline,
  Icon20CalendarOutline,
  Icon20Cancel,
  Icon20CheckBoxIndetermanate,
  Icon20CheckBoxOff,
  Icon20CheckBoxOn,
  Icon20CheckCircleOff,
  Icon20CheckCircleOn,
  Icon20ChevronLeftOutline,
  Icon20ChevronRightOutline,
  Icon20ChevronUp,
  Icon20Dropdown,
  Icon24ArrowLeftOutline,
  Icon24Attach,
  Icon24Cancel,
  Icon24CancelOutline,
  Icon24CheckBoxOff,
  Icon24CheckBoxOn,
  Icon24CheckCircleOff,
  Icon24CheckCircleOn,
  Icon24CheckCircleOutline,
  Icon24Chevron,
  Icon24ChevronCompactLeft,
  Icon24ChevronCompactRight,
  Icon24ChevronDown,
  Icon24ChevronUp,
  Icon24Dismiss,
  Icon24DismissDark,
  Icon24DoneOutline,
  Icon24PenOutline,
  Icon24Reorder,
  Icon24ReorderIos,
  Icon24Send,
  Icon28AddCircleOutline,
  Icon28ArrowLeftOutline,
  Icon28AttachOutline,
  Icon28CancelOutline,
  Icon28CheckCircleOutline,
  Icon28ChevronBack,
  Icon28ChevronLeftOutline,
  Icon28ChevronRightCircle,
  Icon28DoneOutline,
  Icon28EditOutline,
  Icon28Send,
  Icon48WritebarDone,
  Icon48WritebarSend,
  IconAppearanceProvider,
  _define_property,
  _object_spread,
  _object_spread_props,
  _object_without_properties
} from "./chunk-J6UM2CH5.js";
import {
  require_jsx_runtime
} from "./chunk-MAPK647S.js";
import {
  require_react
} from "./chunk-3RM6SWVL.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/@vkontakte/vkui/dist/components/AppRoot/AppRoot.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var React13 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkjs/lib/other/dom.js
var canUseDOM = (function() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
})();
var canUseEventListeners = (function() {
  return canUseDOM && !!window.addEventListener;
})();

// node_modules/@vkontakte/vkjs/lib/animation/animate.js
var animationEvent = (function() {
  var obj = {
    supported: false,
    name: "animationend"
  };
  if (canUseDOM) {
    if (typeof AnimationEvent !== "undefined") {
      obj.supported = true;
    } else if (typeof WebKitAnimationEvent !== "undefined") {
      obj.supported = true;
      obj.name = "webkitAnimationEnd";
    }
  }
  return obj;
})();
var transitionEvent = (function() {
  var obj = {
    supported: false,
    name: "transitionend"
  };
  if (canUseDOM) {
    if (typeof TransitionEvent !== "undefined") {
      obj.supported = true;
    } else if (typeof WebKitTransitionEvent !== "undefined") {
      obj.supported = true;
      obj.name = "webkitTransitionEnd";
    }
  }
  return obj;
})();

// node_modules/@swc/helpers/esm/_array_like_to_array.js
function _array_like_to_array(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}

// node_modules/@swc/helpers/esm/_unsupported_iterable_to_array.js
function _unsupported_iterable_to_array(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _array_like_to_array(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}

// node_modules/@swc/helpers/esm/_type_of.js
function _type_of(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}

// node_modules/@vkontakte/vkjs/lib/async/debounce.js
function debounce(fn, delay) {
  var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : typeof window !== "undefined" ? window : void 0;
  var timeoutId;
  var args;
  var later = function() {
    return fn.apply(context, args);
  };
  var debouncedFn = function() {
    for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {
      a[_key] = arguments[_key];
    }
    args = a;
    clearTimeout(timeoutId);
    timeoutId = setTimeout(later, delay);
  };
  debouncedFn.cancel = function() {
    clearTimeout(timeoutId);
  };
  return debouncedFn;
}

// node_modules/@vkontakte/vkjs/lib/async/throttle.js
function throttle(fn) {
  var threshold = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50, scope = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : typeof window !== "undefined" ? window : void 0;
  var prevDate = Date.now() - threshold;
  var timeoutId;
  var throttledFn = function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var timeLeft = prevDate + threshold - Date.now();
    clearTimeout(timeoutId);
    if (timeLeft > 0) {
      timeoutId = setTimeout(function() {
        prevDate = Date.now();
        fn.apply(scope, args);
      }, timeLeft);
      return;
    }
    prevDate = Date.now();
    fn.apply(scope, args);
  };
  throttledFn.cancel = function() {
    clearTimeout(timeoutId);
  };
  return throttledFn;
}

// node_modules/@vkontakte/vkjs/lib/datetime/isSameDate.js
function isSameDate(d1, d2) {
  return d1.getDate() === d2.getDate() && d1.getMonth() === d2.getMonth() && d1.getFullYear() === d2.getFullYear();
}

// node_modules/@vkontakte/vkjs/lib/datetime/date.js
var SECONDS_IN_THE_DAY = 86400;
var MILLISECONDS_IN_THE_DAY = SECONDS_IN_THE_DAY * 1e3;

// node_modules/@vkontakte/vkjs/lib/device/IOSDetections.js
function detectIOS(ua) {
  if (!ua) {
    ua = canUseDOM ? navigator.userAgent : "";
  }
  ua = ua.toLowerCase();
  var isIPadOS2 = checkIPadOS(ua);
  var isIPad2 = isIPadOS2 || ua.includes("ipad");
  var isIPhone2 = !isIPad2 && ua.search(/iphone|ipod/) !== -1;
  var isIOS2 = isIPhone2 || isIPad2;
  var iosVersion = isIOS2 && ua.match(/os ([\d_]+) like mac os x/i);
  var iosMajor2 = 0;
  var iosMinor2 = 0;
  if (isIPadOS2) {
    iosMajor2 = 13;
    iosMinor2 = 0;
  } else if (iosVersion) {
    iosVersion = iosVersion[1].split("_");
    iosMajor2 = +iosVersion[0];
    iosMinor2 = +iosVersion[1];
  }
  iosVersion = null;
  var isScrollBasedViewport2 = iosMajor2 < 13 && !(iosMajor2 === 11 && iosMinor2 < 3);
  var isWKWebView2 = isIOS2 && checkWKWebView(ua);
  var isIPhoneX2 = false;
  if (canUseDOM) {
    isIPhoneX2 = isIOS2 && screen.width === 375 && screen.height === 812 && window.devicePixelRatio === 3;
  }
  var isIOSChrome2 = ua.search(/crios/i) !== -1;
  return {
    isIPad: isIPad2,
    isIPhone: isIPhone2,
    isIOS: isIOS2,
    isIPadOS: isIPadOS2,
    iosMajor: iosMajor2,
    iosMinor: iosMinor2,
    isWKWebView: isWKWebView2,
    isScrollBasedViewport: isScrollBasedViewport2,
    isIPhoneX: isIPhoneX2,
    isIOSChrome: isIOSChrome2
  };
}
var detect = detectIOS();
var isIPad = (function() {
  return detect.isIPad;
})();
var isIPhone = (function() {
  return detect.isIPhone;
})();
var isIOS = (function() {
  return detect.isIOS;
})();
var isIPadOS = (function() {
  return detect.isIPadOS;
})();
var iosMajor = (function() {
  return detect.iosMajor;
})();
var iosMinor = (function() {
  return detect.iosMinor;
})();
var isWKWebView = (function() {
  return detect.isWKWebView;
})();
var isScrollBasedViewport = (function() {
  return detect.isScrollBasedViewport;
})();
var isIPhoneX = (function() {
  return detect.isIPhoneX;
})();
var isIOSChrome = (function() {
  return detect.isIOSChrome;
})();
function checkWKWebView(ua) {
  if (!canUseDOM) {
    return false;
  }
  var webkit = window.webkit;
  if (webkit && webkit.messageHandlers) {
    return true;
  }
  var lte9 = /constructor/i.test(String(window.HTMLElement));
  var idb = !!window.indexedDB;
  if (ua.includes("safari") && ua.includes("version") && !navigator.standalone) {
  } else if (!idb && lte9 || !(window.statusbar && window.statusbar.visible)) {
  } else if (!lte9 || idb) {
    return true;
  }
  return false;
}
function checkIPadOS(ua) {
  if (!canUseDOM) {
    return false;
  }
  var isNotIOS = !/ipPad|iPhone|iPod/i.test(ua);
  var isMacOS = /Mac OS/i.test(ua);
  return isNotIOS && isMacOS && "ontouchend" in document;
}

// node_modules/@vkontakte/vkjs/lib/device/InputUtils.js
var detect2 = (function() {
  var obj = {
    hasMouse: false,
    hasTouchEvents: false,
    hasHover: false,
    hasTouch: false
  };
  if (!canUseDOM) {
    return obj;
  }
  if (isIOS && !isIPadOS) {
    obj.hasMouse = false;
    obj.hasHover = false;
    obj.hasTouchEvents = true;
    obj.hasTouch = true;
  } else {
    obj.hasTouchEvents = "ontouchstart" in document;
    obj.hasTouch = obj.hasTouchEvents || "maxTouchPoints" in navigator && navigator.maxTouchPoints > 0;
    if (obj.hasTouch) {
      var notMobile = !/android|mobile|tablet/i.test(navigator.userAgent);
      obj.hasMouse = typeof window.matchMedia === "function" && window.matchMedia("(pointer)").matches ? matchMedia("(pointer: fine)").matches : notMobile;
      obj.hasHover = obj.hasMouse && (typeof window.matchMedia === "function" && window.matchMedia("(hover)").matches ? matchMedia("(hover: hover)").matches : notMobile);
    } else {
      obj.hasMouse = true;
      obj.hasHover = true;
    }
  }
  return obj;
})();
var hasMouse = (function() {
  return detect2.hasMouse;
})();
var hasHover = (function() {
  return detect2.hasHover;
})();
var hasTouchEvents = (function() {
  return detect2.hasTouchEvents;
})();
var hasTouch = (function() {
  return detect2.hasTouch;
})();

// node_modules/@swc/helpers/esm/_class_call_check.js
function _class_call_check(instance, Constructor) {
  if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}

// node_modules/@swc/helpers/esm/_create_class.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

// node_modules/@vkontakte/vkjs/lib/other/regexp.js
function escapeRegExp(string) {
  if (string) {
    return string.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1");
  }
  return "";
}

// node_modules/@vkontakte/vkjs/lib/internal/replacer.js
var Replacer = (function() {
  "use strict";
  function Replacer2(map) {
    _class_call_check(this, Replacer2);
    _define_property(this, "regexp", void 0);
    _define_property(this, "map", void 0);
    this.map = map;
  }
  _create_class(Replacer2, [
    {
      key: "build",
      value: function build() {
        if (this.regexp) {
          return;
        }
        var groups = Object.keys(this.map).map(escapeRegExp).sort(function(a, b) {
          return b.length - a.length;
        });
        var pattern = "(?:".concat(groups.join("|"), ")");
        this.regexp = new RegExp(pattern, "g");
      }
    },
    {
      key: "replace",
      value: function replace(string) {
        var _this = this;
        if (!string) {
          return "";
        }
        this.build();
        return string.replace(this.regexp, function(substring) {
          return _this.map[substring];
        });
      }
    }
  ]);
  return Replacer2;
})();

// node_modules/@vkontakte/vkjs/lib/internal/codepoints.js
var fromCodePoint = (function() {
  return String.fromCodePoint || function(astralCodePoint) {
    return String.fromCharCode(Math.floor((astralCodePoint - 65536) / 1024) + 55296, (astralCodePoint - 65536) % 1024 + 56320);
  };
})();
var codePointAtNative = (function() {
  return (
    // eslint-disable-next-line @typescript-eslint/unbound-method
    String.prototype.codePointAt
  );
})();

// node_modules/@vkontakte/vkjs/lib/html/escape.js
var escapeReplacer = new Replacer({
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  "'": "&#39;",
  '"': "&quot;"
});
var unescapeReplacer = new Replacer({
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"'
});
var outOfBoundsChar = String.fromCharCode(65533);

// node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}

// node_modules/@vkontakte/vkjs/lib/other/functions.js
var noop = function() {
};

// node_modules/@vkontakte/vkjs/lib/other/detections.js
var isPassiveEventsSupported = (function() {
  var isSupported = false;
  if (canUseEventListeners) {
    try {
      var options = Object.defineProperty({}, "passive", {
        get: function get() {
          isSupported = true;
        }
      });
      window.addEventListener("test", noop, options);
      window.removeEventListener("test", noop, options);
    } catch (e) {
    }
  }
  return isSupported;
})();
function detectSmoothScrollSupport() {
  if (!canUseDOM) {
    return false;
  }
  var isSupported = false;
  try {
    var div = document.createElement("div");
    div.scrollTo({
      top: 0,
      get behavior() {
        isSupported = true;
        return "smooth";
      }
    });
  } catch (e) {
  }
  return isSupported;
}
var isSmoothScrollSupported = detectSmoothScrollSupport();

// node_modules/@vkontakte/vkjs/lib/typecheck/type_checkers.js
function isObjectLike(object) {
  return (typeof object === "undefined" ? "undefined" : _type_of(object)) === "object" && object !== null;
}
function isFunction(object) {
  return typeof object === "function";
}

// node_modules/@vkontakte/vkjs/lib/other/equal.js
function isEqual(value, other) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  if (isObjectLike(value) && isObjectLike(other)) {
    if (Object.keys(value).length !== Object.keys(other).length) {
      return false;
    }
    for (var prop in value) {
      if (value.hasOwnProperty(prop) && other.hasOwnProperty(prop)) {
        if (!isEqual(value[prop], other[prop])) {
          return false;
        }
      } else {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/@swc/helpers/esm/_instanceof.js
function _instanceof(left, right) {
  if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
    return !!right[Symbol.hasInstance](left);
  } else return left instanceof right;
}

// node_modules/@vkontakte/vkjs/lib/other/react_utils.js
function hasReactNode(value) {
  return value !== void 0 && value !== false && value !== null && value !== "";
}
function isPrimitiveReactNode(node) {
  return typeof node === "string" || typeof node === "number";
}

// node_modules/@vkontakte/vkjs/lib/other/storage.js
var CustomStorage = (function() {
  "use strict";
  function CustomStorage2() {
    var _this = this;
    _class_call_check(this, CustomStorage2);
    _define_property(this, "data", {});
    _define_property(this, "getItem", function(key) {
      return _this.data.hasOwnProperty(key) ? _this.data[key] : null;
    });
    _define_property(this, "keys", function() {
      return Object.keys(_this.data);
    });
  }
  _create_class(CustomStorage2, [
    {
      key: "setItem",
      value: function setItem(key, val) {
        this.data[key] = String(val);
      }
    },
    {
      key: "removeItem",
      value: function removeItem(id) {
        delete this.data[id];
      }
    },
    {
      key: "clear",
      value: function clear() {
        this.data = {};
      }
    },
    {
      key: "length",
      get: function get() {
        return Object.keys(this.data).length;
      }
    },
    {
      key: "key",
      value: function key(index2) {
        return Object.keys(this.data)[index2];
      }
    }
  ]);
  return CustomStorage2;
})();

// node_modules/@vkontakte/vkjs/lib/text/transliteration.js
var transliterationDictVKRusToEng = {
  "А": "A",
  "Б": "B",
  "В": "V",
  "Г": "G",
  "¥": "G",
  "Д": "D",
  "Е": "E",
  "Є": "Ye",
  "Ё": "Yo",
  "Ж": "Zh",
  "З": "Z",
  "И": "I",
  "Ї": "Yi",
  "²": "I",
  "Й": "J",
  "К": "K",
  "Л": "L",
  "М": "M",
  "Н": "N",
  "О": "O",
  "П": "P",
  "Р": "R",
  "С": "S",
  "Т": "T",
  "У": "U",
  "Ў": "W",
  "Ф": "F",
  "Х": "Kh",
  "Ц": "Ts",
  "Ч": "Ch",
  "Ш": "Sh",
  "Щ": "Sch",
  "Ы": "Y",
  "Ый": "Y",
  "Э": "E",
  "Ю": "Yu",
  "Я": "Ya",
  "а": "a",
  "б": "b",
  "в": "v",
  "г": "g",
  "´": "g",
  "д": "d",
  "е": "e",
  "є": "ye",
  "ё": "yo",
  "ж": "zh",
  "з": "z",
  "ия": "ia",
  "ий": "y",
  "и": "i",
  "й": "y",
  "ї": "yi",
  "³": "i",
  "кс": "x",
  "к": "k",
  "л": "l",
  "м": "m",
  "н": "n",
  "о": "o",
  "п": "p",
  "р": "r",
  "с": "s",
  "т": "t",
  "у": "u",
  "ў": "w",
  "ф": "f",
  "х": "kh",
  "ц": "ts",
  "ч": "ch",
  "ш": "sh",
  "щ": "sch",
  "ъ": "",
  "ый": "y",
  "ы": "y",
  "ь": "",
  "ье": "ye",
  "ьо": "io",
  "э": "e",
  "ю": "yu",
  "я": "ya"
};
var transliterationDictVKEngToRus = {
  "a": "а",
  "b": "б",
  "v": "в",
  "g": "г",
  "d": "д",
  "e": "е",
  "z": "з",
  "i": "и",
  "j": "й",
  "k": "к",
  "l": "л",
  "m": "м",
  "n": "н",
  "o": "о",
  "p": "п",
  "r": "р",
  "s": "с",
  "t": "т",
  "u": "у",
  "f": "ф",
  "h": "х",
  "c": "ц",
  "y": "ы",
  "A": "А",
  "B": "Б",
  "V": "В",
  "G": "Г",
  "D": "Д",
  "E": "Е",
  "Z": "З",
  "I": "И",
  "J": "Й",
  "K": "К",
  "L": "Л",
  "M": "М",
  "N": "Н",
  "O": "О",
  "P": "П",
  "R": "Р",
  "S": "С",
  "T": "Т",
  "U": "У",
  "F": "Ф",
  "H": "Х",
  "C": "Ц",
  "Y": "Ы",
  "w": "в",
  "q": "к",
  "x": "кс",
  "W": "В",
  "Q": "К",
  "X": "КС",
  "yo": "ё",
  "zh": "ж",
  "kh": "х",
  "ts": "ц",
  "ch": "ч",
  "sch": "щ",
  "shch": "щ",
  "sh": "ш",
  "eh": "э",
  "yu": "ю",
  "ya": "я",
  "YO": "Ё",
  "ZH": "Ж",
  "KH": "Х",
  "TS": "Ц",
  "CH": "Ч",
  "SCH": "Щ",
  "SHCH": "Щ",
  "SH": "Ш",
  "EH": "Э",
  "YU": "Ю",
  "YA": "Я",
  "'": "ь"
};
var transliterationDictGostLetterCombinationsRu = {
  "А": "A",
  "Б": "B",
  "В": "V",
  "Г": "G",
  "Д": "D",
  "Е": "E",
  "Ё": "Yo",
  "Ж": "Zh",
  "З": "Z",
  "И": "I",
  "Й": "J",
  "К": "K",
  "Л": "L",
  "М": "M",
  "Н": "N",
  "О": "O",
  "П": "P",
  "Р": "R",
  "С": "S",
  "Т": "T",
  "У": "U",
  "Ф": "F",
  "Х": "X",
  "Ц": "Cz",
  "Ч": "Ch",
  "Ш": "Sh",
  "Щ": "Shh",
  "Ъ": "``",
  "Ы": "Y`",
  "Ь": "`",
  "Э": "E`",
  "Ю": "Yu",
  "Я": "Ya",
  "а": "a",
  "б": "b",
  "в": "v",
  "г": "g",
  "д": "d",
  "е": "e",
  "ё": "yo",
  "ж": "zh",
  "з": "z",
  "и": "i",
  "й": "j",
  "к": "k",
  "л": "l",
  "м": "m",
  "н": "n",
  "о": "o",
  "п": "p",
  "р": "r",
  "с": "s",
  "т": "t",
  "у": "u",
  "ф": "f",
  "х": "x",
  "ц": "cz",
  "ч": "ch",
  "ш": "sh",
  "щ": "shh",
  "ъ": "``",
  "ы": "y`",
  "ь": "`",
  "э": "e`",
  "ю": "yu",
  "я": "ya",
  "’": "'",
  // апостроф
  "Ѣ": "ye",
  // ять
  "Ѳ": "fh",
  //	фита
  "Ѵ": "yh"
};
var Transliterator = (function() {
  "use strict";
  function Transliterator2(dict) {
    _class_call_check(this, Transliterator2);
    _define_property(this, "replacer", void 0);
    this.replacer = new Replacer(dict);
  }
  _create_class(Transliterator2, [
    {
      /**
      * Производит транслитерацию текста
      */
      key: "transliteration",
      value: function transliteration(text) {
        return this.replacer.replace(text);
      }
    }
  ]);
  return Transliterator2;
})();
var transliteratorVKRusToEng = new Transliterator(transliterationDictVKRusToEng);
var transliteratorVKEngToRus = new Transliterator(transliterationDictVKEngToRus);
var transliteratorGostLetterCombinationsRu = new Transliterator(transliterationDictGostLetterCombinationsRu);

// node_modules/@vkontakte/vkui/dist/hooks/useKeyboardInputTracker.js
var React3 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/lib/children.js
var import_react = __toESM(require_react(), 1);
var childToString = (child) => {
  if (typeof child === "undefined" || child === null || typeof child === "boolean") {
    return "";
  }
  if (JSON.stringify(child) === "{}") {
    return "";
  }
  return child.toString();
};
var getTextFromChildren = (children) => {
  if (!(children instanceof Array) && !(0, import_react.isValidElement)(children)) {
    return childToString(children);
  }
  return import_react.Children.toArray(children).reduce((text, child) => {
    let newText = "";
    const isValidElementResult = (0, import_react.isValidElement)(child);
    const hasChildren = isValidElementResult && "children" in child.props;
    if (isValidElementResult && hasChildren) {
      newText = getTextFromChildren(child.props.children);
    } else if (isValidElementResult && !hasChildren) {
      newText = "";
    } else {
      newText = childToString(child);
    }
    return text.concat(newText);
  }, "");
};

// node_modules/@vkontakte/vkui/dist/lib/accessibility.js
var FOCUSABLE_ELEMENTS_LIST = [
  "a[href]",
  "area[href]",
  'input:not([disabled]):not([hidden]):not([type="hidden"]):not([aria-hidden])',
  "select:not([disabled]):not([hidden]):not([aria-hidden])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "iframe",
  "audio",
  "video",
  "[contenteditable]",
  '[tabindex]:not([tabindex="-1"])'
];
var Keys = {
  ENTER: "Enter",
  SPACE: "Space",
  TAB: "Tab",
  ESCAPE: "Escape",
  HOME: "Home",
  END: "End",
  DELETE: "Delete",
  BACKSPACE: "Backspace",
  ARROW_LEFT: "ArrowLeft",
  ARROW_RIGHT: "ArrowRight",
  ARROW_UP: "ArrowUp",
  ARROW_DOWN: "ArrowDown",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown"
};
var EVENT_KEY_TO_COMMON_KEY_MAP = /* @__PURE__ */ new Map([
  [
    "Enter",
    Keys.ENTER
  ],
  [
    "Space",
    Keys.SPACE
  ],
  [
    "Spacebar",
    Keys.SPACE
  ],
  [
    " ",
    Keys.SPACE
  ],
  [
    "Tab",
    Keys.TAB
  ],
  [
    "Escape",
    Keys.ESCAPE
  ],
  [
    "Delete",
    Keys.DELETE
  ],
  [
    "Backspace",
    Keys.BACKSPACE
  ],
  [
    "Home",
    Keys.HOME
  ],
  [
    "End",
    Keys.END
  ],
  [
    "ArrowLeft",
    Keys.ARROW_LEFT
  ],
  [
    "ArrowRight",
    Keys.ARROW_RIGHT
  ],
  [
    "ArrowUp",
    Keys.ARROW_UP
  ],
  [
    "ArrowDown",
    Keys.ARROW_DOWN
  ],
  [
    "PageUp",
    Keys.PAGE_UP
  ],
  [
    "PageDown",
    Keys.PAGE_DOWN
  ]
]);
function pressedKey(event) {
  const foundKey = EVENT_KEY_TO_COMMON_KEY_MAP.get(event.key);
  return foundKey ? foundKey : null;
}
var FOCUS_ALLOW_LIST_KEYS = /* @__PURE__ */ new Set([
  Keys.TAB,
  Keys.ARROW_LEFT,
  Keys.ARROW_RIGHT,
  Keys.ARROW_UP,
  Keys.ARROW_DOWN,
  Keys.BACKSPACE,
  Keys.DELETE
]);
function isKeyboardFocusingStarted(event) {
  return FOCUS_ALLOW_LIST_KEYS.has(event.key);
}
function shouldTriggerClickOnEnterOrSpace(e) {
  const el = e.target;
  const { tagName } = el;
  const role = el.getAttribute("role");
  const isValidKeyboardEventTarget = el.isContentEditable !== true && tagName !== "INPUT" && tagName !== "TEXTAREA" && (role === "button" || role === "link" || role === "menuitem");
  const isNativeAnchorEl = tagName === "A" && el.hasAttribute("href");
  const keyPressed = pressedKey(e);
  return isValidKeyboardEventTarget && // trigger buttons on Space
  (keyPressed === Keys.SPACE && role === "button" || // trigger non-native links and buttons on Enter
  keyPressed === Keys.ENTER && !isNativeAnchorEl);
}
var injectAriaExpandedPropByRole = (props, state, role) => {
  switch (role) {
    case "dialog":
    case "menu":
    case "application":
    case "tab":
    case "menuitem":
    case "treeitem":
    case "gridcell":
      props["aria-expanded"] = state;
      return props;
    default:
      return props;
  }
};
function hasAccessibleName({ "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, title, children }) {
  if (ariaLabel || ariaLabelledBy || title) {
    return true;
  }
  const accessibleLabel = getTextFromChildren(children);
  if (accessibleLabel.trim() !== "") {
    return true;
  }
  return false;
}
var getHorizontalFocusGoTo = (keys) => {
  switch (keys) {
    case Keys.ARROW_UP:
    case Keys.ARROW_LEFT:
      return "prev";
    case Keys.ARROW_DOWN:
    case Keys.ARROW_RIGHT:
      return "next";
    case Keys.HOME:
      return "first";
    case Keys.END:
      return "last";
  }
};

// node_modules/@vkontakte/vkui/dist/lib/dom.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var React = __toESM(require_react(), 1);

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@vkontakte/vkui-floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return _instanceof(value, Node) || _instanceof(value, getWindow(value).Node);
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return _instanceof(value, Element) || _instanceof(value, getWindow(value).Element);
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return _instanceof(value, HTMLElement) || _instanceof(value, getWindow(value).HTMLElement);
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return _instanceof(value, ShadowRoot) || _instanceof(value, getWindow(value).ShadowRoot);
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set([
  "inline",
  "contents"
]);
function isOverflowElement(element) {
  var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY, display = _getComputedStyle.display;
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set([
  "html",
  "body",
  "#document"
]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  var result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}

// node_modules/@vkontakte/vkui/dist/lib/dom.js
var getDOM = () => ({
  window: canUseDOM ? window : void 0,
  document: canUseDOM ? document : void 0
});
var DOMContext = React.createContext(getDOM());
var useDOM = () => {
  return React.useContext(DOMContext);
};
var isWindow = (node) => {
  return node !== null && node !== void 0 && "navigator" in node;
};
var isDocumentElement = (node) => {
  return node !== null && node !== void 0 && "tagName" in node && node.tagName === "HTML";
};
function withDOM(Component2) {
  const WithDOM = (props) => {
    const dom = useDOM();
    return (0, import_jsx_runtime.jsx)(Component2, _object_spread({}, props, dom));
  };
  return WithDOM;
}
function blurActiveElement(document1) {
  if (document1 && document1.activeElement) {
    document1.activeElement.blur();
  }
}
var TRANSFORM_DEFAULT_VALUES = [
  "none",
  "initial",
  "inherit",
  "unset"
];
var WILL_CHANGE_DEFAULT_VALUES = [
  "auto",
  "initial",
  "inherit",
  "unset"
];
function getTransformedParentCoords(element) {
  let parentNode = element.parentNode;
  while (parentNode !== null) {
    if (isHTMLElement(parentNode)) {
      let { transform, willChange } = getComputedStyle(parentNode);
      if (transform === "") {
        transform = "unset";
      }
      if (willChange === "") {
        willChange = "unset";
      }
      if (!TRANSFORM_DEFAULT_VALUES.includes(transform) || !WILL_CHANGE_DEFAULT_VALUES.includes(willChange)) {
        const { x, y } = parentNode.getBoundingClientRect();
        return {
          x,
          y
        };
      }
    }
    parentNode = parentNode.parentNode;
  }
  return {
    x: 0,
    y: 0
  };
}
var getBoundingClientRect = (node, isFixedStrategy = false) => {
  const element = isWindow(node) ? node.document.documentElement : node;
  const clientRect = element.getBoundingClientRect();
  if (isDocumentElement(element)) {
    clientRect.height = element.clientHeight;
  }
  let offsetX = 0;
  let offsetY = 0;
  if (isFixedStrategy) {
    const { x, y } = getTransformedParentCoords(element);
    offsetX = x;
    offsetY = y;
  }
  return rectToClientRect({
    x: clientRect.left - offsetX,
    y: clientRect.top - offsetY,
    width: clientRect.width,
    height: clientRect.height
  });
};
var getRelativeBoundingClientRect = (parent, child) => {
  const parentRect = getBoundingClientRect(parent);
  const childRect = getBoundingClientRect(child);
  return rectToClientRect({
    x: childRect.left - parentRect.left,
    y: childRect.top - parentRect.top,
    width: childRect.width,
    height: childRect.height
  });
};
function getNearestOverflowAncestor(node, terminalNode) {
  const parentNode = getParentNode(node);
  if (terminalNode === parentNode) {
    return null;
  }
  if (isLastTraversableNode(parentNode)) {
    return getWindow(parentNode);
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode, terminalNode);
}
var getScrollHeight = (node) => {
  return isWindow(node) ? node.document.documentElement.scrollHeight : node.scrollHeight;
};
var getScrollRect = (node) => {
  const window1 = isElement(node) ? getWindow(node) : node;
  const scrollElRect = getBoundingClientRect(node);
  const edgeTop = window1.scrollY + scrollElRect.top;
  const edgeBottom = edgeTop + scrollElRect.height;
  const y = [
    edgeTop,
    edgeBottom
  ];
  return {
    relative: scrollElRect,
    edges: {
      y
    }
  };
};
var getDocumentBody = (node) => getWindow(node).document.body;
var getActiveElementByAnotherElement = (el) => el ? el.ownerDocument.activeElement : null;
var contains = (parent, child) => {
  return parent && child ? parent.contains(child) : false;
};
var getFirstTouchEventData = (event) => {
  let dataRaw = (function resolveData() {
    switch (event.type) {
      case "touchend":
        return event.changedTouches[0];
      case "touchstart":
      case "touchmove":
      case "touchcancel":
        return event.touches[0];
      case "mousedown":
      case "mousemove":
      case "mouseup":
      case "mouseleave":
        return event;
      default:
        return {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0
        };
    }
  })();
  if (false) {
    dataRaw = dataRaw ? dataRaw : {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0
    };
  }
  return {
    screenX: dataRaw.screenX || 0,
    screenY: dataRaw.screenY || 0,
    clientX: dataRaw.clientX || 0,
    clientY: dataRaw.clientY || 0,
    pageX: dataRaw.pageX || 0,
    pageY: dataRaw.pageY || 0
  };
};
var initializeBrowserGesturePreventionEffect = (window1) => {
  const options = {
    passive: false
  };
  const handleWindowTouchMove = (event) => {
    event.preventDefault();
    event.stopPropagation();
  };
  window1.document.documentElement.classList.add("vkui--disable-overscroll-behavior");
  window1.addEventListener("touchmove", handleWindowTouchMove, options);
  return function dispose() {
    window1.document.documentElement.classList.remove("vkui--disable-overscroll-behavior");
    window1.removeEventListener("touchmove", handleWindowTouchMove, options);
  };
};
var nonTextInputTypes = {
  button: true,
  submit: true,
  reset: true,
  color: true,
  file: true,
  image: true,
  checkbox: true,
  radio: true
};
var isHTMLContentEditableElement = (el) => {
  if (el === null) {
    return false;
  }
  if (el.tagName === "INPUT") {
    return !nonTextInputTypes[el.type];
  }
  return el.tagName === "TEXTAREA" || // eslint-disable-next-line no-restricted-properties
  el.closest("[contenteditable=true]") !== null;
};
function getVisualViewport(win) {
  const result = {
    offsetTop: 0,
    offsetLeft: 0,
    width: 0,
    height: 0
  };
  if (win.visualViewport) {
    const { offsetTop, offsetLeft, width, height } = win.visualViewport;
    result.offsetTop = Math.round(offsetTop);
    result.offsetLeft = offsetLeft;
    result.width = width;
    result.height = Math.round(height);
    return result;
  }
  result.offsetTop = win.pageYOffset;
  result.offsetLeft = win.pageXOffset;
  result.width = win.innerWidth;
  result.height = win.innerHeight;
  return result;
}
var hasSelectionWithRangeType = (node) => {
  const selection = getWindow(node).getSelection();
  return selection ? selection.type === "Range" : false;
};
function isSVGElement(value) {
  if (!canUseDOM) {
    return false;
  }
  return value instanceof SVGElement || value instanceof getWindow(value).SVGElement;
}

// node_modules/@vkontakte/vkui/dist/lib/useIsomorphicLayoutEffect.js
var React2 = __toESM(require_react(), 1);
var useIsomorphicLayoutEffect = canUseDOM ? React2.useLayoutEffect : React2.useEffect;

// node_modules/@vkontakte/vkui/dist/hooks/useKeyboardInputTracker.js
var ENABLE_KEYBOARD_INPUT_EVENT_NAME = "enableKeyboardInput";
var DISABLE_KEYBOARD_INPUT_EVENT_NAME = "disableKeyboardInput";
var EVENT_OPTIONS = {
  passive: true,
  capture: true
};
function useKeyboardInputTracker() {
  const { document: document2 } = useDOM();
  const keyboardFocusingStartedRef = React3.useRef(false);
  useIsomorphicLayoutEffect(() => {
    if (!document2) {
      return;
    }
    const handleKeydown = (event) => {
      if (isKeyboardFocusingStarted(event)) {
        keyboardFocusingStartedRef.current = true;
      }
    };
    const handleCustomEnableKeyboardEvent = () => {
      keyboardFocusingStartedRef.current = true;
    };
    const handleCustomDisableKeyboardEvent = () => {
      keyboardFocusingStartedRef.current = false;
    };
    document2.addEventListener("keydown", handleKeydown, EVENT_OPTIONS);
    document2.addEventListener(ENABLE_KEYBOARD_INPUT_EVENT_NAME, handleCustomEnableKeyboardEvent, EVENT_OPTIONS);
    document2.addEventListener(DISABLE_KEYBOARD_INPUT_EVENT_NAME, handleCustomDisableKeyboardEvent, EVENT_OPTIONS);
    document2.addEventListener("mousedown", handleCustomDisableKeyboardEvent, EVENT_OPTIONS);
    document2.addEventListener("touchstart", handleCustomDisableKeyboardEvent, EVENT_OPTIONS);
    return () => {
      document2.removeEventListener("keydown", handleKeydown, EVENT_OPTIONS);
      document2.removeEventListener(ENABLE_KEYBOARD_INPUT_EVENT_NAME, handleCustomEnableKeyboardEvent, EVENT_OPTIONS);
      document2.removeEventListener(DISABLE_KEYBOARD_INPUT_EVENT_NAME, handleCustomDisableKeyboardEvent, EVENT_OPTIONS);
      document2.removeEventListener("mousedown", handleCustomDisableKeyboardEvent, EVENT_OPTIONS);
      document2.removeEventListener("touchstart", handleCustomDisableKeyboardEvent, EVENT_OPTIONS);
    };
  }, [
    document2
  ]);
  return keyboardFocusingStartedRef;
}

// node_modules/@vkontakte/vkui/dist/hooks/useSyncHTMLWithBaseVKUIClasses.js
var layoutClassNames = {
  card: "vkui--layout-card",
  plain: "vkui--layout-plain"
};
function useSyncHTMLWithBaseVKUIClasses({ appRootRef, mode, enable, layout }) {
  useIsomorphicLayoutEffect(() => {
    var _appRootRef_current, _appRootRef_current1;
    if (!enable) {
      return;
    }
    const htmlElement = (_appRootRef_current = appRootRef.current) === null || _appRootRef_current === void 0 ? void 0 : _appRootRef_current.ownerDocument.documentElement;
    var _appRootRef_current_parentElement;
    const parentElement = (_appRootRef_current_parentElement = (_appRootRef_current1 = appRootRef.current) === null || _appRootRef_current1 === void 0 ? void 0 : _appRootRef_current1.parentElement) !== null && _appRootRef_current_parentElement !== void 0 ? _appRootRef_current_parentElement : null;
    const htmlElementClasses = [
      "vkui"
    ];
    const parentElementClasses = [
      "vkui__root"
    ];
    if (mode === "embedded") {
      parentElementClasses.push("vkui__root--embedded");
    }
    if (mode === "full") {
      if (layout) {
        htmlElementClasses.push(layoutClassNames[layout]);
      }
      htmlElement === null || htmlElement === void 0 ? void 0 : htmlElement.classList.add(...htmlElementClasses);
    }
    parentElement === null || parentElement === void 0 ? void 0 : parentElement.classList.add(...parentElementClasses);
    return () => {
      if (mode === "full") {
        htmlElement === null || htmlElement === void 0 ? void 0 : htmlElement.classList.remove(...htmlElementClasses);
      }
      parentElement === null || parentElement === void 0 ? void 0 : parentElement.classList.remove(...parentElementClasses);
    };
  }, [
    mode,
    enable,
    layout
  ]);
}

// node_modules/@vkontakte/vkui/dist/lib/tokens/useTokenClassName.js
var React5 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/ConfigProvider/ConfigProviderContext.js
var React4 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/lib/browser.js
var memoized = {};
function computeBrowserInfo(userAgent = "") {
  if (memoized[userAgent]) {
    return memoized[userAgent];
  }
  const browserInfo = {
    userAgent,
    system: "",
    systemVersion: null
  };
  const { isIOS: isIOS2, iosMajor: iosMajor2, iosMinor: iosMinor2 } = detectIOS(userAgent);
  if (isIOS2) {
    browserInfo.system = "ios";
    browserInfo.systemVersion = {
      major: iosMajor2,
      minor: iosMinor2
    };
  }
  memoized[userAgent] = browserInfo;
  return browserInfo;
}
function mediaQueryNull(query) {
  return {
    matches: false,
    media: query,
    onchange: noop,
    addListener: noop,
    removeListener: noop,
    addEventListener: noop,
    removeEventListener: noop,
    dispatchEvent() {
      return false;
    }
  };
}

// node_modules/@vkontakte/vkui/dist/lib/platform.js
var Platform = {
  ANDROID: "android",
  IOS: "ios",
  VKCOM: "vkcom"
};
function platform(browserInfo) {
  if (!browserInfo) {
    browserInfo = computeBrowserInfo();
  }
  return browserInfo.system === "ios" ? "ios" : "android";
}

// node_modules/@vkontakte/vkui/dist/lib/tokens/constants.js
var DEFAULT_TOKENS_CLASS_NAMES = {
  android: {
    light: "vkui--vkBase--light",
    dark: "vkui--vkBase--dark"
  },
  ios: {
    light: "vkui--vkIOS--light",
    dark: "vkui--vkIOS--dark"
  },
  vkcom: {
    light: "vkui--vkCom--light",
    dark: "vkui--vkCom--dark"
  }
};

// node_modules/@vkontakte/vkui/dist/components/ConfigProvider/ConfigProviderContext.js
var ConfigProviderContext = React4.createContext({
  hasCustomPanelHeaderAfter: false,
  customPanelHeaderAfterMinWidth: 90,
  isWebView: false,
  transitionMotionEnabled: true,
  platform: platform(),
  colorScheme: void 0,
  tokensClassNames: DEFAULT_TOKENS_CLASS_NAMES,
  locale: "ru",
  direction: void 0
});
var useConfigProvider = () => React4.useContext(ConfigProviderContext);
function useConfigProviderContextMemo(config) {
  const { isWebView, hasCustomPanelHeaderAfter, customPanelHeaderAfterMinWidth, colorScheme, transitionMotionEnabled, platform: platform3, tokensClassNames, locale, direction } = config;
  return React4.useMemo(() => {
    return {
      isWebView,
      hasCustomPanelHeaderAfter,
      customPanelHeaderAfterMinWidth,
      colorScheme,
      transitionMotionEnabled,
      platform: platform3,
      tokensClassNames,
      locale,
      direction
    };
  }, [
    isWebView,
    hasCustomPanelHeaderAfter,
    customPanelHeaderAfterMinWidth,
    colorScheme,
    transitionMotionEnabled,
    platform3,
    tokensClassNames,
    locale,
    direction
  ]);
}

// node_modules/@vkontakte/vkui/dist/lib/colorScheme/index.js
var DEFAULT_COLOR_SCHEME = "light";
var ColorScheme = {
  DARK: "dark",
  LIGHT: "light"
};

// node_modules/@vkontakte/vkui/dist/lib/tokens/useTokenClassName.js
var isTokensClassNamesForPlatforms = (tokensClassNames) => Platform.ANDROID in tokensClassNames || Platform.IOS in tokensClassNames || Platform.VKCOM in tokensClassNames;
var getTokenClassNameByAppearance = (colorScheme, tokensClassNames) => tokensClassNames ? tokensClassNames[colorScheme] : void 0;
var getAppearanceTokenClassNameByPlatform = (platform3, tokensClassNames) => tokensClassNames ? tokensClassNames[platform3] : void 0;
var useTokensClassName = () => {
  const { platform: platform3, colorScheme = DEFAULT_COLOR_SCHEME, tokensClassNames } = React5.useContext(ConfigProviderContext);
  const colorSchemeClassName = isTokensClassNamesForPlatforms(tokensClassNames) ? getAppearanceTokenClassNameByPlatform(platform3, tokensClassNames) : tokensClassNames;
  const tokensClassName = getTokenClassNameByAppearance(colorScheme, colorSchemeClassName);
  return tokensClassName ? tokensClassName : DEFAULT_TOKENS_CLASS_NAMES[platform3][colorScheme];
};

// node_modules/@vkontakte/vkui/dist/hooks/useSyncHTMLWithTokens.js
function useSyncHTMLWithTokens({ appRootRef, enable }) {
  const tokenClassName = useTokensClassName();
  useIsomorphicLayoutEffect(() => {
    var _appRootRef_current;
    if (!enable) {
      return;
    }
    const htmlElement = (_appRootRef_current = appRootRef.current) === null || _appRootRef_current === void 0 ? void 0 : _appRootRef_current.ownerDocument.documentElement;
    htmlElement === null || htmlElement === void 0 ? void 0 : htmlElement.classList.add(tokenClassName);
    return () => {
      htmlElement === null || htmlElement === void 0 ? void 0 : htmlElement.classList.remove(tokenClassName);
    };
  }, [
    tokenClassName
  ]);
}

// node_modules/@vkontakte/vkui/dist/components/AppRoot/AppRootContext.js
var React6 = __toESM(require_react(), 1);
var DEFAULT_APP_ROOT_CONTEXT_VALUE = {
  appRoot: React6.createRef(),
  mode: "full",
  portalRoot: null,
  safeAreaInsets: void 0,
  embedded: false,
  keyboardInput: false,
  disablePortal: false
};
var AppRootContext = React6.createContext(DEFAULT_APP_ROOT_CONTEXT_VALUE);

// node_modules/@vkontakte/vkui/dist/components/AppRoot/AppRootStyleContainer/AppRootStyleContainer.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var React11 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivity.js
var React8 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/AdaptivityProvider/AdaptivityContext.js
var React7 = __toESM(require_react(), 1);
var AdaptivityContext = React7.createContext({});

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivity.js
var useAdaptivity = () => {
  return React8.useContext(AdaptivityContext);
};

// node_modules/@vkontakte/vkui/dist/components/RootComponent/RootComponent.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var React9 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/helpers/mergeStyle.js
function mergeStyle(a, b) {
  return a && b ? _object_spread({}, a, b) : a || b;
}

// node_modules/@vkontakte/vkui/dist/components/RootComponent/RootComponent.js
var RootComponent = (_param) => {
  var { Component: Component2 = "div", baseClassName, className, baseStyle, style, getRootRef } = _param, restProps = _object_without_properties(_param, [
    "Component",
    "baseClassName",
    "className",
    "baseStyle",
    "style",
    "getRootRef"
  ]);
  return (0, import_jsx_runtime2.jsx)(Component2, _object_spread({
    ref: getRootRef,
    className: clsx(className, baseClassName, "vkuiRootComponent__host", restProps.hidden === true && "vkuiRootComponent__hidden"),
    style: mergeStyle(baseStyle, style)
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/AppRoot/helpers.js
var React10 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/lib/isRefObject.js
var isRefObject = (refObject) => {
  return typeof refObject === "object" && refObject !== null && refObject.hasOwnProperty("current");
};

// node_modules/@vkontakte/vkui/dist/components/AppRoot/helpers.js
var CUSTOM_PROPERTY_INSET_PREFIX = `--vkui_internal--safe_area_inset_`;
function useSafeAreaInsetsMemo(safeAreaInsetsProp) {
  const { top, right, bottom, left } = safeAreaInsetsProp !== null && safeAreaInsetsProp !== void 0 ? safeAreaInsetsProp : {};
  const safeAreaInsets = React10.useMemo(() => ({
    top,
    right,
    bottom,
    left
  }), [
    top,
    right,
    bottom,
    left
  ]);
  return safeAreaInsets;
}
function getSafeAreaInsetsAsCssVariables(safeAreaInsets) {
  if (!safeAreaInsets) {
    return {};
  }
  const cssVariables = {};
  for (const key in safeAreaInsets) {
    if (safeAreaInsets.hasOwnProperty(key) && typeof safeAreaInsets[key] === "number") {
      const propertyKey = `${CUSTOM_PROPERTY_INSET_PREFIX}${key}`;
      const propertyValue = safeAreaInsets[key];
      cssVariables[propertyKey] = `${propertyValue}px`;
    }
  }
  return cssVariables;
}
function getUserSelectModeClassName({ userSelectMode, isWebView, hasPointer }) {
  switch (userSelectMode) {
    case "enabled-with-pointer": {
      if (hasPointer) {
        return null;
      }
      const enableByHasPointerMediaQuery = hasPointer === void 0;
      if (enableByHasPointerMediaQuery) {
        return "vkuiAppRootStyleContainer__pointerNone";
      }
      return "vkuiAppRootStyleContainer__userSelectNone";
    }
    case "disabled":
      return "vkuiAppRootStyleContainer__userSelectNone";
    case "enabled":
      return null;
    default:
      return isWebView ? "vkuiAppRootStyleContainer__userSelectNone" : null;
  }
}

// node_modules/@vkontakte/vkui/dist/components/AppRoot/AppRootStyleContainer/AppRootStyleContainer.js
var sizeYClassNames = {
  none: "vkuiAppRootStyleContainer__sizeYNone",
  compact: "vkuiAppRootStyleContainer__sizeYCompact"
};
function useAppRootStyles() {
  const { safeAreaInsets, mode, userSelectMode } = React11.useContext(AppRootContext);
  const { hasPointer, sizeY = "none" } = useAdaptivity();
  const { isWebView } = useConfigProvider();
  const userSelectModeClassName = getUserSelectModeClassName({
    userSelectMode,
    isWebView,
    hasPointer
  });
  const tokensClassName = useTokensClassName();
  return {
    style: safeAreaInsets ? getSafeAreaInsetsAsCssVariables(safeAreaInsets) : void 0,
    className: clsx("vkuiAppRootStyleContainer__host", mode === "embedded" && "vkuiAppRootStyleContainer__embedded", sizeY !== "regular" && sizeYClassNames[sizeY], userSelectModeClassName, tokensClassName)
  };
}
function AppRootStyleContainer(props) {
  const { style: appRootStyle, className: appRootClassName } = useAppRootStyles();
  return (0, import_jsx_runtime3.jsx)(RootComponent, _object_spread({
    baseClassName: appRootClassName,
    baseStyle: appRootStyle
  }, props));
}

// node_modules/@vkontakte/vkui/dist/components/AppRoot/ScrollContext.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var React12 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/helpers/math.js
var clamp2 = (value, min2, max2) => Math.max(min2, Math.min(value, max2));
function getDecimalPrecision(num) {
  if (Math.abs(num) < 1) {
    const parts = num.toExponential().split("e-");
    const matissaDecimalPart = parts[0].split(".")[1];
    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);
  }
  const decimalPart = num.toString().split(".")[1];
  return decimalPart ? decimalPart.length : 0;
}
function roundValueToStep(value, step, min2) {
  const nearest = Math.round((value - min2) / step) * step + min2;
  return Number(nearest.toFixed(getDecimalPrecision(step)));
}
function decimatedClamp(val, min2, max2, step) {
  if (step == null || step <= 0) {
    return clamp2(val, min2, max2);
  }
  const roundedValue = roundValueToStep(val, step, min2);
  return clamp2(roundedValue, min2, max2);
}
function rescale(value, from, to, options = {}) {
  const scaled = (value - from[0]) / (from[1] - from[0]) * (to[1] - to[0]) + to[0];
  return decimatedClamp(scaled, to[0], to[1], options.step);
}

// node_modules/@vkontakte/vkui/dist/components/AppRoot/ScrollContext.js
var clearDisableScrollStyle = (node) => {
  Object.assign(node.style, {
    position: "",
    top: "",
    left: "",
    right: "",
    overscrollBehavior: "",
    overflowY: "",
    overflowX: ""
  });
};
var getPageYOffsetWithoutKeyboardHeight = (window2, scrollTop) => {
  const diffOfClientHeightAndViewportHeight = window2.document.documentElement.clientHeight - window2.innerHeight;
  return scrollTop - diffOfClientHeightAndViewportHeight;
};
var ScrollContext = React12.createContext({
  getScroll: () => ({
    x: 0,
    y: 0
  }),
  scrollTo: noop,
  incrementScrollLockCounter: noop,
  decrementScrollLockCounter: noop
});
var useScroll = () => React12.useContext(ScrollContext);
function useScrollLockController(enableScrollLock, disableScrollLock) {
  const countRef = React12.useRef(0);
  const updateScrollLock = React12.useCallback(() => {
    if (countRef.current > 0) {
      enableScrollLock();
    } else {
      disableScrollLock();
    }
  }, [
    enableScrollLock,
    disableScrollLock
  ]);
  const incrementScrollLockCounter = React12.useCallback(() => {
    countRef.current += 1;
    updateScrollLock();
  }, [
    updateScrollLock
  ]);
  const decrementScrollLockCounter = React12.useCallback(() => {
    countRef.current -= 1;
    updateScrollLock();
  }, [
    updateScrollLock
  ]);
  return [
    incrementScrollLockCounter,
    decrementScrollLockCounter
  ];
}
function useManualScroll() {
  const { scrollTo, getScroll } = React12.useContext(ScrollContext);
  return React12.useMemo(() => ({
    scrollTo,
    getScroll
  }), [
    getScroll,
    scrollTo
  ]);
}
var _scrollTo = ({ x, y, scrollWidth, clientWidth, scrollHeight, clientHeight, scrollLockEnabled, lockedElement, elementToScroll }) => {
  const left = x ? clamp2(x, 0, scrollWidth - clientWidth) : 0;
  const top = y ? clamp2(y, 0, scrollHeight - clientHeight) : 0;
  if (scrollLockEnabled) {
    Object.assign(lockedElement.style, {
      left: `-${left}px`,
      top: `-${top}px`
    });
  } else {
    elementToScroll.scrollTo({
      left,
      top
    });
  }
};
var _getScroll = ({ xOffset, yOffset, element, scrollLockEnabled, customCalcY = (v) => v }) => {
  const elementStyles = element.style;
  const [scrollLeft, scrollTop] = scrollLockEnabled ? [
    -parseFloat(elementStyles.left || "0"),
    -parseFloat(elementStyles.top || "0")
  ] : [
    xOffset,
    yOffset
  ];
  return {
    x: scrollLeft || 0,
    y: customCalcY(scrollTop) || 0
  };
};
var GlobalScrollController = ({ children }) => {
  const { window: window2, document: document2 } = useDOM();
  const beforeScrollLockFnSetRef = React12.useRef(/* @__PURE__ */ new Set());
  const scrollLockEnabledRef = React12.useRef(false);
  const getScroll = React12.useCallback((options = {
    compensateKeyboardHeight: true
  }) => {
    if (!window2 || !document2) {
      return {
        x: 0,
        y: 0
      };
    }
    return _getScroll({
      xOffset: window2.pageXOffset,
      yOffset: window2.pageYOffset,
      element: document2.documentElement,
      scrollLockEnabled: scrollLockEnabledRef.current,
      customCalcY: (scrollTop) => options.compensateKeyboardHeight ? getPageYOffsetWithoutKeyboardHeight(window2, scrollTop) : scrollTop
    });
  }, [
    document2,
    window2
  ]);
  const scrollTo = React12.useCallback((x = 0, y = 0) => {
    if (!window2 || !document2) {
      return;
    }
    _scrollTo({
      x,
      y,
      scrollWidth: document2.body.scrollWidth,
      clientWidth: window2.innerWidth,
      scrollHeight: document2.body.scrollHeight,
      clientHeight: window2.innerHeight,
      scrollLockEnabled: scrollLockEnabledRef.current,
      lockedElement: document2.documentElement,
      elementToScroll: window2
    });
  }, [
    document2,
    window2
  ]);
  const enableScrollLock = React12.useCallback(() => {
    beforeScrollLockFnSetRef.current.forEach((fn) => {
      fn();
    });
    const { x: scrollX, y: scrollY } = getScroll({
      compensateKeyboardHeight: false
    });
    const overflowY = window2.innerWidth > document2.documentElement.clientWidth ? "scroll" : "";
    const overflowX = window2.innerHeight > document2.documentElement.clientHeight ? "scroll" : "";
    Object.assign(document2.documentElement.style, {
      position: "fixed",
      top: `-${scrollY}px`,
      left: `-${scrollX}px`,
      right: "0",
      overscrollBehavior: "none",
      overflowY,
      overflowX
    });
    scrollLockEnabledRef.current = true;
  }, [
    document2,
    getScroll,
    window2
  ]);
  const disableScrollLock = React12.useCallback(() => {
    const scrollData = getScroll({
      compensateKeyboardHeight: false
    });
    clearDisableScrollStyle(document2.documentElement);
    scrollLockEnabledRef.current = false;
    scrollTo(scrollData.x, scrollData.y);
  }, [
    document2,
    getScroll,
    scrollTo
  ]);
  const [incrementScrollLockCounter, decrementScrollLockCounter] = useScrollLockController(enableScrollLock, disableScrollLock);
  const scrollController = React12.useMemo(() => ({
    getScroll,
    scrollTo,
    incrementScrollLockCounter,
    decrementScrollLockCounter,
    beforeScrollLockFnSetRef
  }), [
    getScroll,
    scrollTo,
    incrementScrollLockCounter,
    decrementScrollLockCounter
  ]);
  return (0, import_jsx_runtime4.jsx)(ScrollContext.Provider, {
    value: scrollController,
    children
  });
};
var ElementScrollController = ({ elRef, children }) => {
  const beforeScrollLockFnSetRef = React12.useRef(/* @__PURE__ */ new Set());
  const scrollLockEnabledRef = React12.useRef(false);
  const getScroll = React12.useCallback(() => {
    const element = elRef.current;
    if (!element) {
      return {
        x: 0,
        y: 0
      };
    }
    return _getScroll({
      xOffset: element.scrollLeft,
      yOffset: element.scrollTop,
      element,
      scrollLockEnabled: scrollLockEnabledRef.current
    });
  }, [
    elRef
  ]);
  const scrollTo = React12.useCallback((x = 0, y = 0) => {
    const el = elRef.current;
    if (!el) {
      return;
    }
    _scrollTo({
      x,
      y,
      scrollWidth: el.scrollWidth,
      clientWidth: el.clientWidth,
      scrollHeight: el.scrollHeight,
      clientHeight: el.clientHeight,
      scrollLockEnabled: scrollLockEnabledRef.current,
      lockedElement: el,
      elementToScroll: el
    });
  }, [
    elRef
  ]);
  const enableScrollLock = React12.useCallback(() => {
    const el = elRef.current;
    if (!el) {
      return;
    }
    beforeScrollLockFnSetRef.current.forEach((fn) => {
      fn();
    });
    const { x: scrollX, y: scrollY } = getScroll();
    const overflowY = el.scrollWidth > el.clientWidth ? "scroll" : "";
    const overflowX = el.scrollHeight > el.clientHeight ? "scroll" : "";
    Object.assign(el.style, {
      position: "absolute",
      right: "0",
      top: `-${scrollY}px`,
      left: `-${scrollX}px`,
      overflowY,
      overflowX
    });
    scrollLockEnabledRef.current = true;
  }, [
    elRef,
    getScroll
  ]);
  const disableScrollLock = React12.useCallback(() => {
    const el = elRef.current;
    if (!el) {
      return;
    }
    const scrollData = getScroll();
    clearDisableScrollStyle(el);
    scrollLockEnabledRef.current = false;
    scrollTo(scrollData.x, scrollData.y);
  }, [
    elRef,
    getScroll,
    scrollTo
  ]);
  const [incrementScrollLockCounter, decrementScrollLockCounter] = useScrollLockController(enableScrollLock, disableScrollLock);
  const scrollController = React12.useMemo(() => ({
    getScroll,
    scrollTo,
    incrementScrollLockCounter,
    decrementScrollLockCounter,
    beforeScrollLockFnSetRef
  }), [
    getScroll,
    scrollTo,
    incrementScrollLockCounter,
    decrementScrollLockCounter
  ]);
  return (0, import_jsx_runtime4.jsx)(ScrollContext.Provider, {
    value: scrollController,
    children
  });
};
var useScrollLock = (enabled = true) => {
  const { incrementScrollLockCounter, decrementScrollLockCounter } = useScroll();
  React12.useEffect(() => {
    if (enabled) {
      incrementScrollLockCounter();
      return decrementScrollLockCounter;
    }
    return noop;
  }, [
    enabled,
    incrementScrollLockCounter,
    decrementScrollLockCounter
  ]);
};

// node_modules/@vkontakte/vkui/dist/components/AppRoot/AppRoot.js
var layoutClassNames2 = {
  card: "vkuiAppRoot__layoutCard",
  plain: "vkuiAppRoot__layoutPlain"
};
var AppRoot = (_param) => {
  var { children, mode = "full", scroll = "global", portalRoot, disablePortal = false, disableParentTransformForPositionFixedElements, safeAreaInsets: safeAreaInsetsProp, layout, userSelectMode, disableSettingVKUIClassesInRuntime, className } = _param, props = _object_without_properties(_param, [
    "children",
    "mode",
    "scroll",
    "portalRoot",
    "disablePortal",
    "disableParentTransformForPositionFixedElements",
    "safeAreaInsets",
    "layout",
    "userSelectMode",
    "disableSettingVKUIClassesInRuntime",
    "className"
  ]);
  const appRootRef = React13.useRef(null);
  const isKeyboardInputActiveRef = useKeyboardInputTracker();
  const safeAreaInsets = useSafeAreaInsetsMemo(safeAreaInsetsProp);
  const contextValue = React13.useMemo(() => ({
    appRoot: appRootRef,
    portalRoot,
    safeAreaInsets,
    embedded: mode === "embedded",
    mode,
    disablePortal,
    layout,
    get keyboardInput() {
      return isKeyboardInputActiveRef.current;
    },
    userSelectMode
  }), [
    portalRoot,
    disablePortal,
    isKeyboardInputActiveRef,
    layout,
    mode,
    safeAreaInsets,
    userSelectMode
  ]);
  useSyncHTMLWithTokens({
    appRootRef,
    enable: mode === "full"
  });
  useSyncHTMLWithBaseVKUIClasses({
    appRootRef,
    mode,
    layout,
    enable: mode !== "partial" && !disableSettingVKUIClassesInRuntime
  });
  const ScrollController = React13.useMemo(() => scroll === "contain" ? ElementScrollController : GlobalScrollController, [
    scroll
  ]);
  return mode === "partial" ? (0, import_jsx_runtime5.jsx)(AppRootContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime5.jsx)(ScrollController, {
      elRef: appRootRef,
      children
    })
  }) : (0, import_jsx_runtime5.jsx)(AppRootContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime5.jsx)(AppRootStyleContainer, _object_spread_props(_object_spread({
      getRootRef: appRootRef,
      className: clsx(className, "vkuiAppRoot__host", layout && layoutClassNames2[layout], mode === "embedded" && !disableParentTransformForPositionFixedElements ? "vkuiAppRoot__transformForPositionFixedElements" : void 0)
    }, props), {
      children: (0, import_jsx_runtime5.jsx)(ScrollController, {
        elRef: appRootRef,
        children
      })
    }))
  });
};

// node_modules/@vkontakte/vkui/dist/components/AppRoot/AppRootPortal.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var React17 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useColorScheme.js
function useColorScheme() {
  const { colorScheme } = useConfigProvider();
  return colorScheme !== null && colorScheme !== void 0 ? colorScheme : DEFAULT_COLOR_SCHEME;
}

// node_modules/@vkontakte/vkui/dist/lib/createPortal.js
var ReactDOM = __toESM(require_react_dom(), 1);
var createPortal2 = (children, container, key) => {
  const resolvedContainer = container ? container : getDocumentBody();
  return resolvedContainer && ReactDOM.createPortal(children, resolvedContainer, key);
};

// node_modules/@vkontakte/vkui/dist/components/ColorSchemeProvider/ColorSchemeProvider.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var React16 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/lib/tokens/TokensClassProvider.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var React14 = __toESM(require_react(), 1);
var InjectTokenClassNameToChild = ({ children }) => {
  const tokensClassName = useTokensClassName();
  return React14.cloneElement(children, {
    className: clsx(tokensClassName, "vkuitokens__defaultColor", children.props.className)
  });
};
var TokensClassProvider = ({ children }) => {
  return React14.Children.map(children, (child) => {
    if (React14.isValidElement(child)) {
      return (0, import_jsx_runtime6.jsx)(InjectTokenClassNameToChild, {
        children: child
      });
    }
    return child;
  });
};

// node_modules/@vkontakte/vkui/dist/components/ConfigProvider/ConfigProviderOverride.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var React15 = __toESM(require_react(), 1);
function ConfigProviderOverride(_param) {
  var { children } = _param, contextValue = _object_without_properties(_param, [
    "children"
  ]);
  const parentConfig = useConfigProvider();
  const configContext = useConfigProviderContextMemo(_object_spread({}, parentConfig, contextValue));
  return (0, import_jsx_runtime7.jsx)(ConfigProviderContext.Provider, {
    value: configContext,
    children
  });
}

// node_modules/@vkontakte/vkui/dist/components/ColorSchemeProvider/ColorSchemeProvider.js
var ColorSchemeProvider = ({ value, children }) => {
  return (0, import_jsx_runtime8.jsx)(ConfigProviderOverride, {
    colorScheme: value,
    children: (0, import_jsx_runtime8.jsx)(IconAppearanceProvider, {
      value,
      children: (0, import_jsx_runtime8.jsx)(TokensClassProvider, {
        children
      })
    })
  });
};

// node_modules/@vkontakte/vkui/dist/components/AppRoot/AppRootPortal.js
var AppRootPortal = ({ children, usePortal, className }) => {
  const { mode, disablePortal: disableCreatePortalInGlobalPortalRoot } = React17.useContext(AppRootContext);
  const colorScheme = useColorScheme();
  const canUsePortal = shouldUsePortal(usePortal, mode, Boolean(disableCreatePortalInGlobalPortalRoot));
  const portalContainer = usePortalContainer(usePortal);
  if (canUsePortal && portalContainer) {
    return createPortal2((0, import_jsx_runtime9.jsx)(ColorSchemeProvider, {
      value: colorScheme,
      children: (0, import_jsx_runtime9.jsx)(AppRootStyleContainer, {
        className,
        children
      })
    }), portalContainer);
  }
  return children;
};
function shouldUsePortal(usePortal, mode, disableCreatePortalInGlobalPortalRoot) {
  if (usePortal === void 0) {
    return disableCreatePortalInGlobalPortalRoot === false && mode !== "full";
  }
  if (typeof usePortal !== "boolean") {
    return true;
  }
  return disableCreatePortalInGlobalPortalRoot === false && usePortal === true;
}
function usePortalContainer(usePortal) {
  const { portalRoot: portalRootFromContext } = React17.useContext(AppRootContext);
  const { document: document2 } = useDOM();
  if (usePortal && typeof usePortal !== "boolean") {
    return isRefObject(usePortal) ? usePortal.current : usePortal;
  }
  const resolvedPortalFromContext = isRefObject(portalRootFromContext) ? portalRootFromContext.current : portalRootFromContext;
  const portalRoot = resolvedPortalFromContext || (document2 === null || document2 === void 0 ? void 0 : document2.body) || null;
  return portalRoot;
}

// node_modules/@vkontakte/vkui/dist/components/Typography/DisplayTitle/DisplayTitle.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);

// node_modules/@vkontakte/vkui/dist/components/Typography/Typography.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var React18 = __toESM(require_react(), 1);
var stylesWeight = {
  "1": "vkuiTypography__weight1",
  "2": "vkuiTypography__weight2",
  "3": "vkuiTypography__weight3"
};
var stylesAlign = {
  start: "vkuiTypography__alignStart",
  center: "vkuiTypography__alignCenter",
  end: "vkuiTypography__alignEnd"
};
function weightClassNames(weight, useAccentWeight = false) {
  if (!weight) {
    return "";
  }
  return clsx(stylesWeight[weight], useAccentWeight && "vkuiTypography__accent");
}
var Typography = (_param) => {
  var { weight, useAccentWeight, Component: Component2 = "span", normalize, inline: inline3, align } = _param, restProps = _object_without_properties(_param, [
    "weight",
    "useAccentWeight",
    "Component",
    "normalize",
    "inline",
    "align"
  ]);
  return (0, import_jsx_runtime10.jsx)(RootComponent, _object_spread({
    Component: Component2,
    baseClassName: clsx("vkuiTypography__host", normalize && "vkuiTypography__normalize", inline3 && "vkuiTypography__inline", weightClassNames(weight, useAccentWeight), align && stylesAlign[align])
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/DisplayTitle/DisplayTitle.js
var stylesLevel = {
  "1": "vkuiDisplayTitle__level1",
  "2": "vkuiDisplayTitle__level2",
  "3": "vkuiDisplayTitle__level3",
  "4": "vkuiDisplayTitle__level4"
};
var sizeYClassNames2 = {
  none: "vkuiDisplayTitle__sizeYNone",
  compact: "vkuiDisplayTitle__sizeYCompact"
};
var DisplayTitle = (_param) => {
  var { className, level = "1", Component: Component2 = "span", normalize = true, inline: inline3 = false } = _param, restProps = _object_without_properties(_param, [
    "className",
    "level",
    "Component",
    "normalize",
    "inline"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime11.jsx)(Typography, _object_spread({
    Component: Component2,
    normalize,
    inline: inline3,
    className: clsx(className, sizeY !== "regular" && sizeYClassNames2[sizeY], stylesLevel[level])
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Title/Title.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var stylesLevel2 = {
  "1": "vkuiTitle__level1",
  "2": "vkuiTitle__level2",
  "3": "vkuiTitle__level3"
};
var sizeYClassNames3 = {
  none: "vkuiTitle__sizeYNone",
  compact: "vkuiTitle__sizeYCompact"
};
var Title = (_param) => {
  var { className, level = "1", Component: Component2 = "span", normalize = true, inline: inline3 = false } = _param, restProps = _object_without_properties(_param, [
    "className",
    "level",
    "Component",
    "normalize",
    "inline"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime12.jsx)(Typography, _object_spread({
    Component: Component2,
    normalize,
    inline: inline3,
    className: clsx(className, sizeY !== "regular" && sizeYClassNames3[sizeY], stylesLevel2[level])
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Headline/Headline.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var stylesLevel3 = {
  "1": "vkuiHeadline__level1",
  "2": "vkuiHeadline__level2"
};
var sizeYClassNames4 = {
  none: "vkuiHeadline__sizeYNone",
  compact: "vkuiHeadline__sizeYCompact"
};
var Headline = (_param) => {
  var { className, level = "1", Component: Component2 = "span", normalize = true, inline: inline3 = false } = _param, restProps = _object_without_properties(_param, [
    "className",
    "level",
    "Component",
    "normalize",
    "inline"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime13.jsx)(Typography, _object_spread({
    Component: Component2,
    normalize,
    inline: inline3,
    className: clsx(className, sizeY !== "regular" && sizeYClassNames4[sizeY], stylesLevel3[level])
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Text/Text.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var sizeYClassNames5 = {
  none: "vkuiText__sizeYNone",
  compact: "vkuiText__sizeYCompact"
};
var Text = (_param) => {
  var { className, Component: Component2 = "span", normalize = true, inline: inline3 = false } = _param, restProps = _object_without_properties(_param, [
    "className",
    "Component",
    "normalize",
    "inline"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime14.jsx)(Typography, _object_spread({
    Component: Component2,
    normalize,
    inline: inline3,
    className: clsx(className, "vkuiText__host", sizeY !== "regular" && sizeYClassNames5[sizeY])
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Paragraph/Paragraph.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var sizeYClassNames6 = {
  none: "vkuiParagraph__sizeYNone",
  compact: "vkuiParagraph__sizeYCompact"
};
var Paragraph = (_param) => {
  var { className, Component: Component2 = "span", normalize = false, inline: inline3 = false } = _param, restProps = _object_without_properties(_param, [
    "className",
    "Component",
    "normalize",
    "inline"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime15.jsx)(Typography, _object_spread({
    Component: Component2,
    normalize,
    inline: inline3,
    className: clsx(className, "vkuiParagraph__host", sizeY !== "regular" && sizeYClassNames6[sizeY])
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Subhead/Subhead.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var sizeYClassNames7 = {
  none: "vkuiSubhead__sizeYNone",
  compact: "vkuiSubhead__sizeYCompact"
};
var Subhead = (_param) => {
  var { className, Component: Component2 = "span", normalize = true, inline: inline3 = false } = _param, restProps = _object_without_properties(_param, [
    "className",
    "Component",
    "normalize",
    "inline"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime16.jsx)(Typography, _object_spread({
    Component: Component2,
    normalize,
    inline: inline3,
    className: clsx(className, "vkuiSubhead__host", sizeY !== "regular" && sizeYClassNames7[sizeY])
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Footnote/Footnote.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var sizeYClassNames8 = {
  none: "vkuiFootnote__sizeYNone",
  compact: "vkuiFootnote__sizeYCompact"
};
function footnoteClassNames(sizeY, caps = false) {
  return clsx("vkuiFootnote__host", sizeY !== "regular" && sizeYClassNames8[sizeY], caps && "vkuiFootnote__caps");
}
var Footnote = (_param) => {
  var { className, caps, Component: Component2 = "span", normalize = true, inline: inline3 = false } = _param, restProps = _object_without_properties(_param, [
    "className",
    "caps",
    "Component",
    "normalize",
    "inline"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime17.jsx)(Typography, _object_spread({
    Component: Component2,
    normalize,
    inline: inline3,
    className: clsx(className, footnoteClassNames(sizeY, caps))
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Caption/Caption.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var stylesLevel4 = {
  "1": "vkuiCaption__level1",
  "2": "vkuiCaption__level2",
  "3": "vkuiCaption__level3"
};
var sizeYClassNames9 = {
  none: "vkuiCaption__sizeYNone",
  compact: "vkuiCaption__sizeYCompact"
};
function captionClassNames(sizeY, level = "1", caps = false) {
  return clsx(sizeY !== "regular" && sizeYClassNames9[sizeY], caps && "vkuiCaption__caps", stylesLevel4[level]);
}
var Caption = (_param) => {
  var { className, level = "1", caps, Component: Component2 = "span", normalize = true, inline: inline3 = false } = _param, restProps = _object_without_properties(_param, [
    "className",
    "level",
    "caps",
    "Component",
    "normalize",
    "inline"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime18.jsx)(Typography, _object_spread({
    Component: Component2,
    normalize,
    inline: inline3,
    className: clsx(className, captionClassNames(sizeY, level, caps))
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/EllipsisText/EllipsisText.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);
var EllipsisText = (_param) => {
  var { Component: Component2 = "span", className, children, maxWidth, maxLines = 1, disableNativeTitle = false } = _param, restProps = _object_without_properties(_param, [
    "Component",
    "className",
    "children",
    "maxWidth",
    "maxLines",
    "disableNativeTitle"
  ]);
  const contentRef = (0, import_react2.useRef)(null);
  useIsomorphicLayoutEffect(() => {
    if (contentRef && contentRef.current) {
      contentRef.current.style.setProperty("-webkit-line-clamp", maxLines > 1 ? `${maxLines}` : "");
    }
  }, [
    contentRef,
    maxLines
  ]);
  return (0, import_jsx_runtime19.jsx)(RootComponent, _object_spread_props(_object_spread({
    Component: Component2,
    className: clsx("vkuiEllipsisText__host", disableNativeTitle && "vkuiEllipsisText__disableNativeTitle", className),
    title: disableNativeTitle ? void 0 : getTextFromChildren(children)
  }, restProps), {
    children: (0, import_jsx_runtime19.jsx)("span", {
      style: {
        maxWidth
      },
      ref: contentRef,
      className: clsx("vkuiEllipsisText__content", maxLines > 1 && "vkuiEllipsisText__contentMultiline"),
      children
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/UnstyledTextField/UnstyledTextField.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var React19 = __toESM(require_react(), 1);
var UnstyledTextField = (_param) => {
  var { as, noPadding = false, className } = _param, restProps = _object_without_properties(_param, [
    "as",
    "noPadding",
    "className"
  ]);
  return (0, import_jsx_runtime20.jsx)(Text, _object_spread({
    Component: as,
    normalize: false,
    className: clsx("vkuiUnstyledTextField__host", noPadding && "vkuiUnstyledTextField__noPadding", className)
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Tappable/Tappable.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);

// node_modules/@vkontakte/vkui/dist/lib/adaptivity/constants.js
var ViewWidth = {
  SMALL_MOBILE: 1,
  MOBILE: 2,
  SMALL_TABLET: 3,
  TABLET: 4,
  DESKTOP: 5
};
var ViewHeight = {
  EXTRA_SMALL: 1,
  SMALL: 2,
  MEDIUM: 3
};
var SizeType = {
  COMPACT: "compact",
  REGULAR: "regular"
};
var VIEW_WIDTH_TO_CSS_BREAKPOINT_MAP = {
  [ViewWidth.SMALL_MOBILE]: "smallMobileMinus",
  [ViewWidth.MOBILE]: "mobile",
  [ViewWidth.SMALL_TABLET]: "smallTablet",
  [ViewWidth.TABLET]: "tablet",
  [ViewWidth.DESKTOP]: "desktopPlus"
};

// node_modules/@vkontakte/vkui/dist/lib/adaptivity/breakpoints.js
var BREAKPOINTS = {
  DESKTOP: 1280,
  TABLET: 1024,
  SMALL_TABLET: 768,
  MOBILE: 320,
  MOBILE_LANDSCAPE_HEIGHT: 415,
  MEDIUM_HEIGHT: 720
};
function widthPlus(a) {
  return `(min-width: ${a}px)`;
}
function widthMinus(b) {
  return `(max-width: ${b - 0.1}px)`;
}
function widthHalfInterval(a, b) {
  return `${widthPlus(a)} and ${widthMinus(b)}`;
}
function heightPlus(a) {
  return `(min-height: ${a}px)`;
}
var MEDIA_QUERIES = {
  DESKTOP_PLUS: widthPlus(BREAKPOINTS.DESKTOP),
  TABLET: widthHalfInterval(BREAKPOINTS.TABLET, BREAKPOINTS.DESKTOP),
  SMALL_TABLET_PLUS: widthPlus(BREAKPOINTS.SMALL_TABLET),
  SMALL_TABLET: widthHalfInterval(BREAKPOINTS.SMALL_TABLET, BREAKPOINTS.TABLET),
  MOBILE: widthHalfInterval(BREAKPOINTS.MOBILE, BREAKPOINTS.SMALL_TABLET),
  MEDIUM_HEIGHT: heightPlus(BREAKPOINTS.MEDIUM_HEIGHT),
  MOBILE_LANDSCAPE_HEIGHT: heightPlus(BREAKPOINTS.MOBILE_LANDSCAPE_HEIGHT)
};

// node_modules/@vkontakte/vkui/dist/lib/adaptivity/functions.js
function getViewWidthByViewportWidth(viewportWidth) {
  if (viewportWidth >= BREAKPOINTS.DESKTOP) {
    return ViewWidth.DESKTOP;
  }
  if (viewportWidth >= BREAKPOINTS.TABLET) {
    return ViewWidth.TABLET;
  }
  if (viewportWidth >= BREAKPOINTS.SMALL_TABLET) {
    return ViewWidth.SMALL_TABLET;
  }
  if (viewportWidth >= BREAKPOINTS.MOBILE) {
    return ViewWidth.MOBILE;
  }
  return ViewWidth.SMALL_MOBILE;
}
function getViewWidthByMediaQueries(mediaQueries) {
  if (mediaQueries.desktopPlus.matches) {
    return ViewWidth.DESKTOP;
  }
  if (mediaQueries.tablet.matches) {
    return ViewWidth.TABLET;
  }
  if (mediaQueries.smallTablet.matches) {
    return ViewWidth.SMALL_TABLET;
  }
  if (mediaQueries.mobile.matches) {
    return ViewWidth.MOBILE;
  }
  return ViewWidth.SMALL_MOBILE;
}
function getViewHeightByViewportHeight(viewportHeight) {
  if (viewportHeight >= BREAKPOINTS.MEDIUM_HEIGHT) {
    return ViewHeight.MEDIUM;
  }
  if (viewportHeight >= BREAKPOINTS.MOBILE_LANDSCAPE_HEIGHT) {
    return ViewHeight.SMALL;
  }
  return ViewHeight.EXTRA_SMALL;
}
function getViewHeightByMediaQueries(mediaQueries) {
  if (mediaQueries.mediumHeight.matches) {
    return ViewHeight.MEDIUM;
  }
  if (mediaQueries.mobileLandscapeHeight.matches) {
    return ViewHeight.SMALL;
  }
  return ViewHeight.EXTRA_SMALL;
}
function getSizeX(viewWidth) {
  return viewWidth <= ViewWidth.MOBILE ? "compact" : "regular";
}
function isCompactByViewWidth(viewWidth, hasPointer) {
  return viewWidth !== void 0 && viewWidth >= ViewWidth.SMALL_TABLET && hasPointer;
}
function isCompactByViewHeight(viewHeight) {
  return viewHeight !== void 0 && viewHeight <= ViewHeight.EXTRA_SMALL;
}
function getSizeY(viewWidth, viewHeight, hasPointer) {
  if (isCompactByViewWidth(viewWidth, hasPointer) || isCompactByViewHeight(viewHeight)) {
    return "compact";
  }
  return "regular";
}
function tryToCheckIsDesktop(viewWidth, viewHeight, hasPointer, platform3) {
  const IS_VKCOM_CRUTCH = platform3 === "vkcom";
  if ((viewWidth === void 0 || hasPointer === void 0) && (viewWidth === void 0 || viewHeight === void 0) || hasPointer === void 0 && viewHeight === void 0) {
    return IS_VKCOM_CRUTCH ? true : null;
  }
  const widthIsLikeDesktop = viewWidth >= ViewWidth.SMALL_TABLET;
  const otherParametersIsLikeDesktop = hasPointer || (viewHeight !== void 0 ? viewHeight >= ViewHeight.MEDIUM : false);
  return widthIsLikeDesktop && otherParametersIsLikeDesktop || IS_VKCOM_CRUTCH;
}
function viewWidthToClassName(breakpointClassNames2, viewWidth = "none") {
  if (viewWidth === "none") {
    return breakpointClassNames2.hasOwnProperty("none") ? breakpointClassNames2["none"] : null;
  }
  const breakpoints = [];
  const breakpointName = VIEW_WIDTH_TO_CSS_BREAKPOINT_MAP[viewWidth];
  if (breakpointClassNames2.hasOwnProperty(breakpointName)) {
    breakpoints.push(breakpointClassNames2[breakpointName]);
  }
  if (viewWidth >= ViewWidth.MOBILE) {
    if (breakpointClassNames2.hasOwnProperty("mobilePlus")) {
      breakpoints.push(breakpointClassNames2["mobilePlus"]);
    }
  }
  if (viewWidth >= ViewWidth.SMALL_TABLET) {
    if (breakpointClassNames2.hasOwnProperty("smallTabletPlus")) {
      breakpoints.push(breakpointClassNames2["smallTabletPlus"]);
    }
  } else {
    if (breakpointClassNames2.hasOwnProperty("smallTabletMinus")) {
      breakpoints.push(breakpointClassNames2["smallTabletMinus"]);
    }
  }
  if (viewWidth >= ViewWidth.TABLET) {
    if (breakpointClassNames2.hasOwnProperty("tabletPlus")) {
      breakpoints.push(breakpointClassNames2["tabletPlus"]);
    }
  } else {
    if (breakpointClassNames2.hasOwnProperty("tabletMinus")) {
      breakpoints.push(breakpointClassNames2["tabletMinus"]);
    }
  }
  return breakpoints.length > 0 ? breakpoints.join(" ") : null;
}

// node_modules/@vkontakte/vkui/dist/lib/callMultiple.js
var callMultiple = (...fns) => (...args) => fns.filter((f) => typeof f === "function").forEach((f) => f(...args));

// node_modules/@vkontakte/vkui/dist/lib/mergeCalls.js
function mergeCalls(...props) {
  const objectToArrays = props.reduce((record, obj) => {
    Object.entries(obj).forEach(([key, value]) => {
      if (!record.hasOwnProperty(key)) {
        record[key] = [];
      }
      record[key].push(value);
    });
    return record;
  }, {});
  return Object.entries(objectToArrays).reduce((record, [key, array]) => {
    record[key] = callMultiple(...array);
    return record;
  }, {});
}

// node_modules/@vkontakte/vkui/dist/components/Clickable/Clickable.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var React23 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useFocusVisible.js
var import_react3 = __toESM(require_react(), 1);
function useFocusVisible() {
  const [isFocused, setIsFocused] = (0, import_react3.useState)(false);
  const withKeyboardInputCheck = true;
  const { keyboardInput } = (0, import_react3.useContext)(AppRootContext);
  const onFocus = (0, import_react3.useCallback)((event) => {
    event.stopPropagation();
    setIsFocused(true);
  }, [
    setIsFocused
  ]);
  const onBlur = (0, import_react3.useCallback)((event) => {
    event.stopPropagation();
    setIsFocused(false);
  }, [
    setIsFocused
  ]);
  const focusVisible = withKeyboardInputCheck ? keyboardInput && isFocused : isFocused;
  return {
    focusVisible,
    onFocus,
    onBlur
  };
}

// node_modules/@vkontakte/vkui/dist/hooks/useFocusVisibleClassName.js
var focusVisiblePresetModeClassNames = {
  inside: "vkuistyles__-focus-visible--mode-inside",
  outside: "vkuistyles__-focus-visible--mode-outside"
};
var isPresetMode = (mode) => mode === "inside" || mode === "outside";
function useFocusVisibleClassName({ focusVisible = false, mode = "inside" }) {
  const modeClassName = isPresetMode(mode) ? focusVisiblePresetModeClassNames[mode] : mode;
  const focusVisibleClassNames = clsx("vkuistyles__-focus-visible", focusVisible && "vkuistyles__-focus-visible--focused", focusVisible && modeClassName);
  return focusVisibleClassNames;
}

// node_modules/@vkontakte/vkui/dist/lib/utils.js
var React20 = __toESM(require_react(), 1);
function setRef(element1, ref) {
  if (ref) {
    if (typeof ref === "function") {
      ref(element1);
    } else {
      ref.current = element1;
    }
  }
}
var stopPropagation = (event) => event.stopPropagation();
var preventDefault = (event) => event.preventDefault();
var excludeKeysWithUndefined = (obj) => {
  const filteredObj = {};
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && obj[key] !== void 0) {
      filteredObj[key] = obj[key];
    }
  }
  return filteredObj;
};
var isDOMTypeElement = (element1) => typeof element1.type === "string";
function isValidNotReactFragmentElement(children) {
  return React20.isValidElement(children) && // @ts-expect-error: TS2339 $$typeof всегда symbol, в отличии от type, благодаря этому пропускаем лишние проверки на тип.
  children.$$typeof !== /* @__PURE__ */ Symbol.for("react.fragment");
}
function isForwardRefElement(children) {
  if (!React20.isValidElement(children)) {
    return false;
  }
  const typeOfOfType = children.type && children.type.$$typeof;
  return typeOfOfType === /* @__PURE__ */ Symbol.for("react.forward_ref");
}
function getFetchPriorityProp(value) {
  if (React20.version.startsWith("19")) {
    return {
      fetchPriority: value
    };
  }
  return {
    fetchpriority: value
  };
}
function clickByKeyboardHandler(event) {
  var _event_target_click, _event_target;
  if (!isHTMLElement(event.target) || !shouldTriggerClickOnEnterOrSpace(event)) {
    return;
  }
  event.preventDefault();
  (_event_target_click = (_event_target = event.target).click) === null || _event_target_click === void 0 ? void 0 : _event_target_click.call(_event_target);
}

// node_modules/@vkontakte/vkui/dist/components/Clickable/useState.js
var React22 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/Clickable/useStateWithDelay.js
var React21 = __toESM(require_react(), 1);
function useStateWithDelay(initialState, defaultDelay = 0, onStateChange = noop) {
  const [value, setValue] = React21.useState(initialState);
  const timeout = React21.useRef(void 0);
  const handleSetValue = React21.useCallback((nextValue) => {
    if (isFunction(nextValue)) {
      setValue((prevValue) => {
        const value2 = nextValue(prevValue);
        onStateChange(value2);
        return value2;
      });
    } else {
      setValue(nextValue);
      onStateChange(nextValue);
    }
  }, [
    onStateChange
  ]);
  const setValueWithDelay = React21.useCallback((newValue, delay = defaultDelay) => {
    clearTimeout(timeout.current);
    if (delay === 0) {
      handleSetValue(newValue);
      return;
    }
    timeout.current = setTimeout(() => handleSetValue(newValue), delay);
  }, [
    defaultDelay,
    handleSetValue
  ]);
  return [
    value,
    setValueWithDelay
  ];
}

// node_modules/@vkontakte/vkui/dist/components/Clickable/useState.js
var DEFAULT_ACTIVE_EFFECT_DELAY = 600;
var ACTIVE_DELAY = 70;
function useHover({ hovered, hasHover: hasHover2 = true, lockState = false, setParentStateLock = noop } = {}) {
  const [hoveredStateLocal, setHoveredStateLocal] = React22.useState(false);
  const prevIsHoveredRef = React22.useRef(void 0);
  const handleHover = React22.useCallback((isHover) => {
    setHoveredStateLocal(isHover);
    const isHovered2 = hovered !== null && hovered !== void 0 ? hovered : calculateStateValue({
      hasState: hasHover2,
      isLocked: lockState,
      stateValueLocal: isHover
    });
    if (isHovered2 !== prevIsHoveredRef.current) {
      prevIsHoveredRef.current = isHovered2;
      setParentStateLock(isHovered2);
    }
  }, [
    setParentStateLock,
    hasHover2,
    hovered,
    lockState
  ]);
  const onPointerEnter = (e) => {
    if (e.pointerType === "touch") {
      return;
    }
    handleHover(true);
  };
  const onPointerLeave = () => {
    handleHover(false);
  };
  const isHovered = hovered !== null && hovered !== void 0 ? hovered : calculateStateValue({
    hasState: hasHover2,
    isLocked: lockState,
    stateValueLocal: hoveredStateLocal
  });
  return {
    isHovered,
    onPointerEnter: hasHover2 ? onPointerEnter : noop,
    onPointerLeave: hasHover2 ? onPointerLeave : noop
  };
}
function useActive({ activated, activeEffectDelay, hasActive = true, lockStateRef, setParentStateLock }) {
  const [activatedState, setActivated] = useStateWithDelay(false, 0, setParentStateLock);
  const pointersUp = React22.useMemo(() => /* @__PURE__ */ new Set(), []);
  const onPointerDown = () => {
    if (lockStateRef.current) {
      return;
    }
    setActivated(true, ACTIVE_DELAY);
    setParentStateLock(true);
  };
  const onPointerCancel = (e) => {
    if (pointersUp.has(e.pointerId)) {
      pointersUp.delete(e.pointerId);
      return;
    }
    setActivated(false);
  };
  const onPointerUp = (e) => {
    pointersUp.add(e.pointerId);
    if (lockStateRef.current) {
      return;
    }
    setActivated(true);
    setActivated(false, activeEffectDelay);
  };
  const isActivated = activated !== null && activated !== void 0 ? activated : calculateStateValue({
    hasState: hasActive,
    isLocked: lockStateRef.current,
    stateValueLocal: activatedState
  });
  return {
    isActivated,
    onPointerLeave: hasActive ? onPointerCancel : noop,
    onPointerDown: hasActive ? onPointerDown : noop,
    onPointerCancel: hasActive ? onPointerCancel : noop,
    onPointerUp: hasActive ? onPointerUp : noop
  };
}
var ClickableLockStateContext = React22.createContext({
  lockHoverStateBubbling: void 0,
  lockActiveStateBubbling: void 0
});
function useLockState(setParentStateLockBubbling) {
  const [lockState, setLockState] = React22.useState(false);
  const setStateLockBubblingImmediate = React22.useCallback((isLock) => {
    setLockState(isLock);
    setParentStateLockBubbling(isLock);
  }, [
    setParentStateLockBubbling
  ]);
  return [
    lockState,
    setParentStateLockBubbling,
    setStateLockBubblingImmediate
  ];
}
function useLockRef(setParentStateLockBubbling) {
  const lockStateRef = React22.useRef(false);
  const setStateLockBubblingImmediate = React22.useCallback((isLock) => {
    lockStateRef.current = isLock;
    setParentStateLockBubbling(isLock);
  }, [
    setParentStateLockBubbling
  ]);
  return [
    lockStateRef,
    setParentStateLockBubbling,
    setStateLockBubblingImmediate
  ];
}
function useState4({ hovered, hasHover: hasHover2, activated, hasActive, activeEffectDelay, unlockParentHover, hoverClassName, activeClassName }) {
  const { lockHoverStateBubbling = noop, lockActiveStateBubbling = noop } = React22.useContext(ClickableLockStateContext);
  const [lockHoverState, setParentStateLockHoverBubbling, setLockHoverBubblingImmediate] = useLockState(unlockParentHover ? noop : lockHoverStateBubbling);
  const [lockActiveStateRef, setParentStateLockActiveBubbling, setLockActiveBubblingImmediate] = useLockRef(lockActiveStateBubbling);
  const _useHover = useHover({
    hasHover: hasHover2,
    hovered,
    lockState: lockHoverState,
    setParentStateLock: setParentStateLockHoverBubbling
  }), { isHovered } = _useHover, hoverEvent = _object_without_properties(_useHover, [
    "isHovered"
  ]);
  const _useActive = useActive({
    activated,
    hasActive,
    activeEffectDelay,
    lockStateRef: lockActiveStateRef,
    setParentStateLock: setParentStateLockActiveBubbling
  }), { isActivated } = _useActive, activeEvent = _object_without_properties(_useActive, [
    "isActivated"
  ]);
  const stateClassName = clsx(isHovered && hoverClassName, isActivated && activeClassName);
  const handlers = mergeCalls(hoverEvent, activeEvent);
  return _object_spread({
    stateClassName,
    setLockHoverBubblingImmediate,
    setLockActiveBubblingImmediate
  }, handlers);
}
function calculateStateValue({ hasState, isLocked, stateValueLocal }) {
  return hasState && !isLocked && stateValueLocal;
}

// node_modules/@vkontakte/vkui/dist/components/Clickable/Clickable.js
function nonClickableProps(_param) {
  var { href, onClick, onClickCapture, activeClassName, hoverClassName, hasActive, hasHover: hasHover2, hovered, unlockParentHover, activated, activeEffectDelay, focusVisibleMode, DefaultComponent, Component: Component2 } = _param, restProps = _object_without_properties(_param, [
    "href",
    "onClick",
    "onClickCapture",
    "activeClassName",
    "hoverClassName",
    "hasActive",
    "hasHover",
    "hovered",
    "unlockParentHover",
    "activated",
    "activeEffectDelay",
    "focusVisibleMode",
    "DefaultComponent",
    "Component"
  ]);
  return _object_spread_props(_object_spread({
    Component: Component2 || DefaultComponent
  }, restProps), {
    lockStateContextValue: {
      lockHoverStateBubbling: void 0,
      lockActiveStateBubbling: void 0
    }
  });
}
function useClickableProps(_param) {
  var { baseClassName, focusVisibleMode = "inside", activeClassName, hoverClassName, activeEffectDelay = DEFAULT_ACTIVE_EFFECT_DELAY, hasHover: hasHover2 = true, hasActive = true, hovered, activated, hasHoverWithChildren, unlockParentHover, onPointerEnter, onPointerLeave, onPointerDown, onPointerCancel, onPointerUp, onBlur, onFocus, onKeyDown, DefaultComponent } = _param, restProps = _object_without_properties(_param, [
    "baseClassName",
    "focusVisibleMode",
    "activeClassName",
    "hoverClassName",
    "activeEffectDelay",
    "hasHover",
    "hasActive",
    "hovered",
    "activated",
    "hasHoverWithChildren",
    "unlockParentHover",
    "onPointerEnter",
    "onPointerLeave",
    "onPointerDown",
    "onPointerCancel",
    "onPointerUp",
    "onBlur",
    "onFocus",
    "onKeyDown",
    "DefaultComponent"
  ]);
  const _useFocusVisible = useFocusVisible(), { focusVisible } = _useFocusVisible, focusEvents = _object_without_properties(_useFocusVisible, [
    "focusVisible"
  ]);
  const focusVisibleClassNames = useFocusVisibleClassName({
    focusVisible,
    mode: focusVisibleMode
  });
  const _useState = useState4({
    activeClassName,
    hoverClassName,
    activeEffectDelay,
    hasHover: hasHover2,
    hasActive,
    hovered,
    activated,
    unlockParentHover
  }), { stateClassName, setLockHoverBubblingImmediate, setLockActiveBubblingImmediate } = _useState, stateEvents = _object_without_properties(_useState, [
    "stateClassName",
    "setLockHoverBubblingImmediate",
    "setLockActiveBubblingImmediate"
  ]);
  const handlers = mergeCalls(focusEvents, stateEvents, {
    onKeyDown: clickByKeyboardHandler
  }, {
    onPointerEnter,
    onPointerLeave,
    onPointerDown,
    onPointerCancel,
    onPointerUp,
    onBlur,
    onFocus,
    onKeyDown
  });
  const lockStateContextValue = React23.useMemo(() => ({
    lockHoverStateBubbling: hasHoverWithChildren ? noop : setLockHoverBubblingImmediate,
    lockActiveStateBubbling: setLockActiveBubblingImmediate
  }), [
    setLockHoverBubblingImmediate,
    setLockActiveBubblingImmediate,
    hasHoverWithChildren
  ]);
  return _object_spread_props(_object_spread({
    baseClassName: clsx(baseClassName, "vkuiClickable__realClickable", focusVisibleClassNames, stateClassName)
  }, handlers, restProps), {
    lockStateContextValue
  });
}
function useProps(props) {
  const commonProps = component(props);
  const isClickable = checkClickable(props);
  const { baseClassName, disabled, Component: Component2 } = props, restProps = _object_without_properties(props, [
    "baseClassName",
    "disabled",
    "Component"
  ]);
  const nextProps = _object_spread({
    baseClassName: clsx(baseClassName, "vkuiClickable__host")
  }, commonProps, restProps);
  const clickableProps = useClickableProps(nextProps);
  return isClickable ? clickableProps : nonClickableProps(nextProps);
}
function checkClickable(props) {
  return (props.href !== void 0 || props.onClick !== void 0 || props.onClickCapture !== void 0 || props.Component === "a" || props.Component === "button" || props.Component === "label" || props.Component === "input") && !props.disabled;
}
function component({ Component: Component2, DefaultComponent = "div", onClick, onClickCapture, href, disabled }) {
  if (Component2 !== void 0) {
    return {
      Component: Component2,
      disabled
    };
  } else if (href !== void 0) {
    return _object_spread({
      Component: "a"
    }, disabled && {
      "aria-disabled": true,
      "role": "link"
    });
  } else if (onClick !== void 0 || onClickCapture !== void 0) {
    return _object_spread({
      Component: DefaultComponent,
      role: "button"
    }, disabled ? {
      "aria-disabled": true
    } : {
      tabIndex: 0
    });
  }
  return {};
}
var Clickable = (props) => {
  const _useProps = useProps(props), { lockStateContextValue, children } = _useProps, restProps = _object_without_properties(_useProps, [
    "lockStateContextValue",
    "children"
  ]);
  return (0, import_jsx_runtime21.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    children: (0, import_jsx_runtime21.jsx)(ClickableLockStateContext.Provider, {
      value: lockStateContextValue,
      children
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Tappable/Ripple.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var React24 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/usePlatform.js
function usePlatform() {
  const { platform: platform3 } = useConfigProvider();
  return platform3;
}

// node_modules/@vkontakte/vkui/dist/lib/offset.js
function getOffsetRect2(elem) {
  const box = elem === null || elem === void 0 ? void 0 : elem.getBoundingClientRect();
  return {
    top: box === null || box === void 0 ? void 0 : box.top,
    left: box === null || box === void 0 ? void 0 : box.left,
    width: elem === null || elem === void 0 ? void 0 : elem.offsetWidth,
    height: elem === null || elem === void 0 ? void 0 : elem.offsetHeight
  };
}

// node_modules/@vkontakte/vkui/dist/components/Tappable/Ripple.js
var useMaybeNeedRipple = (activeMode, hasPointer) => {
  const platform3 = usePlatform();
  return platform3 === "android" && !hasPointer && activeMode === "background";
};
var DELAY = 70;
var WAVE_LIVE = 225;
var useRipple = (needRipple, hasPointerContext) => {
  const [clicks, setClicks] = React24.useState([]);
  const pointerDelayTimers = React24.useMemo(() => /* @__PURE__ */ new Map(), []);
  React24.useEffect(function setClearClicksTimeout() {
    const clicksTimeoutId = clicks.length > 0 ? setTimeout(() => setClicks([]), WAVE_LIVE) : null;
    return function cancelClearClicksTimeout() {
      if (clicksTimeoutId) {
        clearTimeout(clicksTimeoutId);
      }
    };
  }, [
    clicks
  ]);
  function addClick(x, y, pointerId) {
    const dateNow = Date.now();
    const filteredClicks = clicks.filter((click) => click.id + WAVE_LIVE > dateNow);
    setClicks([
      ...filteredClicks,
      {
        x,
        y,
        id: dateNow,
        pointerId
      }
    ]);
    pointerDelayTimers.delete(pointerId);
  }
  const onPointerDown = (e) => {
    const { top, left } = getOffsetRect2(e.currentTarget);
    const x = e.clientX - (left !== null && left !== void 0 ? left : 0);
    const y = e.clientY - (top !== null && top !== void 0 ? top : 0);
    pointerDelayTimers.set(e.pointerId, setTimeout(() => addClick(x, y, e.pointerId), DELAY));
  };
  const onPointerCancel = (e) => {
    const timer = pointerDelayTimers.get(e.pointerId);
    clearTimeout(timer);
    pointerDelayTimers.delete(e.pointerId);
  };
  const reallyNeedRipple = (!hasMouse || hasPointerContext === false) && needRipple;
  return {
    clicks,
    onPointerDown: reallyNeedRipple ? onPointerDown : noop,
    onPointerCancel: reallyNeedRipple ? onPointerCancel : noop
  };
};
var Ripple = ({ needRipple = true, clicks }) => {
  return (0, import_jsx_runtime22.jsx)("span", {
    "aria-hidden": true,
    className: clsx("vkuiTappable__stateLayer", needRipple && "vkuiTappable__ripple"),
    children: clicks.map((wave) => (0, import_jsx_runtime22.jsx)("span", {
      className: "vkuiTappable__wave",
      style: {
        top: wave.y,
        left: wave.x
      }
    }, wave.id))
  });
};

// node_modules/@vkontakte/vkui/dist/components/Tappable/state.js
var DEFAULT_STATE_MODE = "background";
var stylesHovered = {
  background: "vkuiTappable__hoveredBackground",
  opacity: "vkuiTappable__hoveredOpacity",
  none: ""
};
function hoverClass(hoverMode = DEFAULT_STATE_MODE) {
  const presetClass = stylesHovered[hoverMode];
  return presetClass !== void 0 ? presetClass : hoverMode;
}
var stylesActivated = {
  background: "vkuiTappable__activatedBackground",
  opacity: "vkuiTappable__activatedOpacity",
  none: ""
};
function activeClass(activeMode = DEFAULT_STATE_MODE) {
  const presetClass = stylesActivated[activeMode];
  return presetClass !== void 0 ? presetClass : activeMode;
}

// node_modules/@vkontakte/vkui/dist/components/Tappable/Tappable.js
var sizeXClassNames = {
  none: "vkuiTappable__sizeXNone",
  compact: "vkuiTappable__sizeXCompact"
};
function hasPointerClassName(hasPointer) {
  switch (hasPointer) {
    case void 0:
      return "vkuiTappable__hasPointerNone";
    case false:
      return "vkuiTappable__hasPointerFalse";
  }
  return void 0;
}
var Tappable = (_param) => {
  var { baseClassName, borderRadiusMode = "auto", children, hoverMode = DEFAULT_STATE_MODE, activeMode = DEFAULT_STATE_MODE, onPointerDown, onPointerCancel } = _param, restProps = _object_without_properties(_param, [
    "baseClassName",
    "borderRadiusMode",
    "children",
    "hoverMode",
    "activeMode",
    "onPointerDown",
    "onPointerCancel"
  ]);
  const isClickable = checkClickable(restProps);
  const { sizeX = "none", hasPointer } = useAdaptivity();
  const needRipple = useMaybeNeedRipple(activeMode, hasPointer);
  const _useRipple = useRipple(needRipple, hasPointer), { clicks } = _useRipple, rippleEvents = _object_without_properties(_useRipple, [
    "clicks"
  ]);
  const handlers = mergeCalls(rippleEvents, {
    onPointerDown,
    onPointerCancel
  });
  const typeProps = restProps.Component === "button" ? {
    type: "button"
  } : {};
  return (0, import_jsx_runtime23.jsxs)(Clickable, _object_spread_props(_object_spread({
    baseClassName: clsx("vkuiInternalTappable", baseClassName, "vkuiTappable__host", sizeX !== SizeType.REGULAR && sizeXClassNames[sizeX], borderRadiusMode === "inherit" && "vkuiTappable__borderRadiusInherit", hasPointerClassName(hasPointer)),
    hoverClassName: hoverClass(hoverMode),
    activeClassName: activeClass(activeMode)
  }, typeProps, handlers, restProps), {
    children: [
      children,
      isClickable && (hoverMode === "background" || activeMode === "background") && (0, import_jsx_runtime23.jsx)(Ripple, {
        needRipple,
        clicks
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/FixedLayout/FixedLayout.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);
var React28 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useResizeObserver.js
var import_react4 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/lib/floating/customResizeObserver.js
var defaultIframeStyles = {
  position: "absolute",
  left: "0",
  top: "0",
  zIndex: "-1",
  width: "100%",
  height: "100%",
  pointerEvents: "none",
  opacity: "0",
  border: "0"
};
var CustomResizeObserver = class {
  observe(element) {
    if (isPositioned(element)) {
      return this.observeUsingIframe(element);
    }
    return this.observeUsingMutationObserver(element);
  }
  appendToTheDOM() {
    for (let record of this.records) {
      record.target.appendChild(record.iframe);
    }
    for (let record of this.records) {
      if (record.iframe.contentWindow) {
        record.iframe.contentWindow.addEventListener("resize", this.updateFunction);
      }
    }
  }
  observeUsingIframe(element) {
    const iframe = element.ownerDocument.createElement("iframe");
    iframe.ariaHidden = "true";
    iframe.tabIndex = -1;
    Object.assign(iframe.style, defaultIframeStyles);
    this.records.push({
      target: element,
      iframe
    });
  }
  observeUsingMutationObserver(element) {
    if (!this.mutationObserverFallback) {
      this.mutationObserverFallback = new MutationObserver(this.updateFunction);
    }
    this.mutationObserverFallback.observe(element, {
      childList: true,
      subtree: true
    });
  }
  disconnect() {
    this.records.map(({ target, iframe }) => {
      if (iframe.contentWindow) {
        iframe.contentWindow.removeEventListener("resize", this.updateFunction);
      }
      target.removeChild(iframe);
    });
    this.records = [];
    if (this.mutationObserverFallback) {
      this.mutationObserverFallback.disconnect();
    }
    this.mutationObserverFallback = null;
  }
  constructor(updateFunction) {
    _define_property(this, "records", []);
    _define_property(this, "mutationObserverFallback", null);
    _define_property(this, "updateFunction", void 0);
    this.updateFunction = updateFunction;
  }
};
function isPositioned(element) {
  return getComputedStyle(element).position !== "static";
}

// node_modules/@vkontakte/vkui/dist/hooks/useStableCallback.js
var React25 = __toESM(require_react(), 1);
function useStableCallback(fn) {
  const ref = React25.useRef(fn);
  useIsomorphicLayoutEffect(() => {
    ref.current = fn;
  });
  return React25.useCallback((...args) => (0, ref.current)(...args), []);
}

// node_modules/@vkontakte/vkui/dist/hooks/useResizeObserver.js
function useResizeObserver(ref, callback) {
  const stableCallback = useStableCallback(callback);
  const { window: window2 } = useDOM();
  (0, import_react4.useEffect)(function addResizeObserverHandler() {
    if (!ref || !window2) {
      return;
    }
    if (ref === window2) {
      const onResize = () => stableCallback(ref);
      ref.addEventListener("resize", onResize);
      return () => ref.removeEventListener("resize", onResize);
    }
    if (!isRefObject(ref) || !ref.current) {
      return;
    }
    const element = ref.current;
    const canUseResizeObserver = "ResizeObserver" in window2 && window2.ResizeObserver !== void 0;
    const observeFn = () => stableCallback(element);
    const observer = canUseResizeObserver ? new ResizeObserver(observeFn) : new CustomResizeObserver(observeFn);
    observer.observe(element);
    if (observer instanceof CustomResizeObserver) {
      observer.appendToTheDOM();
    }
    return () => observer.disconnect();
  }, [
    ref,
    stableCallback,
    window2
  ]);
}

// node_modules/@vkontakte/vkui/dist/components/OnboardingTooltip/OnboardingTooltipContainer.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var React26 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/lib/react/defineComponentDisplayNames.js
function defineComponentDisplayNames(Component2, name) {
  Component2.displayName = name;
  Object.defineProperty(Component2, "name", {
    value: name
  });
}

// node_modules/@vkontakte/vkui/dist/components/OnboardingTooltip/OnboardingTooltipContainer.js
var onboardingTooltipContainerAttr = "data-onboarding-tooltip-container";
var OnboardingTooltipContainer = React26.forwardRef((_param, ref) => {
  var { fixed = false, Component: Component2 = "div" } = _param, props = _object_without_properties(_param, [
    "fixed",
    "Component"
  ]);
  const dataProps = {
    [onboardingTooltipContainerAttr]: fixed ? "fixed" : "true"
  };
  return (0, import_jsx_runtime24.jsx)(Component2, _object_spread_props(_object_spread({}, dataProps, props), {
    ref
  }));
});
if (true) {
  defineComponentDisplayNames(OnboardingTooltipContainer, "OnboardingTooltipContainer");
}

// node_modules/@vkontakte/vkui/dist/components/SplitCol/SplitColContext.js
var React27 = __toESM(require_react(), 1);
var SplitColContext = React27.createContext({
  colRef: null,
  animate: true
});
var useSplitCol = () => React27.useContext(SplitColContext);

// node_modules/@vkontakte/vkui/dist/components/FixedLayout/FixedLayout.js
var stylesVertical = {
  top: "vkuiFixedLayout__verticalTop",
  bottom: clsx("vkuiFixedLayout__verticalBottom", "vkuiInternalFixedLayout--vertical-bottom")
};
var FixedLayout = (_param) => {
  var { children, style, vertical, getRootRef, filled, className, useParentWidth } = _param, restProps = _object_without_properties(_param, [
    "children",
    "style",
    "vertical",
    "getRootRef",
    "filled",
    "className",
    "useParentWidth"
  ]);
  const platform3 = usePlatform();
  const ref = React28.useRef(null);
  const [width, setWidth] = React28.useState(void 0);
  const { window: window2 } = useDOM();
  const { colRef } = React28.useContext(SplitColContext);
  const parentRef = React28.useRef(null);
  const handleRootRef = (0, import_react5.useCallback)((node) => {
    if (!node) {
      return;
    }
    setRef(node, getRootRef);
    setRef(node, ref);
    setRef(node.parentElement, parentRef);
  }, [
    getRootRef
  ]);
  const doResize = () => {
    if (useParentWidth && parentRef.current) {
      const parentWidth = parentRef.current.getBoundingClientRect().width;
      setWidth(parentWidth ? `${parentWidth}px` : void 0);
    } else if (colRef === null || colRef === void 0 ? void 0 : colRef.current) {
      const computedStyle = getComputedStyle(colRef.current);
      setWidth(`${colRef.current.clientWidth - parseFloat(computedStyle.paddingLeft || "0") - parseFloat(computedStyle.paddingRight || "0")}px`);
    } else {
      setWidth(void 0);
    }
  };
  React28.useEffect(doResize, [
    colRef,
    platform3,
    ref,
    useParentWidth
  ]);
  useResizeObserver(window2, doResize);
  useResizeObserver(useParentWidth ? parentRef : colRef, doResize);
  return (0, import_jsx_runtime25.jsx)(OnboardingTooltipContainer, _object_spread_props(_object_spread({}, restProps), {
    fixed: true,
    ref: handleRootRef,
    className: clsx("vkuiFixedLayout__host", platform3 === "ios" && "vkuiInternalFixedLayout--ios", filled && "vkuiFixedLayout__filled", vertical && stylesVertical[vertical], className),
    style: _object_spread({
      width
    }, style),
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBase.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
var React37 = __toESM(require_react(), 1);

// node_modules/@swc/helpers/esm/_class_apply_descriptor_get.js
function _class_apply_descriptor_get(receiver, descriptor) {
  if (descriptor.get) return descriptor.get.call(receiver);
  return descriptor.value;
}

// node_modules/@swc/helpers/esm/_class_extract_field_descriptor.js
function _class_extract_field_descriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) throw new TypeError("attempted to " + action + " private field on non-instance");
  return privateMap.get(receiver);
}

// node_modules/@swc/helpers/esm/_class_private_field_get.js
function _class_private_field_get(receiver, privateMap) {
  var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
  return _class_apply_descriptor_get(receiver, descriptor);
}

// node_modules/@swc/helpers/esm/_check_private_redeclaration.js
function _check_private_redeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

// node_modules/@swc/helpers/esm/_class_private_field_init.js
function _class_private_field_init(obj, privateMap, value) {
  _check_private_redeclaration(obj, privateMap);
  privateMap.set(obj, value);
}

// node_modules/@swc/helpers/esm/_class_apply_descriptor_set.js
function _class_apply_descriptor_set(receiver, descriptor, value) {
  if (descriptor.set) descriptor.set.call(receiver, value);
  else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}

// node_modules/@swc/helpers/esm/_class_private_field_set.js
function _class_private_field_set(receiver, privateMap, value) {
  var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
  _class_apply_descriptor_set(receiver, descriptor, value);
  return value;
}

// node_modules/@vkontakte/vkui/dist/hooks/useExternRef.js
var React29 = __toESM(require_react(), 1);
var _element = /* @__PURE__ */ new WeakMap();
var _externRefs = /* @__PURE__ */ new WeakMap();
var ExternalRef = class {
  updateExternRefs(refs) {
    refs.forEach((ref) => {
      if (!ref || _class_private_field_get(this, _externRefs).has(ref)) {
        return;
      }
      setRef(_class_private_field_get(this, _element), ref);
      _class_private_field_get(this, _externRefs).add(ref);
    });
  }
  get current() {
    return _class_private_field_get(this, _element);
  }
  set current(el) {
    _class_private_field_set(this, _element, el);
    _class_private_field_get(this, _externRefs).forEach((ref) => setRef(el, ref));
  }
  /**
  * React проверяет наличие свойства current у объектов через hasOwnProperty
  *
  * https://github.com/facebook/react/blob/c3cdbec0a78d39b5ff7329384cb41c4573a38212/packages/react-reconciler/src/ReactFiberCommitWork.js#L1612
  */
  hasOwnProperty(v) {
    return v === "current";
  }
  constructor(externRefs = []) {
    _class_private_field_init(this, _element, {
      writable: true,
      value: null
    });
    _class_private_field_init(this, _externRefs, {
      writable: true,
      value: /* @__PURE__ */ new Set()
    });
    externRefs.forEach((ref) => {
      if (ref) {
        _class_private_field_get(this, _externRefs).add(ref);
      }
    });
  }
};
function useExternRef(...externRefs) {
  const ref = React29.useRef(null);
  if (ref.current === null) {
    ref.current = new ExternalRef(externRefs);
  } else {
    ref.current.updateExternRefs(externRefs);
  }
  return ref.current;
}

// node_modules/@vkontakte/vkui/dist/helpers/getMergedSameEventsByProps.js
var isFunctionExistInProps = (props, key) => typeof props[key] === "function";
var getMergedSameEventsByProps = (mainProps, secondProps) => {
  const result = {};
  for (const eventName in mainProps) {
    if (mainProps.hasOwnProperty(eventName) && secondProps.hasOwnProperty(eventName) && isFunctionExistInProps(mainProps, eventName) && isFunctionExistInProps(secondProps, eventName)) {
      result[eventName] = function mergeSameEventsByProps(...args) {
        secondProps[eventName].apply(this, args);
        mainProps[eventName].apply(this, args);
      };
    }
  }
  return result;
};

// node_modules/@vkontakte/vkui/dist/lib/object.js
function filterObject(object, filter2) {
  return Object.entries(object).reduce(
    (acc, [key, value]) => {
      if (filter2(value, key)) {
        Object.assign(acc, {
          [key]: value
        });
      }
      return acc;
    },
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/prefer-reduce-type-parameter
    {}
  );
}

// node_modules/@vkontakte/vkui/dist/hooks/useMergeProps.js
var filterProps = (props) => {
  return filterObject(props, (value) => value !== void 0);
};
var useMergeProps = (originalProps, slotProps) => {
  const originalSlotGetRef = originalProps.getRootRef;
  const rootSlotGetRef = slotProps === null || slotProps === void 0 ? void 0 : slotProps.getRootRef;
  const getRootRef = useExternRef(originalSlotGetRef, rootSlotGetRef);
  if (!slotProps) {
    return filterProps(originalProps);
  }
  const _ref = slotProps || {}, { className: rootSlotClassName, style: rootSlotStyle } = _ref, rootSlotProps = _object_without_properties(_ref, [
    "className",
    "style"
  ]);
  const { className: originalClassName, style: originalSlotStyle } = originalProps, originalRestProps = _object_without_properties(originalProps, [
    "className",
    "style"
  ]);
  const resolvedClassName = originalClassName || rootSlotClassName ? clsx(originalClassName, rootSlotClassName) : void 0;
  const resolvedStyle = originalSlotStyle || rootSlotStyle ? mergeStyle(originalSlotStyle, rootSlotStyle) : void 0;
  const mergedEventsByInjectProps = getMergedSameEventsByProps(originalRestProps, rootSlotProps);
  const resolvedProps = _object_spread({}, originalRestProps, rootSlotProps, mergedEventsByInjectProps);
  if (resolvedClassName) {
    resolvedProps.className = resolvedClassName;
  }
  if (resolvedStyle) {
    resolvedProps.style = resolvedStyle;
  }
  if (rootSlotGetRef || originalSlotGetRef) {
    resolvedProps.getRootRef = getRootRef;
  }
  return filterProps(resolvedProps);
};

// node_modules/@vkontakte/vkui/dist/lib/comparing.js
function isNotUndefined(value) {
  return value !== void 0;
}
function fnArgsOr(fn, args, defaultValue) {
  const definedArgs = args.filter(isNotUndefined);
  if (definedArgs.length) {
    return fn(...definedArgs);
  }
  return defaultValue;
}
function minOr(args, defaultValue) {
  return fnArgsOr(Math.min, args, defaultValue);
}

// node_modules/@vkontakte/vkui/dist/lib/warnOnce.js
function warnOnce(zone) {
  const didWarn = /* @__PURE__ */ new Set();
  return (message, type = "warn") => {
    if (!didWarn.has(message)) {
      didWarn.add(message);
      const formattedMessage = `%c[VKUI/${zone}] ${message}`;
      const styles = type === "log" ? "color: steelblue; font-style: italic" : void 0;
      console[type](formattedMessage, styles);
    }
  };
}
function getA11yRuleUrl(ruleName) {
  const AXE_CORE_MINOR_VERSION = "4.5";
  return `https://dequeuniversity.com/rules/axe/${AXE_CORE_MINOR_VERSION}/${ruleName}`;
}
var COMMON_WARNINGS = {
  a11y: {
    "button-name": `a11y: Кнопка должна содержать текст, доступный для скринридеров. Чтобы исправить эту ошибку, передайте компоненту текст или свойство aria-label.
${getA11yRuleUrl("button-name")}`,
    "link-name": `a11y: Ссылка должна содержать текст, доступный для скринридеров. Чтобы исправить эту ошибку, передайте компоненту текст или свойство aria-label.
${getA11yRuleUrl("link-name")}`,
    "image-alt": `a11y: Изображение должно содержать альтернативный текст, который его описывает. Чтобы исправить эту ошибку, передайте компоненту свойство alt.
${getA11yRuleUrl("image-alt")}`
  }
};

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBaseBadge/ImageBaseBadge.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var React31 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/ImageBase/context.js
var React30 = __toESM(require_react(), 1);
var ImageBaseContext = React30.createContext({
  size: 0,
  onMouseOverHandlers: [],
  onMouseOutHandlers: []
});

// node_modules/@vkontakte/vkui/dist/components/ImageBase/helpers.js
function getFallbackIconSizeByImageBaseSize(imageSize) {
  if (imageSize <= 20) {
    return 12;
  } else if (imageSize > 20 && imageSize <= 28) {
    return 16;
  } else if (imageSize > 28 && imageSize <= 32) {
    return 20;
  } else if (imageSize > 32 && imageSize <= 44) {
    return 24;
  } else if (imageSize > 44 && imageSize <= 64) {
    return 28;
  }
  return getFallbackIconSizeByImageBaseSize.MAX_SIZE;
}
getFallbackIconSizeByImageBaseSize.MAX_SIZE = 36;
function getBadgeIconSizeByImageBaseSize(imageSize) {
  if (imageSize <= 36) {
    return 12;
  } else if (imageSize > 36 && imageSize <= 48) {
    return 16;
  } else if (imageSize > 48 && imageSize <= 64) {
    return 20;
  }
  return getBadgeIconSizeByImageBaseSize.MAX_SIZE;
}
getBadgeIconSizeByImageBaseSize.MAX_SIZE = 24;
function getOverlayIconSizeByImageBaseSize(imageSize) {
  if (imageSize <= 20) {
    return 12;
  } else if (imageSize > 20 && imageSize <= 24) {
    return 16;
  } else if (imageSize > 24 && imageSize <= 28) {
    return 18;
  } else if (imageSize > 28 && imageSize <= 40) {
    return 20;
  } else if (imageSize > 40 && imageSize <= 48) {
    return 24;
  } else if (imageSize > 48 && imageSize <= 88) {
    return 28;
  }
  return getOverlayIconSizeByImageBaseSize.MAX_SIZE;
}
getOverlayIconSizeByImageBaseSize.MAX_SIZE = 32;

// node_modules/@vkontakte/vkui/dist/components/ImageBase/types.js
var imageBaseSizes = [
  16,
  20,
  24,
  28,
  32,
  36,
  40,
  44,
  48,
  56,
  64,
  72,
  80,
  88,
  96
];

// node_modules/@vkontakte/vkui/dist/components/ImageBase/validators.js
function parseIconSizeByDisplayName(displayName) {
  if (typeof displayName !== "string") {
    return null;
  }
  const match = /Icon(\d+)/.exec(displayName);
  return match ? Number(match[1]) : null;
}
function parseIconSizeByWidthProp(width) {
  if (typeof width !== "string" && typeof width !== "number") {
    return null;
  }
  const size5 = Number(width);
  return size5 > 0 ? size5 : null;
}
function getElementDisplayName(element) {
  var _element_type_displayName, _ref;
  return (_ref = (_element_type_displayName = element.type.displayName) !== null && _element_type_displayName !== void 0 ? _element_type_displayName : element.type.name) !== null && _ref !== void 0 ? _ref : null;
}
function getElementWidthProp(element) {
  var _element_props_width;
  return (_element_props_width = element.props.width) !== null && _element_props_width !== void 0 ? _element_props_width : null;
}
function getIconSizeByElement(element) {
  const sizeByDisplayName = parseIconSizeByDisplayName(getElementDisplayName(element));
  const sizeByWidth = parseIconSizeByWidthProp(getElementWidthProp(element));
  return sizeByWidth ? sizeByWidth : sizeByDisplayName;
}
function validateIconComponentSizeByImageSize(imageSize, iconProp, selectorFn, logger) {
  const iconSize2 = getIconSizeByElement(iconProp.value);
  if (iconSize2 === null) {
    return;
  }
  const result = selectorFn(imageSize);
  if (result === iconSize2 || result === selectorFn.MAX_SIZE && iconSize2 >= result) {
    return;
  }
  const iconName = getElementDisplayName(iconProp.value);
  const propMessage = iconName ? `${iconProp.name}={<${iconName} />}` : iconProp.name;
  logger(`Размер \`${propMessage}\` не соответствует дизайн-системе. Для \`size={${imageSize}}\` размер иконки для \`${iconProp.name}\` должен соответствовать <Icon${result}<name> />. Если такого размера нет, то используйте <${iconName} width={${result}} height={${result}} />`, "log");
}
var warnImageBase = warnOnce("ImageBase");
function validateFallbackIcon(imageSize, iconProp) {
  return validateIconComponentSizeByImageSize(imageSize, iconProp, getFallbackIconSizeByImageBaseSize, warnImageBase);
}
var mapOfExpectedSize = new Set(imageBaseSizes);
var arrayOfSizes = Array.from(mapOfExpectedSize).map((str) => Number(str));
var maxSize = arrayOfSizes.reduce((maxSize2, size5) => size5 > maxSize2 ? size5 : maxSize2, 0);
function validateSize(imageSize) {
  if (imageSize > maxSize || mapOfExpectedSize.has(imageSize)) {
    return;
  }
  warnImageBase(`\`size={${imageSize}}\` не соответствует дизайн-системе. Пожалуйста, используйте один из следующих вариантов: ${arrayOfSizes.join(" | ")}`, "log");
}
var warnImageBaseBadge = warnOnce("ImageBase.Badge");
function validateBadgeIcon(imageSize, iconProp) {
  if (imageSize < 24 && iconProp) {
    return warnImageBaseBadge("Не используйте бейдж при `size < 24`.", "log");
  }
  validateIconComponentSizeByImageSize(imageSize, iconProp, getBadgeIconSizeByImageBaseSize, warnImageBaseBadge);
}
var warnImageBaseOverlay = warnOnce("ImageBase.Overlay");
function validateOverlayIcon(imageSize, iconProp) {
  validateIconComponentSizeByImageSize(imageSize, iconProp, getOverlayIconSizeByImageBaseSize, warnImageBaseOverlay);
}

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBaseBadge/ImageBaseBadge.js
function DevelopmentCheck({ children }) {
  const { size: size5 } = React31.useContext(ImageBaseContext);
  if (children) {
    validateBadgeIcon(size5, {
      name: "children",
      value: children
    });
  }
  return null;
}
var backgroundStyles = {
  stroke: "vkuiImageBaseBadge__backgroundStroke",
  shadow: "vkuiImageBaseBadge__backgroundShadow"
};
var ImageBaseBadge = (_param) => {
  var { background = "shadow" } = _param, restProps = _object_without_properties(_param, [
    "background"
  ]);
  return (0, import_jsx_runtime26.jsxs)(import_jsx_runtime26.Fragment, {
    children: [
      (0, import_jsx_runtime26.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
        baseClassName: clsx("vkuiImageBaseBadge__host", backgroundStyles[background])
      })),
      (0, import_jsx_runtime26.jsx)(DevelopmentCheck, {
        children: restProps.children
      })
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBaseFloatElement/ImageBaseFloatElement.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var React32 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBaseFloatElement/helpers.js
function isIndentSizeConstant(indent) {
  return indent === "2xs" || indent === "xs" || indent === "s" || indent === "m" || indent === "l" || indent === "xl" || indent === "2xl" || indent === "3xl" || indent === "4xl";
}
function calculateIndent(indent) {
  if (isIndentSizeConstant(indent)) {
    return;
  }
  return typeof indent === "string" ? indent : `${indent}px`;
}
var resolveIndent = (indent, cssProperty, classNames) => {
  if (!indent) {
    return [
      void 0,
      void 0
    ];
  }
  const calculatedIndent = calculateIndent(indent);
  if (calculatedIndent) {
    return [
      {
        [cssProperty]: calculatedIndent
      },
      void 0
    ];
  }
  return [
    void 0,
    classNames[indent]
  ];
};
var mutableRemoveElement = (arr, element) => {
  arr.splice(arr.indexOf(element), 1);
};

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBaseFloatElement/ImageBaseFloatElement.js
var positionPlacementClassNames = {
  "top-start": "vkuiImageBaseFloatElement__placementTopStart",
  "top": "vkuiImageBaseFloatElement__placementTop",
  "top-end": "vkuiImageBaseFloatElement__placementTopEnd",
  "bottom-start": "vkuiImageBaseFloatElement__placementBottomStart",
  "bottom": "vkuiImageBaseFloatElement__placementBottom",
  "bottom-end": "vkuiImageBaseFloatElement__placementBottomEnd",
  "middle-start": "vkuiImageBaseFloatElement__placementMiddleStart",
  "middle": "vkuiImageBaseFloatElement__placementMiddle",
  "middle-end": "vkuiImageBaseFloatElement__placementMiddleEnd"
};
var inlineIndentClassNames = {
  "2xs": "vkuiImageBaseFloatElement__inlineIndent2xs",
  "xs": "vkuiImageBaseFloatElement__inlineIndentXs",
  "s": "vkuiImageBaseFloatElement__inlineIndentS",
  "m": "vkuiImageBaseFloatElement__inlineIndentM",
  "l": "vkuiImageBaseFloatElement__inlineIndentL",
  "xl": "vkuiImageBaseFloatElement__inlineIndentXl",
  "2xl": "vkuiImageBaseFloatElement__inlineIndent2xl",
  "3xl": "vkuiImageBaseFloatElement__inlineIndent3xl",
  "4xl": "vkuiImageBaseFloatElement__inlineIndent4xl"
};
var blockIndentClassNames = {
  "2xs": "vkuiImageBaseFloatElement__blockIndent2xs",
  "xs": "vkuiImageBaseFloatElement__blockIndentXs",
  "s": "vkuiImageBaseFloatElement__blockIndentS",
  "m": "vkuiImageBaseFloatElement__blockIndentM",
  "l": "vkuiImageBaseFloatElement__blockIndentL",
  "xl": "vkuiImageBaseFloatElement__blockIndentXl",
  "2xl": "vkuiImageBaseFloatElement__blockIndent2xl",
  "3xl": "vkuiImageBaseFloatElement__blockIndent3xl",
  "4xl": "vkuiImageBaseFloatElement__blockIndent4xl"
};
var ImageBaseFloatElement = (_param) => {
  var { placement, visibility = "always", style, className, inlineIndent, blockIndent } = _param, restProps = _object_without_properties(_param, [
    "placement",
    "visibility",
    "style",
    "className",
    "inlineIndent",
    "blockIndent"
  ]);
  const [hidden, setHidden] = React32.useState(visibility !== "always");
  const { onMouseOverHandlers, onMouseOutHandlers } = React32.useContext(ImageBaseContext);
  useIsomorphicLayoutEffect(function resetHidden() {
    setHidden(visibility === "on-hover");
  }, [
    visibility
  ]);
  useIsomorphicLayoutEffect(function addMouseHandlers() {
    if (visibility === "on-hover") {
      const onMouseOver = () => setHidden(false);
      const onMouseOut = () => setHidden(true);
      onMouseOverHandlers.push(onMouseOver);
      onMouseOutHandlers.push(onMouseOut);
      return () => {
        mutableRemoveElement(onMouseOverHandlers, onMouseOver);
        mutableRemoveElement(onMouseOutHandlers, onMouseOut);
      };
    }
    return;
  }, [
    visibility
  ]);
  const [inlineIndentStyle, blockIndentStyle, inlineIndentClassName, blockIndentClassName] = React32.useMemo(() => {
    const [inlineIndentStyle2, inlineIndentClassName2] = resolveIndent(inlineIndent, "--vkui_internal--FloatElement_horizontal_indent", inlineIndentClassNames);
    const [blockIndentStyle2, blockIndentClassName2] = resolveIndent(blockIndent, "--vkui_internal--FloatElement_vertical_indent", blockIndentClassNames);
    return [
      inlineIndentStyle2,
      blockIndentStyle2,
      inlineIndentClassName2,
      blockIndentClassName2
    ];
  }, [
    inlineIndent,
    blockIndent
  ]);
  return (0, import_jsx_runtime27.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    style: _object_spread({}, style, inlineIndentStyle, blockIndentStyle),
    className: clsx("vkuiImageBaseFloatElement__host", hidden && "vkuiImageBaseFloatElement__hidden", positionPlacementClassNames[placement], inlineIndentClassName, blockIndentClassName, className)
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBaseOverlay/ImageBaseOverlay.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var React36 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBaseOverlay/hooks.js
var React35 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useFocusWithin.js
var React33 = __toESM(require_react(), 1);
var isFocusWithin = (ref, document2) => ref.contains(document2.activeElement);
function useFocusWithin(ref) {
  const { document: document2 } = useDOM();
  const [focusWithin, setFocusWithin] = React33.useState(() => ref.current && document2 ? isFocusWithin(ref.current, document2) : false);
  useIsomorphicLayoutEffect(function handleAutoFocus() {
    if (!document2) {
      return;
    }
    const handleFocusOrBlurEvents = () => {
      if (ref.current) {
        setFocusWithin(isFocusWithin(ref.current, document2));
      }
    };
    void handleFocusOrBlurEvents();
    document2.addEventListener("focus", handleFocusOrBlurEvents, {
      capture: true
    });
    document2.addEventListener("blur", handleFocusOrBlurEvents, {
      capture: true
    });
    return () => {
      document2.removeEventListener("focus", handleFocusOrBlurEvents, {
        capture: true
      });
      document2.removeEventListener("blur", handleFocusOrBlurEvents, {
        capture: true
      });
    };
  }, []);
  return focusWithin;
}

// node_modules/@vkontakte/vkui/dist/hooks/useIsClient.js
var React34 = __toESM(require_react(), 1);
function useIsClient(initial = false) {
  const [isClient2, setIsClient] = React34.useState(initial);
  useIsomorphicLayoutEffect(() => {
    setIsClient(true);
  }, []);
  return isClient2;
}

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBaseOverlay/hooks.js
function useNonInteractiveOverlayProps(rootRef) {
  const focusWithin = useFocusWithin(rootRef);
  const [nonInteractiveFocusShown, setNonInteractiveFocusShown] = React35.useState(false);
  function onClick(event) {
    if (event.detail > 0) {
      setNonInteractiveFocusShown(false);
    }
  }
  useIsomorphicLayoutEffect(() => {
    setNonInteractiveFocusShown(focusWithin);
  }, [
    focusWithin
  ]);
  return {
    shown: nonInteractiveFocusShown && focusWithin,
    onClick
  };
}
function useCalculatedDefaultVisibility() {
  const { hasPointer: hasPointerContext } = useAdaptivity();
  const needTwoPassRendering = hasPointerContext === void 0;
  const isClient2 = useIsClient(!needTwoPassRendering);
  if (!isClient2 && hasPointerContext === void 0) {
    return "on-hover";
  }
  const hasPointer = hasPointerContext !== null && hasPointerContext !== void 0 ? hasPointerContext : hasMouse;
  return hasPointer ? "on-hover" : "always";
}

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBaseOverlay/ImageBaseOverlay.js
function DevelopmentCheck2({ children }) {
  const { size: size5 } = React36.useContext(ImageBaseContext);
  if (true) {
    if (children) {
      validateOverlayIcon(size5, {
        name: "children",
        value: children
      });
    }
  }
  return null;
}
var ImageBaseOverlayInteractive = (_param) => {
  var { children, className, getRootRef, overlayShown } = _param, restProps = _object_without_properties(_param, [
    "children",
    "className",
    "getRootRef",
    "overlayShown"
  ]);
  const _useFocusVisible = useFocusVisible(), { focusVisible } = _useFocusVisible, focusEvents = _object_without_properties(_useFocusVisible, [
    "focusVisible"
  ]);
  const focusVisibleClassNames = useFocusVisibleClassName({
    focusVisible,
    mode: "inside"
  });
  return (0, import_jsx_runtime28.jsxs)(import_jsx_runtime28.Fragment, {
    children: [
      (0, import_jsx_runtime28.jsx)("div", _object_spread_props(_object_spread(_object_spread_props(_object_spread({}, restProps), {
        tabIndex: 0,
        role: "button",
        className: clsx("vkuiImageBaseOverlay__clickable", (focusVisible || overlayShown) && "vkuiImageBaseOverlay__visible", focusVisibleClassNames, className),
        ref: getRootRef,
        onKeyDown: clickByKeyboardHandler
      }), focusEvents), {
        children
      })),
      (0, import_jsx_runtime28.jsx)(DevelopmentCheck2, {
        children
      })
    ]
  });
};
var ImageBaseOverlayNonInteractive = (_param) => {
  var { className, getRootRef, overlayShown: overlayShownProps } = _param, restProps = _object_without_properties(_param, [
    "className",
    "getRootRef",
    "overlayShown"
  ]);
  const rootRef = useExternRef(getRootRef);
  const { shown: overlayShown, onClick: onOverlayClick } = useNonInteractiveOverlayProps(rootRef);
  return (0, import_jsx_runtime28.jsx)("div", _object_spread_props(_object_spread({}, restProps), {
    ref: rootRef,
    className: clsx((overlayShown || overlayShownProps) && "vkuiImageBaseOverlay__visible", className),
    onClick: onOverlayClick
  }));
};
var ImageBaseOverlay = (_param) => {
  var { className, theme: themeProp, visibility: visibilityProp } = _param, restProps = _object_without_properties(_param, [
    "className",
    "theme",
    "visibility"
  ]);
  const colorScheme = useColorScheme();
  const theme = themeProp !== null && themeProp !== void 0 ? themeProp : colorScheme;
  const commonClassNames = clsx("vkuiImageBaseOverlay__host", theme === "light" && "vkuiImageBaseOverlay__themeLight", theme === "dark" && "vkuiImageBaseOverlay__themeDark", className);
  const defaultVisibility = useCalculatedDefaultVisibility();
  const visibility = visibilityProp !== null && visibilityProp !== void 0 ? visibilityProp : defaultVisibility;
  const commonProps = {
    className: commonClassNames,
    overlayShown: visibility === "always"
  };
  if (!restProps.onClick) {
    return (0, import_jsx_runtime28.jsx)(ImageBaseOverlayNonInteractive, _object_spread({}, restProps, commonProps));
  }
  return (0, import_jsx_runtime28.jsx)(ImageBaseOverlayInteractive, _object_spread({}, restProps, commonProps));
};

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBase.js
var warn = warnOnce("ImageBase");
var defaultSize = 24;
var getObjectFitClassName = (objectFit) => {
  switch (objectFit) {
    case "contain":
      return "vkuiImageBase__imgObjectFitContain";
    case "cover":
      return "vkuiImageBase__imgObjectFitCover";
    case "none":
      return "vkuiImageBase__imgObjectFitNone";
    case "scale-down":
      return "vkuiImageBase__imgObjectFitScaleDown";
  }
  return void 0;
};
var parsePx = (value) => {
  if (value.endsWith("px")) {
    return parseInt(value);
  }
  return void 0;
};
var sizeToNumber = (size5) => {
  if (typeof size5 === "string") {
    return parsePx(size5);
  }
  return size5;
};
var ImageBase = (_param) => {
  var { alt, crossOrigin, decoding, loading, referrerPolicy, sizes, src, srcSet, useMap, fetchPriority: fetchPriorityProp, getRef, size: sizeProp, width: widthImg, height: heightImg, widthSize, heightSize, noBorder = false, fallbackIcon: fallbackIconProp, children, onLoad, onError, withTransparentBackground, objectFit = "cover", objectPosition, filter: filter2, keepAspectRatio = false, getRootRef, elementTiming, slotProps } = _param, restProps = _object_without_properties(_param, [
    "alt",
    "crossOrigin",
    "decoding",
    "loading",
    "referrerPolicy",
    "sizes",
    "src",
    "srcSet",
    "useMap",
    "fetchPriority",
    "getRef",
    "size",
    "width",
    "height",
    "widthSize",
    "heightSize",
    "noBorder",
    "fallbackIcon",
    "children",
    "onLoad",
    "onError",
    "withTransparentBackground",
    "objectFit",
    "objectPosition",
    "filter",
    "keepAspectRatio",
    "getRootRef",
    "elementTiming",
    "slotProps"
  ]);
  if (true) {
    if (getRef) {
      warn("Свойство `getRef` устаревшее и будет удалено в VKUI v9. Используйте `slotProps={ img: { getRootRef: ... } }`");
    }
  }
  const size5 = sizeProp !== null && sizeProp !== void 0 ? sizeProp : minOr([
    sizeToNumber(widthSize),
    sizeToNumber(heightSize)
  ], defaultSize);
  const wrapperRef = useExternRef(getRootRef);
  const width = widthSize !== null && widthSize !== void 0 ? widthSize : keepAspectRatio ? void 0 : size5;
  const height = heightSize !== null && heightSize !== void 0 ? heightSize : keepAspectRatio ? void 0 : size5;
  const [loaded, setLoaded] = React37.useState(false);
  const [failed, setFailed] = React37.useState(false);
  const mouseOverHandlersRef = (0, import_react6.useRef)([]);
  const mouseOutHandlersRef = (0, import_react6.useRef)([]);
  const hasSrc = src || srcSet;
  const fallbackIcon = failed || !hasSrc ? fallbackIconProp : null;
  if (true) {
    validateSize(size5);
    if (React37.isValidElement(fallbackIcon)) {
      validateFallbackIcon(size5, {
        name: "fallbackIcon",
        value: fallbackIcon
      });
    }
  }
  const handleImageLoad = (event) => {
    if (loaded) {
      return;
    }
    setLoaded(true);
    setFailed(false);
    onLoad === null || onLoad === void 0 ? void 0 : onLoad(event);
  };
  const handleImageError = (event) => {
    setLoaded(false);
    setFailed(true);
    onError === null || onError === void 0 ? void 0 : onError(event);
  };
  const _useMergeProps = useMergeProps(hasSrc ? {
    // safari и firefox нужно чтобы атрибут `loading` был до `src`
    //
    // https://mihaly4.ru/image-loading-lazy-bug
    loading,
    getRootRef: getRef,
    alt,
    className: clsx("vkuiImageBase__img", getObjectFitClassName(objectFit), objectPosition && "vkuiImageBase__withObjectPosition", filter2 && "vkuiImageBase__withFilter", keepAspectRatio && "vkuiImageBase__imgKeepRatio", failed && "vkuiImageBase__imgHiddenAlt"),
    crossOrigin,
    decoding,
    referrerPolicy,
    style: mergeStyle(keepAspectRatio ? {
      width: widthImg || width,
      height: heightImg || height
    } : void 0, objectPosition || filter2 ? {
      "--vkui_internal--ImageBase_object_position": objectPosition,
      "--vkui_internal--ImageBase_object_filter": filter2
    } : void 0),
    sizes,
    src,
    srcSet,
    useMap,
    width,
    height,
    onLoad: handleImageLoad,
    onError: handleImageError,
    fetchPriority: fetchPriorityProp,
    // @ts-expect-error: TS2322 отсутствует в @types/react
    elementtiming: elementTiming
  } : {}, hasSrc ? slotProps === null || slotProps === void 0 ? void 0 : slotProps.img : void 0), { getRootRef: getImgRef, fetchPriority } = _useMergeProps, imgRest = _object_without_properties(_useMergeProps, [
    "getRootRef",
    "fetchPriority"
  ]);
  const imgRef = useExternRef(getImgRef);
  const isOnLoadStatusCheckedRef = React37.useRef(false);
  React37.useEffect(function dispatchLoadEventForAlreadyLoadedResourceIfReactInitializedLater() {
    if (isOnLoadStatusCheckedRef.current) {
      return;
    }
    isOnLoadStatusCheckedRef.current = true;
    if (imgRef.current && imgRef.current.complete && !loaded) {
      const event = new Event("load");
      imgRef.current.dispatchEvent(event);
    }
  }, [
    imgRef,
    loaded
  ]);
  const onMouseOver = () => {
    mouseOverHandlersRef.current.forEach((fn) => fn());
  };
  const onMouseOut = () => {
    mouseOutHandlersRef.current.forEach((fn) => fn());
  };
  const contextValue = React37.useMemo(() => ({
    size: size5,
    onMouseOverHandlers: mouseOverHandlersRef.current,
    onMouseOutHandlers: mouseOutHandlersRef.current
  }), [
    size5
  ]);
  return (0, import_jsx_runtime29.jsx)(ImageBaseContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime29.jsxs)(Clickable, _object_spread_props(_object_spread({
      baseStyle: {
        width,
        height
      },
      baseClassName: clsx("vkuiImageBase__host", hasSrc && loaded && "vkuiImageBase__loaded", withTransparentBackground && "vkuiImageBase__transparentBackground"),
      getRootRef: wrapperRef,
      onMouseOver,
      onMouseOut
    }, restProps), {
      children: [
        hasSrc && (0, import_jsx_runtime29.jsx)("img", _object_spread({
          ref: imgRef
        }, imgRest, getFetchPriorityProp(fetchPriority))),
        fallbackIcon && (0, import_jsx_runtime29.jsx)("div", {
          className: "vkuiImageBase__fallback",
          children: fallbackIcon
        }),
        children && (0, import_jsx_runtime29.jsx)("div", {
          className: "vkuiImageBase__children",
          children
        }),
        !noBorder && (0, import_jsx_runtime29.jsx)("div", {
          "aria-hidden": true,
          className: "vkuiImageBase__border"
        })
      ]
    }))
  });
};
ImageBase.Badge = ImageBaseBadge;
ImageBase.Overlay = ImageBaseOverlay;
ImageBase.FloatElement = ImageBaseFloatElement;
if (true) {
  defineComponentDisplayNames(ImageBase.Badge, "ImageBase.Badge");
  defineComponentDisplayNames(ImageBase.Overlay, "ImageBase.Overlay");
  defineComponentDisplayNames(ImageBase.FloatElement, "ImageBase.FloatElement");
}

// node_modules/@vkontakte/vkui/dist/components/Button/Button.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var React42 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/Spinner/Spinner.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var React41 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/styles/animationVisibilityDelay.js
function animationVisibilityDelayStyles(delay) {
  if (delay === void 0) {
    return void 0;
  }
  return {
    "--vkui_internal--animation_delay_visibility": `${delay}ms`
  };
}

// node_modules/@vkontakte/vkui/dist/components/VisuallyHidden/VisuallyHidden.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var VisuallyHidden = (_param) => {
  var { Component: Component2 = "span", baseClassName } = _param, restProps = _object_without_properties(_param, [
    "Component",
    "baseClassName"
  ]);
  return (0, import_jsx_runtime30.jsx)(RootComponent, _object_spread_props(_object_spread({
    Component: Component2
  }, restProps), {
    baseClassName: clsx(baseClassName, "vkuiVisuallyHidden__host", Component2 === "input" && "vkuiVisuallyHidden__focusableInput")
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Spinner/SpinnerAnimation.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);

// node_modules/@vkontakte/vkui/dist/lib/animation/useCSSKeyframesAnimationController.js
var React38 = __toESM(require_react(), 1);
var useCSSKeyframesAnimationController = (stateProp, { onEnter: onEnterProp, onEntering, onEntered, onExit: onExitProp, onExiting, onExited } = {}, disableInitAnimation = false) => {
  const [state, setState] = React38.useState(() => disableInitAnimation ? stateProp === "enter" ? "entered" : "exited" : stateProp);
  const prevStateRef = React38.useRef(void 0);
  React38.useEffect(() => {
    prevStateRef.current = stateProp;
  });
  const onAnimationStart = () => {
    if (state === "enter") {
      setState("entering");
      if (onEntering) {
        onEntering();
      }
    } else if (state === "exit") {
      setState("exiting");
      if (onExiting) {
        onExiting();
      }
    }
  };
  const onAnimationEnd = () => {
    if (state === "entering") {
      setState("entered");
      if (onEntered) {
        onEntered();
      }
    } else if (state === "exiting") {
      setState("exited");
      if (onExited) {
        onExited();
      }
    }
  };
  const onEnter = useStableCallback(onEnterProp || noop);
  const onExit = useStableCallback(onExitProp || noop);
  useIsomorphicLayoutEffect(function updateState() {
    const prevState = prevStateRef.current;
    if (prevState === stateProp) {
      return;
    }
    switch (stateProp) {
      case "enter":
        if (state === "entering" || state === "entered") {
          break;
        }
        setState("enter");
        onEnter();
        break;
      case "exit":
        if (state === "exiting" || state === "exited") {
          break;
        }
        setState("exit");
        onExit();
        break;
    }
  }, [
    state,
    stateProp,
    onEnter,
    onExit
  ]);
  return [
    state,
    {
      onAnimationStart,
      onAnimationEnd
    }
  ];
};

// node_modules/@vkontakte/vkui/dist/lib/animation/useReducedMotion.js
var React39 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/lib/matchMedia.js
function matchMediaListAddListener(mediaQueryList, listener) {
  mediaQueryList.addEventListener ? mediaQueryList.addEventListener("change", listener) : mediaQueryList.addListener(listener);
}
function matchMediaListRemoveListener(mediaQueryList, listener) {
  mediaQueryList.removeEventListener ? mediaQueryList.removeEventListener("change", listener) : mediaQueryList.removeListener(listener);
}

// node_modules/@vkontakte/vkui/dist/lib/animation/useReducedMotion.js
var REDUCE_MOTION_MEDIA_QUERY = "screen and (prefers-reduced-motion: reduce)";
var useReducedMotion = () => {
  const { window: window2 } = useDOM();
  const [reducedMotion, setReducedMotion] = React39.useState(void 0);
  useIsomorphicLayoutEffect(() => {
    if (!window2) {
      return;
    }
    const match = window2.matchMedia(REDUCE_MOTION_MEDIA_QUERY);
    setReducedMotion(match.matches);
    const handleMediaQueryChange = (event) => {
      setReducedMotion(event.matches);
    };
    matchMediaListAddListener(match, handleMediaQueryChange);
    return () => matchMediaListRemoveListener(match, handleMediaQueryChange);
  }, [
    window2
  ]);
  return reducedMotion;
};

// node_modules/@vkontakte/vkui/dist/lib/animation/rubberbandIfOutOfBounds.js
function rubberband(distance, dimension, constant) {
  if (dimension === 0 || Math.abs(dimension) === Infinity) {
    return Math.pow(distance, constant * 5);
  }
  return distance * dimension * constant / (dimension + constant * distance);
}
function rubberbandIfOutOfBounds(position, min2, max2, constant = 0.15) {
  if (constant === 0) {
    return clamp2(position, min2, max2);
  }
  if (position < min2) {
    return -rubberband(min2 - position, max2 - min2, constant) + min2;
  }
  if (position > max2) {
    return +rubberband(position - max2, max2 - min2, constant) + max2;
  }
  return position;
}

// node_modules/@vkontakte/vkui/dist/lib/animation/fades.js
var animationFadeClassNames = {
  in: "vkuistyles__-anim-fade-in",
  out: "vkuistyles__-anim-fade-out"
};

// node_modules/@vkontakte/vkui/dist/lib/animation/transformOrigin.js
var transformOriginClassNames = {
  "top": "vkuistyles__-anim-transform-origin-top",
  "top-start": "vkuistyles__-anim-transform-origin-top-start",
  "top-end": "vkuistyles__-anim-transform-origin-top-end",
  "right": "vkuistyles__-anim-transform-origin-right",
  "right-start": "vkuistyles__-anim-transform-origin-right-start",
  "right-end": "vkuistyles__-anim-transform-origin-right-end",
  "bottom": "vkuistyles__-anim-transform-origin-bottom",
  "bottom-start": "vkuistyles__-anim-transform-origin-bottom-start",
  "bottom-end": "vkuistyles__-anim-transform-origin-bottom-end",
  "left": "vkuistyles__-anim-transform-origin-left",
  "left-start": "vkuistyles__-anim-transform-origin-left-start",
  "left-end": "vkuistyles__-anim-transform-origin-left-end"
};

// node_modules/@vkontakte/vkui/dist/lib/animation/useCSSTransition.js
var import_react7 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui-date-fns-tz/tzName/index.js
function tzName(timeZone, date, format = "long") {
  return new Intl.DateTimeFormat("en-US", {
    // Enforces engine to render the time. Without the option JavaScriptCore omits it.
    hour: "numeric",
    timeZone,
    timeZoneName: format
  }).format(date).split(/\s/g).slice(2).join(" ");
}

// node_modules/@vkontakte/vkui-date-fns-tz/tzOffset/index.js
var offsetFormatCache = {};
var offsetCache = {};
function tzOffset(timeZone, date) {
  try {
    var _offsetFormatCache, _timeZone;
    const format = (_offsetFormatCache = offsetFormatCache)[_timeZone = timeZone] || (_offsetFormatCache[_timeZone] = new Intl.DateTimeFormat("en-US", {
      timeZone,
      timeZoneName: "longOffset"
    }).format);
    const offsetStr = format(date).split("GMT")[1];
    if (offsetStr in offsetCache) return offsetCache[offsetStr];
    return calcOffset(offsetStr, offsetStr.split(":"));
  } catch (e) {
    if (timeZone in offsetCache) return offsetCache[timeZone];
    const captures = timeZone === null || timeZone === void 0 ? void 0 : timeZone.match(offsetRe);
    if (captures) return calcOffset(timeZone, captures.slice(1));
    return NaN;
  }
}
var offsetRe = /([+-]\d\d):?(\d\d)?/;
function calcOffset(cacheStr, values) {
  const hours2 = +(values[0] || 0);
  const minutes2 = +(values[1] || 0);
  const seconds = +(values[2] || 0) / 60;
  return offsetCache[cacheStr] = hours2 * 60 + minutes2 > 0 ? hours2 * 60 + minutes2 + seconds : hours2 * 60 - minutes2 - seconds;
}

// node_modules/@vkontakte/vkui-date-fns-tz/date/mini.js
var TZDateMini = class _TZDateMini extends Date {
  static tz(tz, ...args) {
    return args.length ? new _TZDateMini(...args, tz) : new _TZDateMini(Date.now(), tz);
  }
  //#endregion
  //#region time zone
  withTimeZone(timeZone) {
    return new _TZDateMini(+this, timeZone);
  }
  getTimezoneOffset() {
    const offset5 = -tzOffset(this.timeZone, this);
    return offset5 > 0 ? Math.floor(offset5) : Math.ceil(offset5);
  }
  //#endregion
  //#region time
  setTime(time) {
    Date.prototype.setTime.apply(this, arguments);
    syncToInternal(this);
    return +this;
  }
  //#endregion
  //#region date-fns integration
  [/* @__PURE__ */ Symbol.for("constructDateFrom")](date) {
    return new _TZDateMini(+new Date(date), this.timeZone);
  }
  //#region static
  constructor(...args) {
    super();
    if (args.length > 1 && typeof args[args.length - 1] === "string") {
      this.timeZone = args.pop();
    }
    this.internal = /* @__PURE__ */ new Date();
    if (isNaN(tzOffset(this.timeZone, this))) {
      this.setTime(NaN);
    } else {
      if (!args.length) {
        this.setTime(Date.now());
      } else if (typeof args[0] === "number" && (args.length === 1 || args.length === 2 && typeof args[1] !== "number")) {
        this.setTime(args[0]);
      } else if (typeof args[0] === "string") {
        this.setTime(+new Date(args[0]));
      } else if (args[0] instanceof Date) {
        this.setTime(+args[0]);
      } else {
        this.setTime(+new Date(...args));
        adjustToSystemTZ(this, NaN);
        syncToInternal(this);
      }
    }
  }
};
var re = /^(get|set)(?!UTC)/;
Object.getOwnPropertyNames(Date.prototype).forEach((method) => {
  if (!re.test(method)) return;
  const utcMethod = method.replace(re, "$1UTC");
  if (!TZDateMini.prototype[utcMethod]) return;
  if (method.startsWith("get")) {
    TZDateMini.prototype[method] = function() {
      return this.internal[utcMethod]();
    };
  } else {
    TZDateMini.prototype[method] = function() {
      Date.prototype[utcMethod].apply(this.internal, arguments);
      syncFromInternal(this);
      return +this;
    };
    TZDateMini.prototype[utcMethod] = function() {
      Date.prototype[utcMethod].apply(this, arguments);
      syncToInternal(this);
      return +this;
    };
  }
});
function syncToInternal(date) {
  date.internal.setTime(+date);
  date.internal.setUTCSeconds(date.internal.getUTCSeconds() - Math.round(-tzOffset(date.timeZone, date) * 60));
}
function syncFromInternal(date) {
  Date.prototype.setFullYear.call(date, date.internal.getUTCFullYear(), date.internal.getUTCMonth(), date.internal.getUTCDate());
  Date.prototype.setHours.call(date, date.internal.getUTCHours(), date.internal.getUTCMinutes(), date.internal.getUTCSeconds(), date.internal.getUTCMilliseconds());
  adjustToSystemTZ(date);
}
function adjustToSystemTZ(date) {
  const baseOffset = tzOffset(date.timeZone, date);
  const offset5 = baseOffset > 0 ? Math.floor(baseOffset) : Math.ceil(baseOffset);
  const prevHour = /* @__PURE__ */ new Date(+date);
  prevHour.setUTCHours(prevHour.getUTCHours() - 1);
  const systemOffset = -(/* @__PURE__ */ new Date(+date)).getTimezoneOffset();
  const prevHourSystemOffset = -(/* @__PURE__ */ new Date(+prevHour)).getTimezoneOffset();
  const systemDSTChange = systemOffset - prevHourSystemOffset;
  const dstShift = Date.prototype.getHours.apply(date) !== date.internal.getUTCHours();
  if (systemDSTChange && dstShift) date.internal.setUTCMinutes(date.internal.getUTCMinutes() + systemDSTChange);
  const offsetDiff = systemOffset - offset5;
  if (offsetDiff) Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + offsetDiff);
  const systemDate = /* @__PURE__ */ new Date(+date);
  systemDate.setUTCSeconds(0);
  const systemSecondsOffset = systemOffset > 0 ? systemDate.getSeconds() : (systemDate.getSeconds() - 60) % 60;
  const secondsOffset = Math.round(-(tzOffset(date.timeZone, date) * 60)) % 60;
  if (secondsOffset || systemSecondsOffset) {
    date.internal.setUTCSeconds(date.internal.getUTCSeconds() + secondsOffset);
    Date.prototype.setUTCSeconds.call(date, Date.prototype.getUTCSeconds.call(date) + secondsOffset + systemSecondsOffset);
  }
  const postBaseOffset = tzOffset(date.timeZone, date);
  const postOffset = postBaseOffset > 0 ? Math.floor(postBaseOffset) : Math.ceil(postBaseOffset);
  const postSystemOffset = -(/* @__PURE__ */ new Date(+date)).getTimezoneOffset();
  const postOffsetDiff = postSystemOffset - postOffset;
  const offsetChanged = postOffset !== offset5;
  const postDiff = postOffsetDiff - offsetDiff;
  if (offsetChanged && postDiff) {
    Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + postDiff);
    const newBaseOffset = tzOffset(date.timeZone, date);
    const newOffset = newBaseOffset > 0 ? Math.floor(newBaseOffset) : Math.ceil(newBaseOffset);
    const offsetChange = postOffset - newOffset;
    if (offsetChange) {
      date.internal.setUTCMinutes(date.internal.getUTCMinutes() + offsetChange);
      Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + offsetChange);
    }
  }
}

// node_modules/@vkontakte/vkui-date-fns-tz/date/index.js
var TZDate = class _TZDate extends TZDateMini {
  //#region static
  static tz(tz, ...args) {
    return args.length ? new _TZDate(...args, tz) : new _TZDate(Date.now(), tz);
  }
  //#endregion
  //#region representation
  toISOString() {
    const [sign, hours2, minutes2] = this.tzComponents();
    const tz = `${sign}${hours2}:${minutes2}`;
    return this.internal.toISOString().slice(0, -1) + tz;
  }
  toString() {
    return `${this.toDateString()} ${this.toTimeString()}`;
  }
  toDateString() {
    const [day, date, month, year] = this.internal.toUTCString().split(" ");
    return `${day === null || day === void 0 ? void 0 : day.slice(0, -1)} ${month} ${date} ${year}`;
  }
  toTimeString() {
    const time = this.internal.toUTCString().split(" ")[4];
    const [sign, hours2, minutes2] = this.tzComponents();
    return `${time} GMT${sign}${hours2}${minutes2} (${tzName(this.timeZone, this)})`;
  }
  toLocaleString(locales, options) {
    return Date.prototype.toLocaleString.call(this, locales, _object_spread_props(_object_spread({}, options), {
      timeZone: (options === null || options === void 0 ? void 0 : options.timeZone) || this.timeZone
    }));
  }
  toLocaleDateString(locales, options) {
    return Date.prototype.toLocaleDateString.call(this, locales, _object_spread_props(_object_spread({}, options), {
      timeZone: (options === null || options === void 0 ? void 0 : options.timeZone) || this.timeZone
    }));
  }
  toLocaleTimeString(locales, options) {
    return Date.prototype.toLocaleTimeString.call(this, locales, _object_spread_props(_object_spread({}, options), {
      timeZone: (options === null || options === void 0 ? void 0 : options.timeZone) || this.timeZone
    }));
  }
  //#endregion
  //#region private
  tzComponents() {
    const offset5 = this.getTimezoneOffset();
    const sign = offset5 > 0 ? "-" : "+";
    const hours2 = String(Math.floor(Math.abs(offset5) / 60)).padStart(2, "0");
    const minutes2 = String(Math.abs(offset5) % 60).padStart(2, "0");
    return [
      sign,
      hours2,
      minutes2
    ];
  }
  //#endregion
  withTimeZone(timeZone) {
    return new _TZDate(+this, timeZone);
  }
  //#region date-fns integration
  [/* @__PURE__ */ Symbol.for("constructDateFrom")](date) {
    return new _TZDate(+new Date(date), this.timeZone);
  }
};

// node_modules/@vkontakte/vkui/dist/lib/date.js
function parse(input, format, referenceDate = /* @__PURE__ */ new Date()) {
  const match2 = /^\d\d/;
  const match4 = /^\d{4}/;
  const entries = [
    [
      "yyyy",
      match4,
      (val) => [
        "Y",
        +val,
        true
      ]
    ],
    [
      "MM",
      match2,
      (val) => {
        const numVal = +val;
        const okay = numVal > 0 && numVal <= 12;
        return [
          "M",
          numVal - 1,
          okay
        ];
      }
    ],
    [
      "dd",
      match2,
      (val) => [
        "D",
        +val,
        true
      ]
    ],
    [
      "HH",
      match2,
      (val) => {
        const numVal = parseInt(val, 10);
        const okay = numVal >= 0 && numVal < 24;
        return [
          "h",
          numVal,
          okay
        ];
      }
    ],
    [
      "mm",
      match2,
      (val) => {
        const numVal = parseInt(val, 10);
        const okay = numVal >= 0 && numVal < 60;
        return [
          "m",
          numVal,
          okay
        ];
      }
    ]
  ];
  const superRegExp = new RegExp(entries.map((item) => item[0]).join("|"), "g");
  const store = {
    y: referenceDate.getFullYear(),
    M: referenceDate.getMonth(),
    d: referenceDate.getDate(),
    h: referenceDate.getHours(),
    m: referenceDate.getMinutes(),
    s: referenceDate.getSeconds(),
    ms: referenceDate.getMilliseconds()
  };
  let prevInputIndex = 0;
  let lastNonFormatting = "";
  let lastFormatIndex = 0;
  let found = false;
  while (true) {
    const match = superRegExp.exec(format);
    if (!match) {
      break;
    }
    const length = match[0].length;
    const atIndex = superRegExp.lastIndex - length;
    const item = entries.find((item2) => item2[0] === match[0]);
    lastNonFormatting = format.slice(lastFormatIndex, atIndex);
    lastFormatIndex = superRegExp.lastIndex;
    if (input.slice(prevInputIndex, prevInputIndex + lastNonFormatting.length) !== lastNonFormatting) {
      return /* @__PURE__ */ new Date("");
    }
    const value = input.slice(prevInputIndex + lastNonFormatting.length).match(item[1]);
    if (!value) {
      return /* @__PURE__ */ new Date("");
    }
    prevInputIndex = prevInputIndex + lastNonFormatting.length + value[0].length;
    const [key, newValue, okay] = item[2](value[0]);
    if (!okay) {
      return /* @__PURE__ */ new Date("");
    }
    store[key] = newValue;
    found = true;
  }
  if (!found) {
    return /* @__PURE__ */ new Date("");
  }
  const date = new Date(store.Y, store.M, store.D, store.h, store.m, store.s, store.ms);
  if (date.getMonth() !== store.M || date.getDate() !== store.D) {
    return /* @__PURE__ */ new Date("");
  }
  return date;
}
var convertDateToTimeZone = (date, timezone) => {
  if (!timezone) {
    return date;
  }
  if (date === null) {
    return null;
  }
  return date ? TZDateMini.tz(timezone, date) : void 0;
};
var convertDateFromTimeZone = (date, timezone) => {
  if (!timezone) {
    return date;
  }
  if (date === null) {
    return null;
  }
  const systemTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  return date ? TZDateMini.tz(systemTimezone, date) : void 0;
};
var dateOptions = {
  day: "2-digit",
  month: "2-digit",
  year: "numeric"
};
var dateFormatter = new Intl.DateTimeFormat("ru-RU", dateOptions);
var DateTimeFormat = class extends Intl.DateTimeFormat {
  format(date) {
    return super.format(date).replace(",", "");
  }
  constructor() {
    super("ru-RU", _object_spread_props(_object_spread({}, dateOptions), {
      hour: "2-digit",
      minute: "2-digit"
    }));
  }
};
var dateTimeFormatter = new DateTimeFormat();
function startOfMonth(date) {
  const result = new Date(date);
  result.setDate(1);
  result.setHours(0, 0, 0, 0);
  return result;
}
function endOfMonth(date) {
  const result = new Date(date);
  const month = result.getMonth();
  result.setFullYear(result.getFullYear(), month + 1, 0);
  result.setHours(23, 59, 59, 999);
  return result;
}
var MONDAY = 1;
function startOfWeek(date, { weekStartsOn = MONDAY } = {}) {
  const result = new Date(date);
  const day = result.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  result.setDate(result.getDate() - diff);
  result.setHours(0, 0, 0, 0);
  return result;
}
function endOfWeek(date, { weekStartsOn = MONDAY } = {}) {
  const result = new Date(date);
  const day = result.getDay();
  const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  result.setDate(result.getDate() + diff);
  result.setHours(23, 59, 59, 999);
  return result;
}
function startOfDay(date) {
  const result = new Date(date);
  result.setHours(0, 0, 0, 0);
  return result;
}
function endOfDay(date) {
  const result = new Date(date);
  result.setHours(23, 59, 59, 999);
  return result;
}
function startOfTomorrow() {
  const date = /* @__PURE__ */ new Date();
  const day = date.getDate();
  date.setDate(day + 1);
  date.setHours(0, 0, 0, 0);
  return date;
}
function startOfMinute(date) {
  const result = new Date(date);
  result.setSeconds(0, 0);
  return result;
}
function eachDayOfInterval(startDate, endDate, { step = 1 } = {}) {
  let reversed = +startDate > +endDate;
  const endTime = reversed ? +startDate : +endDate;
  const date = new Date(reversed ? endDate : startDate);
  date.setHours(0, 0, 0, 0);
  if (!step) {
    return [];
  }
  if (step < 0) {
    step = -step;
    reversed = !reversed;
  }
  const dates = [];
  while (+date <= endTime) {
    dates.push(new Date(date));
    date.setDate(date.getDate() + 1);
    date.setHours(0, 0, 0, 0);
  }
  return reversed ? dates.reverse() : dates;
}
function isSameMonth(d1, d2) {
  return d1.getMonth() === d2.getMonth() && d1.getFullYear() === d2.getFullYear();
}
function isLastDayOfMonth(date) {
  return +endOfDay(date) === +endOfMonth(date);
}
function isWithinInterval(date, interval) {
  const [startTime, endTime] = interval.sort((a, b) => +a - +b);
  return date >= startTime && date <= endTime;
}
function isMatch(input, format) {
  return !isNaN(+parse(input, format));
}
var millisecondsInSecond = 1e3;
function addDays2(date, amount) {
  const result = new Date(date);
  if (!amount) {
    return result;
  }
  result.setDate(result.getDate() + amount);
  return result;
}
function subDays(date, amount) {
  return addDays2(date, -amount);
}
function addWeeks(date, amount) {
  return addDays2(date, amount * 7);
}
function subWeeks(date, amount) {
  return addWeeks(date, -amount);
}
function addMonths(date, amount) {
  const result = new Date(date);
  if (!amount) {
    return result;
  }
  const dayOfMonth = result.getDate();
  const endOfDesiredMonth = new Date(date);
  endOfDesiredMonth.setMonth(result.getMonth() + amount + 1, 0);
  const daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  }
  result.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
  return result;
}
function subMonths(date, amount) {
  return addMonths(date, -amount);
}
function setYear(date, year) {
  const result = new Date(date);
  result.setFullYear(year);
  return result;
}
function getDaysInMonth(date) {
  const result = new Date(date);
  const lastDayOfMonth = new Date(result);
  lastDayOfMonth.setFullYear(result.getFullYear(), result.getMonth() + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return lastDayOfMonth.getDate();
}
function setMonth(date, month) {
  const result = new Date(date);
  const year = result.getFullYear();
  const day = result.getDate();
  const midMonth = new Date(date);
  midMonth.setFullYear(year, month, 15);
  midMonth.setHours(0, 0, 0, 0);
  const daysInMonth = getDaysInMonth(midMonth);
  result.setMonth(month, Math.min(day, daysInMonth));
  return result;
}
function setHours(date, hours2) {
  const result = new Date(date);
  result.setHours(hours2);
  return result;
}
function setMinutes(date, minutes2) {
  const result = new Date(date);
  result.setMinutes(minutes2);
  return result;
}

// node_modules/@vkontakte/vkui/dist/lib/animation/useCSSTransition.js
var forceReflowForFixNewMountedElement = (node) => void (node === null || node === void 0 ? void 0 : node.scrollTop);
var TRANSITION_FALLBACK_DELAY = 100;
var useCSSTransition = (inProp, { enableAppear = false, enableEnter = true, enableExit = true, onEnter: onEnterProp, onEntering: onEnteringProp, onEntered: onEnteredProp, onExit: onExitProp, onExiting: onExitingProp, onExited: onExitedProp } = {}) => {
  const onEnter = useStableCallback(onEnterProp || noop);
  const onEntering = useStableCallback(onEnteringProp || noop);
  const onEntered = useStableCallback(onEnteredProp || noop);
  const onExit = useStableCallback(onExitProp || noop);
  const onExiting = useStableCallback(onExitingProp || noop);
  const onExited = useStableCallback(onExitedProp || noop);
  const timerRef = (0, import_react7.useRef)(null);
  const ref = (0, import_react7.useRef)(null);
  const [state, setState] = (0, import_react7.useState)(() => {
    if (!inProp) {
      return "exited";
    }
    if (enableAppear) {
      onEnter(true);
      return "appear";
    }
    return "entered";
  });
  const clearTimer = () => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
      timerRef.current = null;
    }
  };
  useIsomorphicLayoutEffect(function updateState() {
    if (inProp) {
      switch (state) {
        case "appear":
          forceReflowForFixNewMountedElement(ref.current);
          setState("appearing");
          onEntering(true);
          break;
        case "enter":
          forceReflowForFixNewMountedElement(ref.current);
          setState("entering");
          onEntering();
          break;
        case "exiting":
          if (enableEnter) {
            setState("entering");
            onEntering();
            break;
          }
          setState("entered");
          onEntered();
          break;
        case "exited":
          if (enableEnter) {
            setState("enter");
            onEnter();
            break;
          }
          setState("entered");
          onEntered();
          break;
      }
    } else {
      switch (state) {
        case "exit":
          forceReflowForFixNewMountedElement(ref.current);
          setState("exiting");
          onExiting();
          break;
        case "appearing":
        case "entering":
          if (enableExit) {
            setState("exiting");
            onExiting();
            break;
          }
          setState("exited");
          onExited();
          break;
        case "appeared":
        case "entered":
          if (enableExit) {
            setState("exit");
            onExit();
            break;
          }
          setState("exited");
          onExited();
          break;
      }
    }
  }, [
    inProp,
    state,
    enableAppear,
    enableEnter,
    onEnter,
    onEntering,
    onEntered,
    enableExit,
    onExit,
    onExiting,
    onExited
  ]);
  const completeTransition = useStableCallback((event) => {
    clearTimer();
    switch (state) {
      case "appearing":
        setState("appeared");
        onEntered(event === null || event === void 0 ? void 0 : event.propertyName, true);
        break;
      case "entering":
        setState("entered");
        onEntered(event === null || event === void 0 ? void 0 : event.propertyName);
        break;
      case "exiting":
        setState("exited");
        onExited(event === null || event === void 0 ? void 0 : event.propertyName);
        break;
    }
  });
  useIsomorphicLayoutEffect(function scheduleTransitionCompletionFallback() {
    const el = ref.current;
    if (!el) {
      return;
    }
    if (state === "appearing" || state === "entering" || state === "exiting") {
      const style = getComputedStyle(el);
      const parseTime = (s) => s.includes("ms") ? parseFloat(s) : parseFloat(s) * millisecondsInSecond;
      const duration = Math.max(...style.transitionDuration.split(",").map(parseTime)) + Math.max(...style.transitionDelay.split(",").map(parseTime));
      if (duration <= 0) {
        completeTransition();
        return;
      }
      timerRef.current = setTimeout(completeTransition, duration + TRANSITION_FALLBACK_DELAY);
      return clearTimer;
    }
    return;
  }, [
    completeTransition,
    state
  ]);
  return [
    state,
    {
      ref,
      onTransitionEnd: state !== "appeared" && state !== "entered" && state !== "exited" ? completeTransition : void 0
    }
  ];
};

// node_modules/@vkontakte/vkui/dist/components/Spinner/SpinnerAnimation.js
function SpinnerAnimation({ size: size5 = "m" }) {
  const isReducedMotion = useReducedMotion();
  if (isReducedMotion === void 0) {
    return null;
  }
  if (isReducedMotion) {
    return (0, import_jsx_runtime31.jsx)("animate", {
      attributeName: "opacity",
      keyTimes: "0; 0.5; 1",
      values: "1; 0.1; 1",
      begin: "0s",
      dur: "2s",
      repeatCount: "indefinite"
    });
  }
  const center = {
    s: 8,
    m: 12,
    l: 16,
    xl: 22
  }[size5];
  return (0, import_jsx_runtime31.jsx)("animateTransform", {
    attributeType: "XML",
    attributeName: "transform",
    type: "rotate",
    from: `0 ${center} ${center}`,
    to: `360 ${center} ${center}`,
    dur: "0.7s",
    repeatCount: "indefinite"
  });
}

// node_modules/@vkontakte/vkui/dist/components/Spinner/icons.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var React40 = __toESM(require_react(), 1);
function iconClassName(size5) {
  return `vkuiIcon vkuiIcon--${size5} vkuiIcon--w-${size5} vkuiIcon--h-${size5}`;
}
function Icon16Spinner({ children }) {
  return (0, import_jsx_runtime32.jsx)("svg", {
    className: iconClassName(16),
    "aria-hidden": "true",
    width: "16",
    height: "16",
    children: (0, import_jsx_runtime32.jsx)("path", {
      fill: "currentColor",
      d: "M8 3.25a4.75 4.75 0 0 0-4.149 7.065.75.75 0 1 1-1.31.732A6.25 6.25 0 1 1 8 14.25a.75.75 0 0 1 .001-1.5 4.75 4.75 0 1 0 0-9.5Z",
      children
    })
  });
}
function Icon24Spinner({ children }) {
  return (0, import_jsx_runtime32.jsx)("svg", {
    className: iconClassName(24),
    "aria-hidden": "true",
    width: "24",
    height: "24",
    children: (0, import_jsx_runtime32.jsx)("path", {
      fill: "currentColor",
      d: "M16.394 5.077A8.2 8.2 0 0 0 4.58 15.49a.9.9 0 0 1-1.628.767A10 10 0 1 1 12 22a.9.9 0 0 1 0-1.8 8.2 8.2 0 0 0 4.394-15.123",
      children
    })
  });
}
function Icon32Spinner({ children }) {
  return (0, import_jsx_runtime32.jsx)("svg", {
    className: iconClassName(32),
    "aria-hidden": "true",
    width: "32",
    height: "32",
    children: (0, import_jsx_runtime32.jsx)("path", {
      fill: "currentColor",
      d: "M16 32a1.5 1.5 0 0 1 0-3c7.18 0 13-5.82 13-13S23.18 3 16 3 3 8.82 3 16c0 1.557.273 3.074.8 4.502A1.5 1.5 0 1 1 .986 21.54 16 16 0 0 1 0 16C0 7.163 7.163 0 16 0s16 7.163 16 16-7.163 16-16 16",
      children
    })
  });
}
function Icon44Spinner({ children }) {
  return (0, import_jsx_runtime32.jsx)("svg", {
    className: iconClassName(44),
    "aria-hidden": "true",
    width: "44",
    height: "44",
    children: (0, import_jsx_runtime32.jsx)("path", {
      fill: "currentColor",
      d: "M22 44a1.5 1.5 0 0 1 0-3c10.493 0 19-8.507 19-19S32.493 3 22 3 3 11.507 3 22c0 2.208.376 4.363 1.103 6.397a1.5 1.5 0 1 1-2.825 1.01A22 22 0 0 1 0 22C0 9.85 9.85 0 22 0s22 9.85 22 22-9.85 22-22 22",
      children
    })
  });
}

// node_modules/@vkontakte/vkui/dist/components/Spinner/Spinner.js
var spinnerIconMap = {
  s: Icon16Spinner,
  m: Icon24Spinner,
  l: Icon32Spinner,
  xl: Icon44Spinner
};
var Spinner = React41.memo((_param) => {
  var { size: size5 = "m", children = "Загружается...", disableAnimation = false, noColor = false, visibilityDelay } = _param, restProps = _object_without_properties(_param, [
    "size",
    "children",
    "disableAnimation",
    "noColor",
    "visibilityDelay"
  ]);
  const SpinnerIcon = spinnerIconMap[size5];
  return (0, import_jsx_runtime33.jsxs)(RootComponent, _object_spread_props(_object_spread({
    Component: "span",
    role: "status"
  }, restProps), {
    baseClassName: clsx("vkuiSpinner__host", noColor && "vkuiSpinner__noColor", visibilityDelay && "vkuistyles__visibilityDelay"),
    baseStyle: animationVisibilityDelayStyles(visibilityDelay),
    children: [
      (0, import_jsx_runtime33.jsx)(SpinnerIcon, {
        children: disableAnimation ? null : (0, import_jsx_runtime33.jsx)(SpinnerAnimation, {
          size: size5
        })
      }),
      hasReactNode(children) && (0, import_jsx_runtime33.jsx)(VisuallyHidden, {
        children
      })
    ]
  }));
});
if (true) {
  defineComponentDisplayNames(Spinner, "Spinner");
}

// node_modules/@vkontakte/vkui/dist/components/Button/Button.js
var stylesSize = {
  s: "vkuiButton__sizeS",
  m: "vkuiButton__sizeM",
  l: "vkuiButton__sizeL"
};
var stylesMode = {
  primary: "vkuiButton__modePrimary",
  secondary: "vkuiButton__modeSecondary",
  tertiary: "vkuiButton__modeTertiary",
  outline: "vkuiButton__modeOutline",
  link: "vkuiButton__modeLink"
};
var stylesAppearance = {
  "accent": "vkuiButton__appearanceAccent",
  "positive": "vkuiButton__appearancePositive",
  "negative": "vkuiButton__appearanceNegative",
  "neutral": "vkuiButton__appearanceNeutral",
  "overlay": "vkuiButton__appearanceOverlay",
  "accent-invariable": "vkuiButton__appearanceAccentInvariable"
};
var stylesAlign2 = {
  left: "vkuiButton__alignLeft",
  right: "vkuiButton__alignRight"
};
var sizeYClassNames10 = {
  none: "vkuiButton__sizeYNone",
  regular: "vkuiButton__sizeYRegular"
};
var Button = (_param) => {
  var { size: size5 = "s", mode = "primary", appearance = "accent", stretched = false, align = "center", children, before, after, getRootRef, loading, onClick, disableSpinnerAnimation, rounded, disabled } = _param, restProps = _object_without_properties(_param, [
    "size",
    "mode",
    "appearance",
    "stretched",
    "align",
    "children",
    "before",
    "after",
    "getRootRef",
    "loading",
    "onClick",
    "disableSpinnerAnimation",
    "rounded",
    "disabled"
  ]);
  const hasIconOnly = !children && Boolean(after) !== Boolean(before);
  const { sizeY = "none" } = useAdaptivity();
  const platform3 = usePlatform();
  return (0, import_jsx_runtime34.jsxs)(Tappable, _object_spread_props(_object_spread(_object_spread_props(_object_spread({
    hoverMode: "vkuiButton__hover",
    activeMode: "vkuiButton__active"
  }, restProps.href === void 0 && {
    Component: "button"
  }), {
    focusVisibleMode: "outside",
    disabled: loading || disabled
  }), restProps), {
    onClick: loading ? void 0 : onClick,
    baseClassName: clsx("vkuiButton__host", stylesSize[size5], stylesMode[mode], stylesAppearance[appearance], align !== "center" && stylesAlign2[align], sizeY !== "compact" && sizeYClassNames10[sizeY], platform3 === "ios" && "vkuiButton__ios", stretched && "vkuiButton__stretched", hasIconOnly && !stretched && "vkuiButton__singleIcon", loading && "vkuiButton__loading", rounded && "vkuiButton__rounded", disabled && "vkuiButton__disabled"),
    getRootRef,
    children: [
      loading && (0, import_jsx_runtime34.jsx)(Spinner, {
        size: "s",
        className: "vkuiButton__spinner",
        disableAnimation: disableSpinnerAnimation,
        noColor: true
      }),
      (0, import_jsx_runtime34.jsxs)("span", {
        className: "vkuiButton__in",
        children: [
          hasReactNode(before) && (0, import_jsx_runtime34.jsx)("span", {
            className: "vkuiButton__before",
            role: "presentation",
            "data-testid": false ? "before" : void 0,
            children: before
          }),
          hasReactNode(children) && (0, import_jsx_runtime34.jsx)("span", {
            className: "vkuiButton__content",
            "data-testid": false ? "children" : void 0,
            children
          }),
          hasReactNode(after) && (0, import_jsx_runtime34.jsx)("span", {
            className: "vkuiButton__after",
            role: "presentation",
            "data-testid": false ? "after" : void 0,
            children: after
          })
        ]
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/IconButton/IconButton.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var sizeYClassNames11 = {
  none: "vkuiIconButton__sizeYNone",
  compact: "vkuiIconButton__sizeYCompact"
};
var warn2 = warnOnce("IconButton");
var IconButton = (_param) => {
  var { label, children } = _param, restProps = _object_without_properties(_param, [
    "label",
    "children"
  ]);
  const platform3 = usePlatform();
  const { sizeY = "none" } = useAdaptivity();
  if (true) {
    const isAccessible = hasAccessibleName(_object_spread({
      children: [
        children,
        label
      ]
    }, restProps));
    if (!isAccessible) {
      warn2(COMMON_WARNINGS.a11y[restProps.href ? "link-name" : "button-name"], "error");
    }
  }
  return (0, import_jsx_runtime35.jsxs)(Tappable, _object_spread_props(_object_spread({
    activeEffectDelay: 200,
    activeMode: "background",
    Component: restProps.href ? "a" : "button"
  }, restProps), {
    baseClassName: clsx("vkuiIconButton__host", sizeY !== "regular" && sizeYClassNames11[sizeY], platform3 === "ios" && "vkuiIconButton__ios"),
    children: [
      label && (0, import_jsx_runtime35.jsx)(VisuallyHidden, {
        children: label
      }),
      children
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ToolButton/ToolButton.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);

// node_modules/@vkontakte/vkui/dist/components/AdaptiveIconRenderer/AdaptiveIconRenderer.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var React44 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityConditionalRender/useAdaptivityConditionalRender.js
var React43 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityConditionalRender/constants.js
var forcedProps = {
  className: ""
};
var sizeXCompactMediaQueryProps = {
  className: "vkuistyles__-sizeX--compact-mq"
};
var sizeXRegularMediaQueryProps = {
  className: "vkuistyles__-sizeX--regular-mq"
};
var sizeYCompactMediaQueryProps = {
  className: "vkuistyles__-sizeY--compact-mq"
};
var sizeYRegularMediaQueryProps = {
  className: "vkuistyles__-sizeY--regular-mq"
};
var viewWidthMediaQueryMapProps = {
  tabletMinus: {
    className: "vkuistyles__-viewWidth--tabletMinus-mq"
  },
  tabletPlus: {
    className: "vkuistyles__-viewWidth--tabletPlus-mq"
  }
};
var deviceTypeMediaQueryMapProps = {
  mobile: {
    className: "vkuistyles__-deviceType--mobile-mq"
  },
  desktop: {
    className: "vkuistyles__-deviceType--desktop-mq"
  }
};

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityConditionalRender/helpers.js
var getAdaptiveSizeType = (type, compactMediaQueryProps, regularMediaQueryProps) => {
  return {
    compact: type === void 0 ? compactMediaQueryProps : type === "compact" ? forcedProps : false,
    regular: type === void 0 ? regularMediaQueryProps : type === "regular" ? forcedProps : false
  };
};
var getAdaptiveViewWidth = (viewWidth, viewWidthMapProps) => {
  return {
    tabletMinus: viewWidth === void 0 ? viewWidthMapProps.tabletMinus : viewWidth < ViewWidth.TABLET ? forcedProps : false,
    tabletPlus: viewWidth === void 0 ? viewWidthMapProps.tabletPlus : viewWidth >= ViewWidth.TABLET ? forcedProps : false
  };
};
var getAdaptiveDeviceType = (viewWidth, viewHeight, hasPointer, platform3, deviceTypeMapProps) => {
  const isDesktop = tryToCheckIsDesktop(viewWidth, viewHeight, hasPointer, platform3);
  if (isDesktop === null) {
    return {
      mobile: deviceTypeMapProps.mobile,
      desktop: deviceTypeMapProps.desktop
    };
  }
  if (isDesktop) {
    return {
      mobile: false,
      desktop: forcedProps
    };
  }
  return {
    mobile: forcedProps,
    desktop: false
  };
};

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityConditionalRender/useAdaptivityConditionalRender.js
var useAdaptivityConditionalRender = () => {
  const { sizeX: sizeXContext, sizeY: sizeYContext, viewWidth: viewWidthContext, viewHeight: viewHeightContext, hasPointer: hasPointerContext } = React43.useContext(AdaptivityContext);
  const platform3 = usePlatform();
  return React43.useMemo(() => {
    const sizeX = getAdaptiveSizeType(sizeXContext, sizeXCompactMediaQueryProps, sizeXRegularMediaQueryProps);
    const sizeY = getAdaptiveSizeType(sizeYContext, sizeYCompactMediaQueryProps, sizeYRegularMediaQueryProps);
    const viewWidth = getAdaptiveViewWidth(viewWidthContext, viewWidthMediaQueryMapProps);
    const deviceType = getAdaptiveDeviceType(viewWidthContext, viewHeightContext, hasPointerContext, platform3, deviceTypeMediaQueryMapProps);
    return {
      sizeX,
      sizeY,
      viewWidth,
      deviceType
    };
  }, [
    sizeXContext,
    sizeYContext,
    viewWidthContext,
    viewHeightContext,
    hasPointerContext,
    platform3
  ]);
};

// node_modules/@vkontakte/vkui/dist/components/AdaptiveIconRenderer/AdaptiveIconRenderer.js
var AdaptiveIconRenderer = ({ IconCompact, IconRegular }) => {
  const { sizeY } = useAdaptivityConditionalRender();
  return (0, import_jsx_runtime36.jsxs)(React44.Fragment, {
    children: [
      sizeY.compact && (0, import_jsx_runtime36.jsx)(IconCompact, {
        className: sizeY.compact.className
      }),
      sizeY.regular && (0, import_jsx_runtime36.jsx)(IconRegular, {
        className: sizeY.regular.className
      })
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/ToolButton/ToolButton.js
var stylesMode2 = {
  primary: "vkuiToolButton__modePrimary",
  secondary: "vkuiToolButton__modeSecondary",
  tertiary: "vkuiToolButton__modeTertiary",
  outline: "vkuiToolButton__modeOutline"
};
var stylesAppearance2 = {
  accent: "vkuiToolButton__appearanceAccent",
  neutral: "vkuiToolButton__appearanceNeutral"
};
var stylesDirection = {
  row: "vkuiToolButton__directionRow",
  column: "vkuiToolButton__directionColumn"
};
var sizeYClassNames12 = {
  none: "vkuiToolButton__sizeYNone",
  regular: "vkuiToolButton__sizeYRegular"
};
var ToolButton = (_param) => {
  var { mode = "primary", appearance = "accent", direction = "row", children, IconCompact, IconRegular, rounded } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "appearance",
    "direction",
    "children",
    "IconCompact",
    "IconRegular",
    "rounded"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const hasChildren = hasReactNode(children);
  return (0, import_jsx_runtime37.jsxs)(Tappable, _object_spread_props(_object_spread({
    hoverMode: "vkuiToolButton__hover",
    activeMode: "vkuiToolButton__active",
    Component: restProps.href ? "a" : "button",
    focusVisibleMode: "outside",
    baseClassName: clsx("vkuiToolButton__host", rounded && getRoundedClassName(direction, hasChildren), hasChildren && direction === "row" && "vkuiToolButton__withFakeEndIcon", stylesMode2[mode], stylesAppearance2[appearance], stylesDirection[direction], sizeY !== "compact" && sizeYClassNames12[sizeY])
  }, restProps), {
    children: [
      (0, import_jsx_runtime37.jsx)(AdaptiveIconRenderer, {
        IconCompact,
        IconRegular
      }),
      hasChildren && (0, import_jsx_runtime37.jsx)("span", {
        className: "vkuiToolButton__text",
        children
      })
    ]
  }));
};
function getRoundedClassName(direction, hasChildren) {
  switch (direction) {
    case "row":
      return "vkuiToolButton__rounded";
    case "column":
      return hasChildren ? void 0 : "vkuiToolButton__rounded";
  }
}

// node_modules/@vkontakte/vkui/dist/components/Root/Root.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var React47 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/lib/getNavId.js
function getNavId(props, warn40) {
  const id = props.nav || props.id;
  if (!id && warn40) {
    warn40('Навигационный элемент должен иметь свойство "nav" или "id"', "error");
  }
  return id;
}

// node_modules/@vkontakte/vkui/dist/components/NavTransitionContext/NavTransitionContext.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var React45 = __toESM(require_react(), 1);
var TransitionContext = React45.createContext({
  entering: false
});
var useNavTransition = () => React45.useContext(TransitionContext);
var NavTransitionProvider = ({ children, entering }) => {
  const parentContext = useNavTransition();
  const contextValue = React45.useMemo(() => ({
    entering: parentContext.entering || entering
  }), [
    entering,
    parentContext.entering
  ]);
  return (0, import_jsx_runtime38.jsx)(TransitionContext.Provider, {
    value: contextValue,
    children
  });
};

// node_modules/@vkontakte/vkui/dist/components/NavTransitionDirectionContext/NavTransitionDirectionContext.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var React46 = __toESM(require_react(), 1);
var TransitionDirectionContext = React46.createContext(void 0);
var NavTransitionDirectionProvider = ({ children, isBack: isBackProp }) => {
  const parentIsBack = React46.useContext(TransitionDirectionContext);
  const isBack = isBackProp !== void 0 ? isBackProp : parentIsBack;
  const [isBackOnMount] = React46.useState(isBack);
  return (0, import_jsx_runtime39.jsx)(TransitionDirectionContext.Provider, {
    value: isBackOnMount,
    children
  });
};
var useNavDirection = () => {
  const isBack = React46.useContext(TransitionDirectionContext);
  const transitionDirection = isBack === void 0 ? void 0 : isBack ? "backwards" : "forwards";
  return transitionDirection;
};

// node_modules/@vkontakte/vkui/dist/components/Root/Root.js
var warn3 = warnOnce("Root");
var Root = (_param) => {
  var { children, activeView: _activeView, onTransition, nav } = _param, restProps = _object_without_properties(_param, [
    "children",
    "activeView",
    "onTransition",
    "nav"
  ]);
  const scroll = React47.useContext(ScrollContext);
  const platform3 = usePlatform();
  const { document: document2 } = useDOM();
  const scrolls = React47.useRef({}).current;
  const viewNodes = React47.useRef({}).current;
  const { transitionMotionEnabled = true } = useConfigProvider();
  const { animate: animate3 } = React47.useContext(SplitColContext);
  const disableAnimation = !transitionMotionEnabled || !animate3;
  const views = React47.Children.toArray(children);
  const [{ prevView, activeView, transition, isBack }, _setState] = React47.useState({
    activeView: _activeView,
    transition: false
  });
  const transitionTo = (panel) => {
    if (panel !== activeView) {
      const viewIds = views.map((view) => getNavId(view.props, warn3));
      const isBack2 = viewIds.indexOf(panel) < viewIds.indexOf(activeView);
      scrolls[activeView] = scroll.getScroll().y;
      _setState({
        activeView: panel,
        prevView: activeView,
        transition: !disableAnimation,
        isBack: isBack2
      });
    }
  };
  const finishTransition = React47.useCallback(() => _setState({
    activeView,
    prevView,
    isBack,
    transition: false
  }), [
    activeView,
    isBack,
    prevView
  ]);
  useIsomorphicLayoutEffect(() => {
    document2.activeElement.blur();
  }, [
    activeView
  ]);
  useIsomorphicLayoutEffect(() => transitionTo(_activeView), [
    _activeView
  ]);
  useIsomorphicLayoutEffect(() => {
    if (!transition && prevView) {
      scroll.scrollTo(0, isBack ? scrolls[activeView] : 0);
      onTransition && onTransition({
        isBack: Boolean(isBack),
        from: prevView,
        to: activeView
      });
    }
  }, [
    transition,
    prevView
  ]);
  React47.useEffect(function onAnimationEndFallback() {
    if (transition && disableAnimation) {
      finishTransition();
    }
  }, [
    transition,
    disableAnimation,
    finishTransition
  ]);
  const onAnimationEnd = () => {
    finishTransition();
  };
  return (0, import_jsx_runtime40.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiRoot__host", platform3 === "ios" && "vkuiRoot__ios", transition && "vkuiRoot__transition"),
    children: views.map((view) => {
      const viewId = getNavId(view.props, warn3);
      if (viewId !== activeView && !(transition && viewId === prevView)) {
        return null;
      }
      const isTransitionTarget = transition && viewId === (isBack ? prevView : activeView);
      const compensateScroll = transition && (viewId === prevView || isBack && viewId === activeView);
      var _scrolls_viewId;
      return (0, import_jsx_runtime40.jsx)("div", {
        ref: (e) => {
          viewId && (viewNodes[viewId] = e);
        },
        onAnimationEnd: isTransitionTarget ? onAnimationEnd : void 0,
        className: clsx("vkuiRoot__view", transition && viewId === prevView && isBack && "vkuiRoot__viewHideBack", transition && viewId === prevView && !isBack && "vkuiRoot__viewHideForward", transition && viewId === activeView && isBack && "vkuiRoot__viewShowBack", transition && viewId === activeView && !isBack && "vkuiRoot__viewShowForward"),
        children: (0, import_jsx_runtime40.jsx)(NavTransitionDirectionProvider, {
          isBack,
          children: (0, import_jsx_runtime40.jsx)(NavTransitionProvider, {
            entering: transition && viewId === activeView,
            children: (0, import_jsx_runtime40.jsx)("div", {
              className: "vkuiRoot__scrollCompensation",
              style: {
                marginTop: compensateScroll ? viewId && -((_scrolls_viewId = scrolls[viewId]) !== null && _scrolls_viewId !== void 0 ? _scrolls_viewId : 0) : void 0
              },
              children: view
            })
          })
        })
      }, viewId);
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/View/View.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
var React57 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/usePrevious.js
var React48 = __toESM(require_react(), 1);
function usePrevious(value) {
  const ref = React48.useRef(void 0);
  React48.useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}

// node_modules/@vkontakte/vkui/dist/components/NavIdContext/NavIdContext.js
var React49 = __toESM(require_react(), 1);
var NavViewIdContext = React49.createContext(void 0);
var NavPanelIdContext = React49.createContext(void 0);

// node_modules/@vkontakte/vkui/dist/components/Touch/Touch.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var React50 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/lib/touch/functions.js
var coordX = (event) => {
  if ("clientX" in event) {
    return event.clientX;
  }
  return event.changedTouches && event.changedTouches[0].clientX;
};
var coordY = (event) => {
  if ("clientY" in event) {
    return event.clientY;
  }
  return event.changedTouches && event.changedTouches[0].clientY;
};
var touchEnabled = () => canUseDOM && "ontouchstart" in window;

// node_modules/@vkontakte/vkui/dist/lib/touch/UIPanGestureRecognizer.js
var DEFAULT_INITIAL_TIME = 0;
var UIPanGestureRecognizer = class {
  setInitialTimeOnce() {
    if (this.initialTime === DEFAULT_INITIAL_TIME) {
      this.initialTime = Date.now();
    }
  }
  setStartCoords(event) {
    const { clientX, clientY } = getFirstTouchEventData(event);
    this.x1 = clientX;
    this.y1 = clientY;
  }
  setEndCoords(event) {
    const { clientX, clientY } = getFirstTouchEventData(event);
    this.x2 = clientX;
    this.y2 = clientY;
  }
  delta() {
    return {
      x: this.x2 - this.x1,
      y: this.y2 - this.y1
    };
  }
  distance() {
    const { x, y } = this.delta();
    return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
  }
  velocity() {
    const deltaTime = (Date.now() - this.initialTime) / millisecondsInSecond;
    if (deltaTime <= 0) {
      return {
        x: 0,
        y: 0
      };
    }
    const { x, y } = this.delta();
    return {
      x: x / deltaTime,
      y: y / deltaTime
    };
  }
  angle() {
    const deltaX = this.x2 - this.x1;
    const deltaY = this.y2 - this.y1;
    const radians = Math.atan2(deltaY, deltaX);
    const degrees = radians * 180 / Math.PI;
    return degrees < 0 ? 360 + degrees : degrees;
  }
  direction() {
    const { x, y } = this.delta();
    return Math.abs(x) > Math.abs(y) ? {
      axis: "x",
      direction: x > 0 ? 1 : x < 0 ? -1 : null
    } : {
      axis: "y",
      direction: y > 0 ? 1 : y < 0 ? -1 : null
    };
  }
  reset() {
    this.initialTime = DEFAULT_INITIAL_TIME;
    this.x1 = this.y1 = 0;
    this.x2 = this.y2 = 0;
  }
  constructor() {
    _define_property(this, "initialTime", DEFAULT_INITIAL_TIME);
    _define_property(this, "x1", 0);
    _define_property(this, "y1", 0);
    _define_property(this, "x2", 0);
    _define_property(this, "y2", 0);
  }
};

// node_modules/@vkontakte/vkui/dist/components/Touch/Touch.js
function isTouchEvent(event) {
  return event.type.startsWith("touch");
}
function useMouseEventLock() {
  const isMouseEventLockRef = React50.useRef(false);
  const timerRef = React50.useRef(void 0);
  const isEventLock = React50.useCallback((event) => {
    return !isTouchEvent(event) && isMouseEventLockRef.current === true;
  }, []);
  const checkEvent = React50.useCallback((event) => {
    if (!isTouchEvent(event)) {
      return;
    }
    isMouseEventLockRef.current = true;
    clearTimeout(timerRef.current);
    timerRef.current = setTimeout(() => {
      isMouseEventLockRef.current = false;
    }, 1e3);
  }, []);
  React50.useEffect(() => () => clearTimeout(timerRef.current), []);
  return [
    isEventLock,
    checkEvent
  ];
}
var Touch = (_param) => {
  var { onStart, onStartX, onStartY, onMove, onMoveX, onMoveY, onEnter, onLeave, onEnd, onEndX, onEndY, onClickCapture, usePointerHover, slideThreshold = 5, useCapture = false, Component: Component2 = "div", getRootRef, noSlideClick = false, stopPropagation: stopPropagation2 = false } = _param, restProps = _object_without_properties(_param, [
    "onStart",
    "onStartX",
    "onStartY",
    "onMove",
    "onMoveX",
    "onMoveY",
    "onEnter",
    "onLeave",
    "onEnd",
    "onEndX",
    "onEndY",
    "onClickCapture",
    "usePointerHover",
    "slideThreshold",
    "useCapture",
    "Component",
    "getRootRef",
    "noSlideClick",
    "stopPropagation"
  ]);
  const hostRef = useExternRef(getRootRef);
  const [isTouchEnabled] = React50.useState(touchEnabled);
  const gestureRef = React50.useRef(null);
  const didSlide = React50.useRef(false);
  const disposeTargetNativeGestureEvents = React50.useRef(null);
  const [isEventLock, checkEventForLock] = useMouseEventLock();
  const cleanupTargetNativeGestureEvents = () => {
    gestureRef.current = null;
    if (disposeTargetNativeGestureEvents.current) {
      disposeTargetNativeGestureEvents.current();
      disposeTargetNativeGestureEvents.current = null;
    }
  };
  React50.useEffect(() => cleanupTargetNativeGestureEvents, []);
  const handleNativePointerUp = useStableCallback((event) => {
    const gesture = gestureRef.current;
    if (!gesture) {
      return;
    }
    if (gesture.isPressed) {
      dispatchUserHandlers(event, gesture, [
        onEnd,
        onEndX,
        onEndY
      ], stopPropagation2);
    }
    if (isTouchEvent(event)) {
      if (gesture.isSlide) {
        didSlide.current = false;
      }
      if (onLeave) {
        onLeave(event);
      }
    } else {
      didSlide.current = Boolean(gesture.isSlide);
    }
    cleanupTargetNativeGestureEvents();
  });
  const handleNativePointerMove = useStableCallback((event) => {
    const gesture = gestureRef.current;
    if (!gesture) {
      return;
    }
    const clientX = coordX(event);
    const clientY = coordY(event);
    const shiftX = clientX - gesture.startX;
    const shiftY = clientY - gesture.startY;
    const shiftXAbs = Math.abs(shiftX);
    const shiftYAbs = Math.abs(shiftY);
    if ("touches" in event && event.touches.length > 1) {
      return handleNativePointerUp(event);
    }
    if (!gesture.isX && !gesture.isY) {
      const willBeX = shiftXAbs >= slideThreshold && shiftXAbs > shiftYAbs;
      const willBeY = shiftYAbs >= slideThreshold && shiftYAbs > shiftXAbs;
      const willBeSlidedX = willBeX && (!!onMoveX || !!onMove);
      const willBeSlidedY = willBeY && (!!onMoveY || !!onMove);
      gesture.isY = willBeY;
      gesture.isX = willBeX;
      gesture.isSlideX = willBeSlidedX;
      gesture.isSlideY = willBeSlidedY;
      gesture.isSlide = willBeSlidedX || willBeSlidedY;
    }
    if (gesture.isSlide) {
      gesture.clientX = clientX;
      gesture.clientY = clientY;
      gesture.shiftX = shiftX;
      gesture.shiftY = shiftY;
      gesture.shiftXAbs = shiftXAbs;
      gesture.shiftYAbs = shiftYAbs;
      dispatchUserHandlers(event, gesture, [
        onMove,
        onMoveX,
        onMoveY
      ], stopPropagation2);
    }
  });
  const handlePointerDown = useStableCallback((event) => {
    if (isEventLock(event)) {
      return;
    }
    checkEventForLock(event);
    if (gestureRef.current !== null) {
      return;
    }
    const nativeEvent = "nativeEvent" in event ? event.nativeEvent : event;
    gestureRef.current = initGesture(coordX(nativeEvent), coordY(nativeEvent));
    const shouldCallDirectionHandlerOnlyIsSlide = false;
    dispatchUserHandlers(event, gestureRef.current, [
      onStart,
      onStartX,
      onStartY
    ], stopPropagation2, shouldCallDirectionHandlerOnlyIsSlide);
    const eventOptions = {
      capture: useCapture,
      passive: false
    };
    if (isTouchEvent(nativeEvent)) {
      if (isHTMLElement(event.target) || isSVGElement(event.target)) {
        const target = event.target;
        target.addEventListener("touchmove", handleNativePointerMove, eventOptions);
        target.addEventListener("touchend", handleNativePointerUp, eventOptions);
        target.addEventListener("touchcancel", handleNativePointerUp, eventOptions);
        disposeTargetNativeGestureEvents.current = () => {
          target.removeEventListener("touchmove", handleNativePointerMove, eventOptions);
          target.removeEventListener("touchend", handleNativePointerUp, eventOptions);
          target.removeEventListener("touchcancel", handleNativePointerUp, eventOptions);
        };
      }
    } else {
      const doc = getWindow(event.currentTarget).document;
      doc.addEventListener("mousemove", handleNativePointerMove, eventOptions);
      doc.addEventListener("mouseup", handleNativePointerUp, eventOptions);
      doc.addEventListener("mouseleave", handleNativePointerUp, eventOptions);
      disposeTargetNativeGestureEvents.current = () => {
        doc.removeEventListener("mousemove", handleNativePointerMove, eventOptions);
        doc.removeEventListener("mouseup", handleNativePointerUp, eventOptions);
        doc.removeEventListener("mouseleave", handleNativePointerUp, eventOptions);
      };
    }
  });
  const handlePointerEnter = onEnter ? (event) => onEnter(event.nativeEvent) : void 0;
  const handlePointerLeave = onLeave ? (event) => onLeave(event.nativeEvent) : void 0;
  const handleDragStart = (event) => {
    const target = event.target;
    if (target.tagName === "A" || target.tagName === "IMG") {
      event.preventDefault();
    }
  };
  const handleClickCapture = (event) => {
    if (!didSlide.current) {
      return onClickCapture && onClickCapture(event);
    }
    if (noSlideClick) {
      event.stopPropagation();
      event.preventDefault();
    } else {
      onClickCapture && onClickCapture(event);
    }
    didSlide.current = false;
  };
  useIsomorphicLayoutEffect(function initializeNativeTouchStartEventWithPassiveFalse() {
    const hostEl = hostRef.current;
    if (!hostEl || !isTouchEnabled) {
      return;
    }
    const options = {
      capture: useCapture,
      passive: false
    };
    hostEl.addEventListener("touchstart", handlePointerDown, options);
    return () => {
      hostEl.removeEventListener("touchstart", handlePointerDown, options);
    };
  }, [
    hostRef,
    isTouchEnabled,
    useCapture,
    handlePointerDown
  ]);
  return (0, import_jsx_runtime41.jsx)(Component2, _object_spread_props(_object_spread({}, restProps), {
    ref: hostRef,
    onDragStart: handleDragStart,
    onClickCapture: handleClickCapture,
    // onEnter
    onPointerEnter: usePointerHover ? handlePointerEnter : void 0,
    onMouseEnter: !usePointerHover ? handlePointerEnter : void 0,
    // onLeave
    onPointerLeave: usePointerHover ? handlePointerLeave : void 0,
    onMouseLeave: !usePointerHover ? handlePointerLeave : void 0,
    // handlePointerDown(onTouchStart устанавливается отдельно через initializeNativeTouchEventStartWithPassiveFalse)
    onMouseDownCapture: useCapture ? handlePointerDown : void 0,
    onMouseDown: !useCapture ? handlePointerDown : void 0
  }));
};
function initGesture(startX, startY) {
  return {
    startX,
    startY,
    startT: /* @__PURE__ */ new Date(),
    duration: 0,
    isPressed: true,
    isY: false,
    isX: false,
    isSlideX: false,
    isSlideY: false,
    isSlide: false,
    clientX: 0,
    clientY: 0,
    shiftX: 0,
    shiftY: 0,
    shiftXAbs: 0,
    shiftYAbs: 0
  };
}
function dispatchUserHandlers(event, gesture, [handler, handlerX, handlerY], stopPropagation2, shouldCallDirectionHandlerOnlyIsSlide = true) {
  if (stopPropagation2) {
    event.stopPropagation();
  }
  const data = _object_spread_props(_object_spread({}, gesture), {
    originalEvent: event,
    duration: Date.now() - gesture.startT.getTime()
  });
  if (handler) {
    handler(data);
  }
  if (handlerX) {
    if (shouldCallDirectionHandlerOnlyIsSlide) {
      if (gesture.isSlideX) {
        handlerX(data);
      }
    } else {
      handlerX(data);
    }
  }
  if (handlerY) {
    if (shouldCallDirectionHandlerOnlyIsSlide) {
      if (gesture.isSlideY) {
        handlerY(data);
      }
    } else {
      handlerY(data);
    }
  }
}

// node_modules/@vkontakte/vkui/dist/components/View/useLayoutEffectCall.js
var React51 = __toESM(require_react(), 1);
function useLayoutEffectCall() {
  const [fns] = React51.useState(() => []);
  useIsomorphicLayoutEffect(() => {
    while (fns.length > 0) {
      fns.pop()();
    }
  });
  const add = React51.useCallback((fn) => fns.push(fn), [
    fns
  ]);
  return add;
}

// node_modules/@vkontakte/vkui/dist/lib/floating/functions.js
function checkIsNotAutoPlacement(placement) {
  return !placement.startsWith("auto");
}
function getAutoPlacementAlign(placement) {
  const align = placement.replace(/auto-|auto/, "");
  return align === "start" || align === "end" ? align : null;
}
function convertFloatingDataToReactCSSProperties({ strategy, x, y, initialWidth = "max-content", middlewareData }) {
  const styles = {
    position: strategy,
    top: y,
    right: "auto",
    bottom: "auto",
    left: x
  };
  if (initialWidth !== null) {
    styles.width = initialWidth;
  }
  if (middlewareData) {
    const hide5 = middlewareData.hide;
    if (hide5 && hide5.referenceHidden) {
      styles["visibility"] = "hidden";
    }
  }
  return styles;
}
var getArrowCoordsByMiddlewareData = (middlewareData) => {
  const coords = {
    x: 0,
    y: 0
  };
  if (middlewareData.arrow) {
    const { x = 0, y = 0 } = middlewareData.arrow;
    coords.x = x;
    coords.y = y;
  }
  return coords;
};

// node_modules/@swc/helpers/esm/_array_with_holes.js
function _array_with_holes(arr) {
  if (Array.isArray(arr)) return arr;
}

// node_modules/@swc/helpers/esm/_iterable_to_array_limit.js
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}

// node_modules/@swc/helpers/esm/_non_iterable_rest.js
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@swc/helpers/esm/_sliced_to_array.js
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform3,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform3.getClippingRect({
    element: ((_await$platform$isEle = await (platform3.isElement == null ? void 0 : platform3.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform3.getDocumentElement == null ? void 0 : platform3.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform3.getOffsetParent == null ? void 0 : platform3.getOffsetParent(elements.floating));
  const offsetScale = await (platform3.isElement == null ? void 0 : platform3.isElement(offsetParent)) ? await (platform3.getScale == null ? void 0 : platform3.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform3.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform3.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform3
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform3.isRTL == null ? void 0 : platform3.isRTL(floating));
  let rects = await platform3.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    var _platform$detectOverf;
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: {
        ...platform3,
        detectOverflow: (_platform$detectOverf = platform3.detectOverflow) != null ? _platform$detectOverf : detectOverflow
      },
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform3.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform3,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform3.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform3.getOffsetParent == null ? void 0 : platform3.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform3.isElement == null ? void 0 : platform3.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset5 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset5 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset5,
        centerOffset: center - offset5 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
var autoPlacement = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform: platform3,
        elements
      } = state;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = placements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      const placements$1 = alignment !== void 0 || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await platform3.detectOverflow(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements$1[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform3.isRTL == null ? void 0 : platform3.isRTL(elements.floating)));
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements$1[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
      const allOverflows = [...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements$1[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map((d) => {
        const alignment2 = getAlignment(d.placement);
        return [d.placement, alignment2 && crossAxis ? (
          // Check along the mainAxis and main crossAxis side.
          d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0)
        ) : (
          // Check only the mainAxis.
          d.overflows[0]
        ), d.overflows];
      }).sort((a, b) => a[1] - b[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d) => d[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        getAlignment(d[0]) ? 2 : 3
      ).every((v) => v <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform3,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform3.isRTL == null ? void 0 : platform3.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await platform3.detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects,
        platform: platform3
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await platform3.detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await platform3.detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform3,
    elements
  } = state;
  const rtl = await (platform3.isRTL == null ? void 0 : platform3.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement,
        platform: platform3
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await platform3.detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform3,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await platform3.detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform3.isRTL == null ? void 0 : platform3.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform3.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow2() {
  return typeof window !== "undefined";
}
function getNodeName2(node) {
  if (isNode2(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow2(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement2(node) {
  var _ref;
  return (_ref = (isNode2(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode2(value) {
  if (!hasWindow2()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow2(value).Node;
}
function isElement2(value) {
  if (!hasWindow2()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow2(value).Element;
}
function isHTMLElement2(value) {
  if (!hasWindow2()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow2(value).HTMLElement;
}
function isShadowRoot2(value) {
  if (!hasWindow2() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow2(value).ShadowRoot;
}
var invalidOverflowDisplayValues2 = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement2(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle3(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues2.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName2(element));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement2(elementOrCss) ? getComputedStyle3(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode2(element);
  while (isHTMLElement2(currentNode) && !isLastTraversableNode2(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode2(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames2 = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode2(node) {
  return lastTraversableNodeNames2.has(getNodeName2(node));
}
function getComputedStyle3(element) {
  return getWindow2(element).getComputedStyle(element);
}
function getNodeScroll2(element) {
  if (isElement2(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode2(node) {
  if (getNodeName2(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot2(node) && node.host || // Fallback.
    getDocumentElement2(node)
  );
  return isShadowRoot2(result) ? result.host : result;
}
function getNearestOverflowAncestor2(node) {
  const parentNode = getParentNode2(node);
  if (isLastTraversableNode2(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement2(parentNode) && isOverflowElement2(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor2(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor2(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow2(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement2(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle3(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement2(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement2(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement2(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow2(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow2(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect2(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement2(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow2(domElement);
    const offsetWin = offsetParent && isElement2(offsetParent) ? getWindow2(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle3(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow2(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll2(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect2(getDocumentElement2(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement2(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll2(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      const offsetRect = getBoundingClientRect2(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement2(element);
  const scroll = getNodeScroll2(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle3(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow2(element);
  const html = getDocumentElement2(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect2(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement2(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement2(element));
  } else if (isElement2(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode2(element);
  if (parentNode === stopNode || !isElement2(parentNode) || isLastTraversableNode2(parentNode)) {
    return false;
  }
  return getComputedStyle3(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement2(el) && getNodeName2(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle3(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode2(element) : element;
  while (isElement2(currentNode) && !isLastTraversableNode2(currentNode)) {
    const computedStyle = getComputedStyle3(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement2(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode2(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement2(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect2(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll2(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect2(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle3(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement2(element) || getComputedStyle3(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement2(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow2(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement2(element)) {
    let svgOffsetParent = getParentNode2(element);
    while (svgOffsetParent && !isLastTraversableNode2(svgOffsetParent)) {
      if (isElement2(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode2(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode2(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle3(element).direction === "rtl";
}
var platform2 = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement: getDocumentElement2,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: isElement2,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement2(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect2(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect2(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var autoPlacement2 = autoPlacement;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform: platform2,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@vkontakte/vkui-floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React52 = __toESM(require_react(), 1);
var import_react8 = __toESM(require_react(), 1);
var ReactDOM2 = __toESM(require_react_dom(), 1);
var isClient = typeof document !== "undefined";
var noop2 = function noop3() {
};
var index = isClient ? import_react8.useLayoutEffect : noop2;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if ((typeof a === "undefined" ? "undefined" : _type_of(a)) !== (typeof b === "undefined" ? "undefined" : _type_of(b))) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  var length;
  var i;
  var keys;
  if (a && b && (typeof a === "undefined" ? "undefined" : _type_of(a)) === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      var key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  var win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  var dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  var ref = React52.useRef(value);
  index(function() {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  var _options_placement = options.placement, placement = _options_placement === void 0 ? "bottom" : _options_placement, _options_strategy = options.strategy, strategy = _options_strategy === void 0 ? "absolute" : _options_strategy, _options_middleware = options.middleware, middleware = _options_middleware === void 0 ? [] : _options_middleware, platform3 = options.platform, tmp = options.elements, _ref = tmp === void 0 ? {} : tmp, externalReference = _ref.reference, externalFloating = _ref.floating, _options_transform = options.transform, transform = _options_transform === void 0 ? true : _options_transform, whileElementsMounted2 = options.whileElementsMounted, open = options.open;
  var _React_useState = _sliced_to_array(React52.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  }), 2), data = _React_useState[0], setData = _React_useState[1];
  var _React_useState1 = _sliced_to_array(React52.useState(middleware), 2), latestMiddleware = _React_useState1[0], setLatestMiddleware = _React_useState1[1];
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  var _React_useState2 = _sliced_to_array(React52.useState(null), 2), _reference = _React_useState2[0], _setReference = _React_useState2[1];
  var _React_useState3 = _sliced_to_array(React52.useState(null), 2), _floating = _React_useState3[0], _setFloating = _React_useState3[1];
  var setReference = React52.useCallback(function(node) {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  var setFloating = React52.useCallback(function(node) {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  var referenceEl = externalReference || _reference;
  var floatingEl = externalFloating || _floating;
  var referenceRef = React52.useRef(null);
  var floatingRef = React52.useRef(null);
  var dataRef = React52.useRef(data);
  var hasWhileElementsMounted = whileElementsMounted2 != null;
  var whileElementsMountedRef = useLatestRef(whileElementsMounted2);
  var platformRef = useLatestRef(platform3);
  var openRef = useLatestRef(open);
  var update = React52.useCallback(function() {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    var config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then(function(data2) {
      var fullData = _object_spread_props(_object_spread({}, data2), {
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      });
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM2.flushSync(function() {
          setData(fullData);
        });
      }
    });
  }, [
    latestMiddleware,
    placement,
    strategy,
    platformRef,
    openRef
  ]);
  index(function() {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData(function(data2) {
        return _object_spread_props(_object_spread({}, data2), {
          isPositioned: false
        });
      });
    }
  }, [
    open
  ]);
  var isMountedRef = React52.useRef(false);
  index(function() {
    isMountedRef.current = true;
    return function() {
      isMountedRef.current = false;
    };
  }, []);
  index(function() {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [
    referenceEl,
    floatingEl,
    update,
    whileElementsMountedRef,
    hasWhileElementsMounted
  ]);
  var refs = React52.useMemo(function() {
    return {
      reference: referenceRef,
      floating: floatingRef,
      setReference,
      setFloating
    };
  }, [
    setReference,
    setFloating
  ]);
  var elements = React52.useMemo(function() {
    return {
      reference: referenceEl,
      floating: floatingEl
    };
  }, [
    referenceEl,
    floatingEl
  ]);
  var floatingStyles = React52.useMemo(function() {
    var initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    var x = roundByDPR(elements.floating, data.x);
    var y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return _object_spread(_object_spread_props(_object_spread({}, initialStyles), {
        transform: "translate(" + x + "px, " + y + "px)"
      }), getDPR(elements.floating) >= 1.5 && {
        willChange: "transform"
      });
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [
    strategy,
    transform,
    elements.floating,
    data.x,
    data.y
  ]);
  return React52.useMemo(function() {
    return _object_spread_props(_object_spread({}, data), {
      update,
      refs,
      elements,
      floatingStyles
    });
  }, [
    data,
    update,
    refs,
    elements,
    floatingStyles
  ]);
}
var arrow$1 = function arrow$12(options) {
  var isRef = function isRef2(value) {
    return {}.hasOwnProperty.call(value, "current");
  };
  return {
    name: "arrow",
    options,
    fn: function fn(state) {
      var _ref = typeof options === "function" ? options(state) : options, element = _ref.element, padding = _ref.padding;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = function offset4(options, deps) {
  return _object_spread_props(_object_spread({}, offset2(options)), {
    options: [
      options,
      deps
    ]
  });
};
var shift3 = function shift4(options, deps) {
  return _object_spread_props(_object_spread({}, shift2(options)), {
    options: [
      options,
      deps
    ]
  });
};
var flip3 = function flip4(options, deps) {
  return _object_spread_props(_object_spread({}, flip2(options)), {
    options: [
      options,
      deps
    ]
  });
};
var size3 = function size4(options, deps) {
  return _object_spread_props(_object_spread({}, size2(options)), {
    options: [
      options,
      deps
    ]
  });
};
var autoPlacement3 = function autoPlacement4(options, deps) {
  return _object_spread_props(_object_spread({}, autoPlacement2(options)), {
    options: [
      options,
      deps
    ]
  });
};
var hide3 = function hide4(options, deps) {
  return _object_spread_props(_object_spread({}, hide2(options)), {
    options: [
      options,
      deps
    ]
  });
};
var arrow3 = function arrow4(options, deps) {
  return _object_spread_props(_object_spread({}, arrow$1(options)), {
    options: [
      options,
      deps
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/lib/floating/adapters.js
var defaultOptions = {
  ancestorScroll: true,
  ancestorResize: true,
  // По умолчанию отключаем, т.к. навешивать `CustomResizeObserver` может быть дорого.
  // В `autoUpdateLib` по умолчанию опция включена. Там используется ResizeObserver, но и он не менее дорогостоящий.
  // https://github.com/floating-ui/floating-ui/blob/0a34fe9cc2c7483976785a71bd0777cd7c3f2a6a/packages/dom/src/autoUpdate.ts#L6-L33
  elementResize: false,
  animationFrame: false
};
function autoUpdateFloatingElement(reference, floating, update, options = defaultOptions) {
  const { elementResize = false } = options, restOptions = _object_without_properties(options, [
    "elementResize"
  ]);
  const canUseResizeObserver = window.ResizeObserver !== void 0;
  const autoUpdateLibDisposer = autoUpdate(reference, floating, update, _object_spread_props(_object_spread({}, restOptions), {
    elementResize: elementResize && canUseResizeObserver
  }));
  let observer = null;
  if (elementResize && !canUseResizeObserver) {
    observer = new CustomResizeObserver(update);
    if (isHTMLElement(reference)) {
      observer.observe(reference);
    }
    observer.observe(floating);
    observer.appendToTheDOM();
  }
  return () => {
    if (observer) {
      observer.disconnect();
      observer = null;
    }
    autoUpdateLibDisposer();
  };
}

// node_modules/@vkontakte/vkui/dist/lib/floating/useFloatingMiddlewaresBootstrap/index.js
var React53 = __toESM(require_react(), 1);
var useFloatingMiddlewaresBootstrap = ({ placement = "bottom-start", arrowRef = null, arrow: arrow5, arrowHeight, arrowPadding, sameWidth, offsetByMainAxis = 0, offsetByCrossAxis = 0, customMiddlewares, hideWhenReferenceHidden, disableFlipMiddleware = false, disableShiftMiddleware = false, flipMiddlewareFallbackAxisSideDirection = "end", overflowPadding }) => {
  return React53.useMemo(() => {
    const isAutoPlacement = !checkIsNotAutoPlacement(placement);
    const middlewares = [
      offset3({
        crossAxis: offsetByCrossAxis,
        mainAxis: arrow5 && arrowHeight ? offsetByMainAxis + arrowHeight : offsetByMainAxis
      })
    ];
    const shift5 = disableShiftMiddleware ? null : shift3({
      padding: overflowPadding
    });
    if (isAutoPlacement) {
      middlewares.push(autoPlacement3({
        alignment: getAutoPlacementAlign(placement)
      }));
      if (shift5) {
        middlewares.push(shift5);
      }
    } else if (!disableFlipMiddleware) {
      const flip5 = flip3({
        crossAxis: "alignment",
        fallbackAxisSideDirection: flipMiddlewareFallbackAxisSideDirection
      });
      if (placement.includes("-")) {
        middlewares.push(flip5);
        if (shift5) {
          middlewares.push(shift5);
        }
      } else {
        if (shift5) {
          middlewares.push(shift5);
        }
        middlewares.push(flip5);
      }
    } else if (shift5) {
      middlewares.push(shift5);
    }
    if (sameWidth) {
      middlewares.push(size3({
        apply({ rects, elements }) {
          Object.assign(elements.floating.style, {
            width: `${rects.reference.width}px`
          });
        }
      }));
    }
    if (customMiddlewares) {
      middlewares.push(...customMiddlewares);
    }
    if (arrow5) {
      middlewares.push(arrow3({
        element: arrowRef,
        padding: arrowPadding
      }));
    }
    if (hideWhenReferenceHidden) {
      middlewares.push(hide3());
    }
    return {
      middlewares,
      strictPlacement: isAutoPlacement ? void 0 : placement
    };
  }, [
    placement,
    offsetByCrossAxis,
    arrow5,
    arrowHeight,
    offsetByMainAxis,
    disableFlipMiddleware,
    disableShiftMiddleware,
    flipMiddlewareFallbackAxisSideDirection,
    sameWidth,
    customMiddlewares,
    hideWhenReferenceHidden,
    arrowRef,
    arrowPadding,
    overflowPadding
  ]);
};

// node_modules/@vkontakte/vkui/dist/lib/floating/useFloatingWithInteractions/useFloatingWithInteractions.js
var React55 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useEnsuredControl.js
var React54 = __toESM(require_react(), 1);
function useEnsuredControl(_param) {
  var { onChange: onChangeProp, disabled } = _param, props = _object_without_properties(_param, [
    "onChange",
    "disabled"
  ]);
  const [value, onChangeValue] = useCustomEnsuredControl(props);
  const onChange = React54.useCallback((e) => {
    if (disabled) {
      return;
    }
    onChangeValue(e.target.value);
    onChangeProp && onChangeProp(e);
  }, [
    onChangeValue,
    onChangeProp,
    disabled
  ]);
  return [
    value,
    onChange
  ];
}
var warn4 = warnOnce("useCustomEnsuredControl");
function useCustomEnsuredControl({ value, defaultValue, disabled, onChange: onChangeProp }) {
  const isControlled = value !== void 0;
  const [localValue, setLocalValue] = React54.useState(defaultValue);
  const preservedControlledValueRef = React54.useRef(void 0);
  useIsomorphicLayoutEffect(() => {
    preservedControlledValueRef.current = value;
  });
  const currentFallbackValueRef = React54.useRef(value);
  currentFallbackValueRef.current = value;
  const onChange = React54.useCallback((nextValue) => {
    if (disabled) {
      return;
    }
    if (isFunction(nextValue)) {
      if (!isControlled) {
        setLocalValue((prevValue) => {
          const resolvedValue = nextValue(prevValue);
          if (onChangeProp) {
            onChangeProp(resolvedValue);
          }
          return resolvedValue;
        });
      } else if (onChangeProp) {
        if (true) {
          if (preservedControlledValueRef.current === void 0) {
            warn4(`Похоже, что при вызове onChange с аргументом nextValue в виде коллбэка, состояние компонента было переведено из неконтролируемого ("undefined") в контролируемое. Пожалуйста, старайтесь сохранять либо неконтролируемое состояние, либо контролируемое на всём промежутке жизненного цикла компонента, чтобы получать предсказуемое значение prevValue в коллбэке nextValue((prevValue: V) => V)`, "error");
          }
        }
        const prevValue = preservedControlledValueRef.current === void 0 ? currentFallbackValueRef.current : preservedControlledValueRef.current;
        if (prevValue !== void 0) {
          const resolvedValue = nextValue(prevValue);
          onChangeProp(resolvedValue);
        }
      }
    } else {
      if (onChangeProp) {
        onChangeProp(nextValue);
      }
      if (!isControlled) {
        setLocalValue(nextValue);
      }
    }
  }, [
    disabled,
    isControlled,
    onChangeProp
  ]);
  return [
    isControlled ? value : localValue,
    onChange
  ];
}

// node_modules/@vkontakte/vkui/dist/hooks/useGlobalOnClickOutside.js
var useGlobalOnEventOutside = (event, callback, ...refs) => {
  const { document: document2 } = useDOM();
  useIsomorphicLayoutEffect(() => {
    const someRefNotNull = refs.some((ref) => ref && ref.current !== null);
    if (!document2 || !someRefNotNull) {
      return;
    }
    const handleClick = (event2) => {
      const targetEl = event2.target;
      const someRefHasTargetEl = isElement(targetEl) && refs.some((ref) => ref && ref.current && ref.current.contains(targetEl));
      if (!someRefHasTargetEl) {
        callback(event2);
      }
    };
    document2.addEventListener(event, handleClick, {
      passive: true,
      capture: true
    });
    return () => {
      document2.removeEventListener(event, handleClick, true);
    };
  }, [
    document2,
    callback,
    ...refs
  ]);
};
var useGlobalOnClickOutside = (callback, ...refs) => {
  useGlobalOnEventOutside("click", callback, ...refs);
};

// node_modules/@vkontakte/vkui/dist/lib/floating/useFloatingWithInteractions/constants.js
var DEFAULT_TRIGGER = "click";

// node_modules/@vkontakte/vkui/dist/lib/floating/useFloatingWithInteractions/useResolveTriggerType.js
var useResolveTriggerType = (triggerProp) => (typeof triggerProp === "string" ? [
  triggerProp
] : triggerProp).reduce((result, trigger) => {
  switch (trigger) {
    case "click":
      result.triggerOnClick = true;
      return result;
    case "hover":
      result.triggerOnHover = true;
      return result;
    case "focus":
      result.triggerOnFocus = true;
      return result;
    case "manual":
      return result;
  }
}, {
  triggerOnFocus: false,
  triggerOnClick: false,
  triggerOnHover: false
});

// node_modules/@vkontakte/vkui/dist/lib/floating/useFloatingWithInteractions/useFloatingWithInteractions.js
var whileElementsMounted = (...args) => (
  /* istanbul ignore next: не знаю как проверить */
  autoUpdateFloatingElement(...args, {
    elementResize: true
  })
);
var useFloatingWithInteractions = ({
  trigger = DEFAULT_TRIGGER,
  // UseFloating
  placement: placementProp = "bottom",
  strategy: strategyProp = "fixed",
  middlewares,
  hoverDelay = 0,
  closeAfterClick = false,
  // disables
  disabled = false,
  disableInteractive = false,
  disableCloseOnClickOutside = false,
  disableCloseOnEscKey = false,
  // uncontrolled
  defaultShown = false,
  // controlled
  shown: shownProp,
  onShownChange: onShownChangeProp,
  onShownChanged: onShownChangedProp
}) => {
  const memoizedValue = React55.useMemo(() => shownProp !== void 0 ? {
    shown: shownProp
  } : void 0, [
    shownProp
  ]);
  const [shownLocalState, setShownLocalState] = useCustomEnsuredControl({
    value: memoizedValue,
    disabled,
    defaultValue: {
      shown: defaultShown
    },
    onChange: useStableCallback(({ shown, reason }) => {
      if (onShownChangeProp) {
        onShownChangeProp(shown, reason);
      }
    })
  });
  const onShownChanged = useStableCallback(onShownChangedProp ? onShownChangedProp : noop);
  const [shownFinalState, setShownFinalState] = React55.useState(() => shownLocalState.shown);
  const [willBeHide, setWillBeHide] = React55.useState(false);
  const hasCSSAnimation = React55.useRef(false);
  const blockMouseEnterRef = React55.useRef(false);
  const blockFocusRef = React55.useRef(false);
  const blurTimeoutRef = React55.useRef(void 0);
  const handleCloseOnReferenceClickOutsideDisabled = disabled || disableCloseOnClickOutside || willBeHide || !shownLocalState.shown;
  const handleCloseOnFloatingClickOutsideDisabled = disableInteractive || handleCloseOnReferenceClickOutsideDisabled;
  const { triggerOnFocus, triggerOnClick, triggerOnHover } = useResolveTriggerType(trigger);
  const { placement, x, y, strategy, refs, middlewareData } = useFloating({
    strategy: strategyProp,
    placement: placementProp,
    middleware: middlewares,
    whileElementsMounted
  });
  const commitShownLocalState = React55.useCallback((nextShown, reason) => {
    setShownLocalState((prevState) => {
      if (prevState.shown !== nextShown || prevState.reason !== reason) {
        return {
          shown: nextShown,
          reason
        };
      }
      return prevState;
    });
  }, [
    setShownLocalState
  ]);
  const [mouseEnterDelay, mouseLeaveDelay] = typeof hoverDelay === "number" ? [
    hoverDelay,
    hoverDelay
  ] : hoverDelay;
  const showWithDelay = React55.useMemo(() => debounce(() => commitShownLocalState(true, "hover"), mouseEnterDelay), [
    mouseEnterDelay,
    commitShownLocalState
  ]);
  const hideWithDelay = React55.useMemo(() => debounce(() => commitShownLocalState(false, "hover"), mouseLeaveDelay), [
    mouseLeaveDelay,
    commitShownLocalState
  ]);
  const handleFocusOnReference = useStableCallback(() => {
    if (shownLocalState.shown) {
      if (!closeAfterClick && shownLocalState.reason === "hover") {
        return;
      }
      commitShownLocalState(false, "focus");
      return;
    }
    if (blockFocusRef.current) {
      blockFocusRef.current = false;
      return;
    }
    commitShownLocalState(true, "focus");
  });
  const handleBlurOnReference = useStableCallback((event) => {
    blockFocusRef.current = false;
    blockMouseEnterRef.current = false;
    if (!shownLocalState.shown) {
      clearTimeout(blurTimeoutRef.current);
      return;
    }
    const relatedTarget = event.relatedTarget;
    blurTimeoutRef.current = setTimeout(function waitWindowBlurFire() {
      const reference = refs.reference.current;
      if (!relatedTarget && getActiveElementByAnotherElement(reference) === reference) {
        return;
      }
      if (contains(refs.floating.current, relatedTarget) || contains(reference, relatedTarget)) {
        return;
      }
      commitShownLocalState(false, "focus");
    });
  });
  const handleClickOnReference = useStableCallback(() => {
    if (shownLocalState.reason === "focus") {
      commitShownLocalState(shownLocalState.shown, "click");
      return;
    }
    commitShownLocalState(!shownLocalState.shown, "click");
  });
  const handleClickOnReferenceForOnlyClose = useStableCallback(() => {
    blockMouseEnterRef.current = true;
    commitShownLocalState(false, "click");
  });
  const handleMouseEnterOnBoth = useStableCallback((event) => {
    if (willBeHide && event.currentTarget === refs.floating.current) {
      return;
    }
    showWithDelay.cancel();
    hideWithDelay.cancel();
    if (!blockMouseEnterRef.current && !shownLocalState.shown) {
      showWithDelay();
    }
  });
  const handleMouseLeaveOnBothForHoverAndFocusStates = useStableCallback((event) => {
    if (willBeHide && event.currentTarget === refs.floating.current) {
      return;
    }
    blockFocusRef.current = false;
    blockMouseEnterRef.current = false;
    if (triggerOnHover) {
      showWithDelay.cancel();
      hideWithDelay.cancel();
      hideWithDelay();
    }
  });
  const handleFloatingAnimationStart = () => {
    hasCSSAnimation.current = true;
  };
  const handleFloatingAnimationEnd = () => {
    if (willBeHide) {
      setShownFinalState(false);
      setWillBeHide(false);
      onShownChanged(false, shownLocalState.reason);
    }
  };
  const handleOnClose = React55.useCallback(() => {
    blockFocusRef.current = true;
    commitShownLocalState(false, "callback");
  }, [
    commitShownLocalState
  ]);
  const handleRestoreFocus = React55.useCallback((restoreFocus = true) => {
    if (!restoreFocus) {
      return false;
    }
    if (restoreFocus === true) {
      return triggerOnFocus ? blockFocusRef.current : true;
    } else if (restoreFocus === "anchor-element") {
      return refs.reference.current;
    } else if (restoreFocus instanceof HTMLElement) {
      return restoreFocus;
    }
    return false;
  }, [
    refs.reference,
    triggerOnFocus
  ]);
  const handleEscapeKeyDown = React55.useCallback(() => {
    blockFocusRef.current = true;
    commitShownLocalState(false, "escape-key");
  }, [
    commitShownLocalState
  ]);
  const handleClickOutside = React55.useCallback(() => {
    blockFocusRef.current = true;
    commitShownLocalState(false, "click-outside");
  }, [
    commitShownLocalState
  ]);
  useGlobalOnClickOutside(handleClickOutside, handleCloseOnReferenceClickOutsideDisabled ? null : refs.reference, handleCloseOnFloatingClickOutsideDisabled ? null : refs.floating);
  useIsomorphicLayoutEffect(
    /**
    * Если пользователь покинул активное окно и:
    * 1. целевой элемент был в состоянии фокуса;
    * 2. всплывающий элемент был закрытом состоянии;
    * то фокус должен быть заблокирован, когда пользователь вернётся обратно. Иначе покажется
    * всплывающий элемент.
    */
    function setGlobalBlurForTriggerOnFocus() {
      if (!triggerOnFocus || !refs.reference.current) {
        return;
      }
      const handleGlobalBlur = () => {
        const reference = refs.reference.current;
        if (!shownLocalState.shown && isHTMLElement(reference) && reference === getActiveElementByAnotherElement(reference)) {
          blockFocusRef.current = true;
        }
      };
      const win = getWindow(refs.reference.current);
      win.addEventListener("blur", handleGlobalBlur);
      return () => {
        win.removeEventListener("blur", handleGlobalBlur);
      };
    },
    [
      triggerOnFocus,
      refs.reference,
      shownLocalState
    ]
  );
  useIsomorphicLayoutEffect(function resolveShownStates() {
    if (willBeHide || shownLocalState.shown === shownFinalState) {
      return;
    }
    if (shownLocalState.shown) {
      setShownFinalState(true);
      onShownChanged(true, shownLocalState.reason);
    } else if (hasCSSAnimation.current && !willBeHide) {
      setWillBeHide(true);
    } else {
      setShownFinalState(false);
    }
    return () => {
      clearTimeout(blurTimeoutRef.current);
    };
  }, [
    shownLocalState,
    shownFinalState,
    willBeHide,
    onShownChanged
  ]);
  const referencePropsRef = React55.useRef({});
  const floatingPropsRef = React55.useRef({
    style: {}
  });
  useIsomorphicLayoutEffect(() => {
    referencePropsRef.current = {};
  }, [
    triggerOnHover,
    triggerOnFocus,
    triggerOnClick
  ]);
  if (shownFinalState) {
    floatingPropsRef.current.style = convertFloatingDataToReactCSSProperties({
      strategy,
      x,
      y,
      middlewareData
    });
    if (disableInteractive) {
      floatingPropsRef.current.style.pointerEvents = "none";
    }
  }
  if (triggerOnFocus) {
    referencePropsRef.current.onFocus = handleFocusOnReference;
    referencePropsRef.current.onBlur = handleBlurOnReference;
  }
  if (triggerOnClick) {
    referencePropsRef.current.onClick = handleClickOnReference;
  }
  if (triggerOnHover) {
    referencePropsRef.current.onMouseOver = handleMouseEnterOnBoth;
    if (closeAfterClick && !triggerOnClick) {
      referencePropsRef.current.onClick = handleClickOnReferenceForOnlyClose;
    }
    if (!disableInteractive) {
      floatingPropsRef.current.onMouseOver = handleMouseEnterOnBoth;
    }
  }
  if (triggerOnHover || triggerOnFocus) {
    referencePropsRef.current.onMouseLeave = handleMouseLeaveOnBothForHoverAndFocusStates;
    if (!disableInteractive) {
      floatingPropsRef.current.onMouseLeave = handleMouseLeaveOnBothForHoverAndFocusStates;
    }
  }
  if (shownFinalState) {
    floatingPropsRef.current.onAnimationStart = handleFloatingAnimationStart;
    floatingPropsRef.current.onAnimationEnd = handleFloatingAnimationEnd;
  }
  return {
    placement,
    shown: shownFinalState,
    willBeHide,
    refs,
    referenceProps: referencePropsRef.current,
    floatingProps: floatingPropsRef.current,
    middlewareData,
    onClose: handleOnClose,
    // FocusTrap уже определяет нажатие на ESC, поэтому название события содержит конкретный код
    // кнопки вместо просто onKeyDown.
    onEscapeKeyDown: !shownFinalState || disableCloseOnEscKey ? void 0 : handleEscapeKeyDown,
    // [Обход баги с FocusTrap]
    //
    // Если сфокусироваться на целевой элемент через нажатие, а потом нажать в область за пределами
    // целевого и всплывающего элемента, то появляется моргание из-за того, что FocusTrap
    // восстанавливает фокус, из-за чего всплывающий элемент снова показывается за счёт
    // `handleFocusOnReference`, а потом скрывается за счёт `handleBlurOnReference`.
    onRestoreFocus: handleRestoreFocus
  };
};

// node_modules/@vkontakte/vkui/dist/lib/floating/usePlacementChangeCallback.js
var React56 = __toESM(require_react(), 1);
function usePlacementChangeCallback(initialPlacement, resolvedPlacement, onPlacementChange) {
  const prevPlacementRef = React56.useRef(void 0);
  React56.useEffect(() => {
    prevPlacementRef.current = resolvedPlacement;
  });
  useIsomorphicLayoutEffect(() => {
    if (!onPlacementChange) {
      return;
    }
    const prevPlacement = prevPlacementRef.current;
    const isInitialPlacementChanged = prevPlacement === void 0 && initialPlacement !== resolvedPlacement;
    const isResolvedPlacementChanged = prevPlacement !== void 0 && prevPlacement !== resolvedPlacement;
    if (isInitialPlacementChanged || isResolvedPlacementChanged) {
      onPlacementChange(resolvedPlacement);
    }
  }, [
    initialPlacement,
    resolvedPlacement,
    onPlacementChange
  ]);
}

// node_modules/@vkontakte/vkui/dist/components/View/utils.js
var swipeBackExcludedSelector = "input, textarea, [data-vkui-swipe-back=false]";
function swipeBackExcluded(e) {
  var _target_closest;
  const target = e.originalEvent.target;
  return Boolean(target === null || target === void 0 ? void 0 : (_target_closest = target.closest) === null || _target_closest === void 0 ? void 0 : _target_closest.call(target, swipeBackExcludedSelector));
}
function hasHorizontalScrollableElementWithScrolledToLeft(node) {
  return getOverflowAncestors(node).some((node2) => "scrollLeft" in node2 ? node2.scrollLeft > 0 : false);
}
var SWIPE_BACK_EDGE_SIZE_THRESHOLD = 20;
var SWIPE_BACK_SHIFT_THRESHOLD = 10;
var getSwipeBackPredicates = (startX, shiftX, innerWidth) => {
  const swipedToOpposite = shiftX < 0;
  const swipeBackTriggered = shiftX >= SWIPE_BACK_SHIFT_THRESHOLD;
  const viewportStartEdgeTouched = startX <= SWIPE_BACK_EDGE_SIZE_THRESHOLD;
  const viewportEndEdgeTouched = startX >= innerWidth - SWIPE_BACK_EDGE_SIZE_THRESHOLD;
  return {
    swipedToOpposite,
    swipeBackTriggered,
    viewportStartEdgeTouched,
    viewportEndEdgeTouched
  };
};

// node_modules/@vkontakte/vkui/dist/components/View/View.js
var scrollsCache = {};
var warn5 = warnOnce("View");
var View = (_param) => {
  var { activePanel: activePanelProp, history, nav, onTransition, onSwipeBack, onSwipeBackStart, onSwipeBackCancel: onSwipeBackCancelProp, children, className } = _param, restProps = _object_without_properties(_param, [
    "activePanel",
    "history",
    "nav",
    "onTransition",
    "onSwipeBack",
    "onSwipeBackStart",
    "onSwipeBackCancel",
    "children",
    "className"
  ]);
  const id = getNavId({
    nav,
    id: restProps.id
  });
  const scrolls = React57.useRef(scrollsCache[id] || {});
  const layoutEffectCall = useLayoutEffectCall();
  React57.useEffect(() => () => {
    if (id) {
      scrollsCache[id] = scrolls.current;
    }
  });
  const panelNodes = React57.useRef({});
  const { window: window2, document: document2 } = useDOM();
  const scroll = useScroll();
  const configProvider = useConfigProvider();
  const splitCol = useSplitCol();
  const platform3 = usePlatform();
  const [animated, setAnimated] = React57.useState(false);
  const [visiblePanels, setVisiblePanels] = React57.useState([
    activePanelProp
  ]);
  const [activePanel, setActivePanel] = React57.useState(activePanelProp);
  const [isBack, setIsBack] = React57.useState(void 0);
  const [prevPanel, setPrevPanel] = React57.useState(null);
  const [nextPanel, setNextPanel] = React57.useState(null);
  const swipeBackPrevented = React57.useRef(false);
  const [swipingBack, setSwipingBack] = React57.useState(void 0);
  const [swipeBackStartX, setSwipeBackStartX] = React57.useState(0);
  const [swipeBackShift, setSwipeBackShift] = React57.useState(0);
  const [swipeBackNextPanel, setSwipeBackNextPanel] = React57.useState(null);
  const [swipeBackPrevPanel, setSwipeBackPrevPanel] = React57.useState(null);
  const [swipeBackResult, setSwipeBackResult] = React57.useState(null);
  const [browserSwipe, setBrowserSwipe] = React57.useState(false);
  const prevActivePanel = usePrevious(activePanelProp);
  const prevSwipingBack = usePrevious(swipingBack);
  const prevBrowserSwipe = usePrevious(browserSwipe);
  const prevSwipeBackResult = usePrevious(swipeBackResult);
  const prevSwipeBackShift = usePrevious(swipeBackShift);
  const prevSwipeBackPrevPanel = usePrevious(swipeBackPrevPanel);
  const prevOnTransition = usePrevious(onTransition);
  const panels = React57.Children.toArray(children).filter((panel) => {
    const panelId = getNavId(panel.props, warn5);
    return panelId !== void 0 && visiblePanels.includes(panelId) || panelId === swipeBackPrevPanel || panelId === swipeBackNextPanel;
  });
  const disableAnimation = !configProvider.transitionMotionEnabled || !splitCol.animate || platform3 === "vkcom";
  const iOSSwipeBackSimulationEnabled = !disableAnimation && platform3 === "ios" && configProvider.isWebView && Boolean(onSwipeBack);
  const flushTransition = React57.useCallback((prevPanel2, isBackTransition) => {
    if (isBackTransition) {
      scrolls.current[prevPanel2] = 0;
    }
    setPrevPanel(null);
    setNextPanel(null);
    setVisiblePanels([
      activePanelProp
    ]);
    setActivePanel(activePanelProp);
    setAnimated(false);
    setIsBack(isBackTransition);
    layoutEffectCall(() => {
      scroll === null || scroll === void 0 ? void 0 : scroll.scrollTo(0, isBackTransition ? scrolls.current[activePanelProp] : 0);
      onTransition && onTransition({
        isBack: isBackTransition,
        from: prevPanel2,
        to: activePanelProp
      });
    });
  }, [
    activePanelProp,
    layoutEffectCall,
    onTransition,
    scroll
  ]);
  const handleAnimatedTargetAnimationEnd = () => {
    if (prevPanel !== null) {
      flushTransition(prevPanel, Boolean(isBack));
    }
  };
  const onSwipeBackSuccess = React57.useCallback(() => {
    onSwipeBack && onSwipeBack();
  }, [
    onSwipeBack
  ]);
  const onSwipeBackCancel = React57.useCallback(() => {
    onSwipeBackCancelProp && onSwipeBackCancelProp();
    setSwipeBackPrevPanel(null);
    setSwipeBackNextPanel(null);
    setSwipingBack(false);
    setSwipeBackResult(null);
    setSwipeBackStartX(0);
    setSwipeBackShift(0);
  }, [
    onSwipeBackCancelProp
  ]);
  const swipingBackTransitionEndHandler = React57.useCallback(() => {
    switch (swipeBackResult) {
      case "fail":
        onSwipeBackCancel();
        break;
      case "success":
        onSwipeBackSuccess();
    }
  }, [
    onSwipeBackCancel,
    onSwipeBackSuccess,
    swipeBackResult
  ]);
  const handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext = (event) => {
    if (browserSwipe) {
      return;
    }
    const { swipeBackTriggered, viewportStartEdgeTouched, viewportEndEdgeTouched } = getSwipeBackPredicates(event.startX, event.shiftX, window2.innerWidth);
    if ((viewportStartEdgeTouched || viewportEndEdgeTouched) && swipeBackTriggered) {
      setBrowserSwipe(true);
    }
  };
  const handleTouchMoveXForIOSSwipeBackSimulation = (event) => {
    if (swipeBackPrevented.current || swipeBackExcluded(event)) {
      return;
    }
    const { swipedToOpposite, swipeBackTriggered, viewportStartEdgeTouched } = getSwipeBackPredicates(event.startX, event.shiftX, window2.innerWidth);
    if (animated && swipeBackTriggered) {
      return;
    }
    if (!swipingBack && history && history.length > 1) {
      if (swipedToOpposite) {
        swipeBackPrevented.current = true;
        return;
      }
      if (!swipeBackTriggered) {
        return;
      }
      if (!viewportStartEdgeTouched && hasHorizontalScrollableElementWithScrolledToLeft(event.originalEvent.target)) {
        swipeBackPrevented.current = true;
        return;
      }
      if (onSwipeBackStart) {
        const payload = onSwipeBackStart(activePanel);
        if (payload === "prevent") {
          swipeBackPrevented.current = true;
          return;
        }
      }
      if (activePanel !== null) {
        blurActiveElement(document2);
        scrolls.current[activePanel] = scroll === null || scroll === void 0 ? void 0 : scroll.getScroll().y;
      }
      setSwipingBack(true);
      setSwipeBackStartX(event.startX);
      setSwipeBackPrevPanel(activePanel);
      setSwipeBackNextPanel(history.slice(-2)[0]);
    }
    if (swipingBack) {
      if (event.shiftX < 0) {
        setSwipeBackShift(0);
      } else if (event.shiftX > window2.innerWidth - swipeBackStartX) {
        setSwipeBackShift(window2.innerWidth);
      } else {
        setSwipeBackShift(event.shiftX);
      }
    }
  };
  const handleTouchEndForIOSSwipeBackSimulation = (event) => {
    swipeBackPrevented.current = false;
    if (swipingBack) {
      const speed = swipeBackShift / event.duration * millisecondsInSecond;
      var _window_innerWidth;
      if (swipeBackShift === 0) {
        onSwipeBackCancel();
      } else if (swipeBackShift >= ((_window_innerWidth = window2.innerWidth) !== null && _window_innerWidth !== void 0 ? _window_innerWidth : 0)) {
        onSwipeBackSuccess();
      } else if (speed > 250 || swipeBackShift >= window2.innerWidth / 2) {
        setSwipeBackResult("success");
      } else {
        setSwipeBackResult("fail");
      }
    }
  };
  const calcPanelSwipeStyles = (isPrev, isNext) => {
    if (!isPrev && !isNext || swipeBackResult) {
      return {};
    }
    if (isNext) {
      return window2 ? {
        transform: `translate3d(${-50 + swipeBackShift * 100 / window2.innerWidth / 2}%, 0, 0)`
      } : {};
    }
    if (isPrev) {
      return {
        transform: `translate3d(${swipeBackShift}px, 0, 0)`
      };
    }
    return {};
  };
  const calcPanelSwipeBackOverlayStyles = (isNext) => {
    if (!window2 || !isNext) {
      return {};
    }
    const opacityOnSwipeEnd = swipeBackResult === "success" ? 0 : swipeBackResult === "fail" ? 1 : null;
    return {
      display: "block",
      opacity: opacityOnSwipeEnd === null ? 1 - swipeBackShift / window2.innerWidth : opacityOnSwipeEnd
    };
  };
  const handleSwipeBackTargetTransitionEnd = (event) => {
    if (event.propertyName.includes("transform")) {
      swipingBackTransitionEndHandler();
    }
  };
  React57.useEffect(() => {
    if (prevActivePanel && prevActivePanel !== activePanelProp && !prevSwipingBack && !prevBrowserSwipe) {
      const firstLayerId = React57.Children.toArray(children).map((panel) => getNavId(panel.props, warn5)).find((id2) => id2 === prevActivePanel || id2 === activePanelProp);
      const isBackTransition = firstLayerId === activePanelProp;
      scrolls.current[prevActivePanel] = scroll === null || scroll === void 0 ? void 0 : scroll.getScroll({
        compensateKeyboardHeight: false
      }).y;
      if (disableAnimation) {
        flushTransition(prevActivePanel, isBackTransition);
      } else {
        blurActiveElement(document2);
        setVisiblePanels([
          prevActivePanel,
          activePanelProp
        ]);
        setPrevPanel(prevActivePanel);
        setNextPanel(activePanelProp);
        setActivePanel(null);
        setAnimated(true);
        setIsBack(isBackTransition);
      }
    }
    if (prevActivePanel && prevActivePanel !== activePanelProp && prevSwipingBack) {
      const nextPanel2 = activePanelProp;
      const prevPanel2 = prevActivePanel;
      if (prevSwipeBackPrevPanel) {
        scrolls.current[prevSwipeBackPrevPanel] = 0;
      }
      setSwipeBackPrevPanel(null);
      setSwipeBackNextPanel(null);
      setSwipingBack(false);
      setSwipeBackResult(null);
      setSwipeBackStartX(0);
      setSwipeBackShift(0);
      setActivePanel(nextPanel2);
      setVisiblePanels([
        nextPanel2
      ]);
      setIsBack(true);
      layoutEffectCall(() => {
        if (nextPanel2 !== null) {
          scroll === null || scroll === void 0 ? void 0 : scroll.scrollTo(0, scrolls.current[nextPanel2]);
        }
        prevOnTransition && prevOnTransition({
          isBack: true,
          from: prevPanel2,
          to: nextPanel2
        });
      });
    }
    if (prevActivePanel !== activePanelProp && browserSwipe) {
      setBrowserSwipe(false);
      setNextPanel(null);
      setPrevPanel(null);
      setAnimated(false);
      setVisiblePanels([
        activePanelProp
      ]);
      setActivePanel(activePanelProp);
    }
  }, [
    activePanelProp,
    activePanel,
    browserSwipe,
    children,
    disableAnimation,
    document2,
    flushTransition,
    prevActivePanel,
    prevBrowserSwipe,
    prevOnTransition,
    prevSwipeBackPrevPanel,
    prevSwipeBackResult,
    prevSwipingBack,
    scroll,
    swipeBackNextPanel,
    swipeBackResult,
    layoutEffectCall
  ]);
  React57.useEffect(function restoreScrollPositionWhenSwipeBackIsCancelled() {
    const swipeBackCancelledInTheMiddleOfAction = prevSwipeBackResult === "fail" && !swipeBackResult;
    const swipeBackCancelledByMovingPanelBackToInitialPoint = prevSwipingBack && !swipingBack && prevSwipeBackShift === 0;
    if ((swipeBackCancelledInTheMiddleOfAction || swipeBackCancelledByMovingPanelBackToInitialPoint) && activePanel !== null) {
      scroll === null || scroll === void 0 ? void 0 : scroll.scrollTo(0, scrolls.current[activePanel]);
    }
  }, [
    prevSwipeBackResult,
    swipeBackResult,
    prevSwipingBack,
    swipingBack,
    prevSwipeBackShift,
    activePanel,
    scroll
  ]);
  return (0, import_jsx_runtime42.jsx)(NavViewIdContext.Provider, {
    value: id,
    children: (0, import_jsx_runtime42.jsx)(Touch, _object_spread_props(_object_spread({
      Component: "section"
    }, restProps), {
      className: clsx("vkuiView__host", platform3 === "ios" && clsx("vkuiView__ios", "vkuiInternalView--ios"), !disableAnimation && animated && "vkuiView__animated", !disableAnimation && swipingBack && "vkuiView__swipingBack", disableAnimation && "vkuiView__noMotion", className),
      onMoveX: iOSSwipeBackSimulationEnabled ? handleTouchMoveXForIOSSwipeBackSimulation : platform3 === "ios" ? handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext : void 0,
      onEnd: iOSSwipeBackSimulationEnabled ? handleTouchEndForIOSSwipeBackSimulation : void 0,
      children: (0, import_jsx_runtime42.jsx)("div", {
        className: "vkuiView__panels",
        children: panels.map((panel) => {
          const panelId = getNavId(panel.props, warn5);
          const isPanelActive = panelId === activePanel;
          const isPanelPrev = panelId === prevPanel;
          const isPanelNext = panelId === nextPanel;
          const isAnimatedTarget = animated && (isBack ? isPanelPrev : isPanelNext);
          const isSwipeBackPrev = panelId === swipeBackPrevPanel;
          const isSwipeBackNext = panelId === swipeBackNextPanel;
          const isSwipeBackTarget = swipeBackResult && isSwipeBackPrev;
          let scrollCompensateStyle = void 0;
          if (isPanelPrev || isPanelNext && isBack || isSwipeBackPrev || isSwipeBackNext) {
            const marginTop = scrolls.current[panelId];
            if (marginTop !== void 0) {
              scrollCompensateStyle = {
                marginTop: -1 * marginTop
              };
            }
          }
          return (0, import_jsx_runtime42.jsxs)("div", {
            className: clsx("vkuiView__panel", isPanelActive && "vkuiView__panelActive", isPanelPrev && "vkuiView__panelPrev", isPanelNext && "vkuiView__panelNext", isSwipeBackPrev && "vkuiView__panelSwipeBackPrev", isSwipeBackNext && "vkuiView__panelSwipeBackNext", swipeBackResult === "success" && "vkuiView__panelSwipeBackSuccess", swipeBackResult === "fail" && "vkuiView__panelSwipeBackFailed"),
            onTransitionEnd: isSwipeBackTarget ? handleSwipeBackTargetTransitionEnd : void 0,
            onAnimationEnd: isAnimatedTarget ? handleAnimatedTargetAnimationEnd : void 0,
            ref: (el) => {
              panelId !== void 0 && (panelNodes.current[panelId] = el);
            },
            style: calcPanelSwipeStyles(isSwipeBackPrev, isSwipeBackNext),
            children: [
              platform3 === "ios" && (0, import_jsx_runtime42.jsx)("div", {
                className: "vkuiView__panelOverlay",
                style: calcPanelSwipeBackOverlayStyles(isSwipeBackNext)
              }),
              (0, import_jsx_runtime42.jsx)("div", {
                className: "vkuiView__panelIn",
                style: scrollCompensateStyle,
                children: (0, import_jsx_runtime42.jsx)(NavTransitionDirectionProvider, {
                  isBack: swipingBack || isBack,
                  children: (0, import_jsx_runtime42.jsx)(NavTransitionProvider, {
                    entering: panelId === nextPanel || panelId === swipeBackNextPanel,
                    children: panel
                  })
                })
              })
            ]
          }, panelId);
        })
      })
    }))
  });
};

// node_modules/@vkontakte/vkui/dist/components/Panel/Panel.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var React58 = __toESM(require_react(), 1);
var sizeXClassNames2 = {
  none: "vkuiPanel__sizeXNone",
  compact: "vkuiPanel__sizeXCompact",
  regular: "vkuiPanel__sizeXRegular"
};
var stylesMode3 = {
  none: "vkuiPanel__modeNone",
  plain: "vkuiPanel__modePlain",
  card: "vkuiPanel__modeCard"
};
var Panel = (_param) => {
  var { centered = false, children, nav, mode: modeProp, disableBackground } = _param, restProps = _object_without_properties(_param, [
    "centered",
    "children",
    "nav",
    "mode",
    "disableBackground"
  ]);
  const { sizeX = "none" } = useAdaptivity();
  const mode = usePanelMode(modeProp, sizeX);
  return (0, import_jsx_runtime43.jsx)(NavPanelIdContext.Provider, {
    value: restProps.id || nav,
    children: (0, import_jsx_runtime43.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
      baseClassName: clsx("vkuiPanel__host", sizeXClassNames2[sizeX], centered && "vkuiInternalPanel--centered", disableBackground && "vkuiPanel__disableBackground", stylesMode3[mode]),
      children: (0, import_jsx_runtime43.jsxs)(Touch, {
        Component: OnboardingTooltipContainer,
        className: clsx("vkuiPanel__in", "vkuiInternalPanel__in"),
        children: [
          (0, import_jsx_runtime43.jsx)("div", {
            className: "vkuiPanel__inBefore"
          }),
          centered ? (0, import_jsx_runtime43.jsx)("div", {
            className: "vkuiPanel__centered",
            children
          }) : children,
          (0, import_jsx_runtime43.jsx)("div", {
            className: "vkuiPanel__inAfter"
          })
        ]
      })
    }))
  });
};
function usePanelMode(modeProp, sizeX) {
  const { layout } = React58.useContext(AppRootContext);
  if (modeProp) {
    return modeProp;
  }
  if (layout) {
    return layout;
  }
  if (sizeX !== "none") {
    return sizeX === "regular" ? "card" : "plain";
  }
  return "none";
}

// node_modules/@vkontakte/vkui/dist/components/PanelHeaderButton/PanelHeaderButton.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
var React59 = __toESM(require_react(), 1);
var platformClassNames = {
  ios: "vkuiPanelHeaderButton__ios",
  android: "vkuiPanelHeaderButton__android",
  vkcom: "vkuiPanelHeaderButton__vkcom"
};
var defaultHoverMode = {
  ios: "background",
  android: "background",
  vkcom: "vkuiPanelHeaderButton__hover"
};
var defaultActiveMode = {
  ios: "opacity",
  android: "background",
  vkcom: "vkuiPanelHeaderButton__active"
};
var ButtonTypography = ({ primary, children }) => {
  const platform3 = usePlatform();
  if (platform3 === "ios") {
    return (0, import_jsx_runtime44.jsx)(Title, {
      Component: "span",
      level: "3",
      weight: primary ? "1" : "3",
      children
    });
  }
  return (0, import_jsx_runtime44.jsx)(Text, {
    weight: platform3 === "vkcom" ? void 0 : "2",
    children
  });
};
var warn6 = warnOnce("PanelHeaderButton");
var PanelHeaderButton = (_param) => {
  var { children, primary = false, label, activeEffectDelay = 200, hoverMode, activeMode } = _param, restProps = _object_without_properties(_param, [
    "children",
    "primary",
    "label",
    "activeEffectDelay",
    "hoverMode",
    "activeMode"
  ]);
  const isPrimitive = isPrimitiveReactNode(children);
  const isPrimitiveLabel = isPrimitiveReactNode(label);
  const platform3 = usePlatform();
  if (true) {
    const isAccessible = hasAccessibleName(_object_spread({
      children: [
        children,
        label
      ]
    }, restProps));
    if (!isAccessible) {
      warn6(COMMON_WARNINGS.a11y[restProps.href ? "link-name" : "button-name"], "error");
    }
  }
  const elements = [
    label,
    children
  ].filter((item) => !!item);
  const onlyPrimitive = elements.length === 1 && isPrimitiveReactNode(elements[0]);
  return (0, import_jsx_runtime44.jsxs)(Tappable, _object_spread_props(_object_spread({
    Component: restProps.href ? "a" : "button",
    activeEffectDelay,
    hoverMode: hoverMode ? hoverMode : defaultHoverMode[platform3],
    activeMode: activeMode ? activeMode : defaultActiveMode[platform3]
  }, restProps), {
    baseClassName: clsx("vkuiPanelHeaderButton__host", platformClassNames.hasOwnProperty(platform3) ? platformClassNames[platform3] : platformClassNames.android, onlyPrimitive && "vkuiPanelHeaderButton__primitive", !isPrimitive && !isPrimitiveLabel && "vkuiPanelHeaderButton__notPrimitive"),
    children: [
      isPrimitive ? (0, import_jsx_runtime44.jsx)(ButtonTypography, {
        primary,
        children
      }) : children,
      isPrimitiveLabel ? (0, import_jsx_runtime44.jsx)(ButtonTypography, {
        primary,
        className: "vkuiPanelHeaderButton__label",
        children: label
      }) : label
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeader/PanelHeader.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var React61 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/context/ModalContext.js
var import_react9 = __toESM(require_react(), 1);
var ModalContext = (0, import_react9.createContext)(null);
var useModalContext = () => {
  const id = (0, import_react9.useContext)(ModalContext);
  return id === null ? {
    id
  } : {
    id,
    labelId: `${id}-label`
  };
};

// node_modules/@vkontakte/vkui/dist/components/Separator/Separator.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);

// node_modules/@vkontakte/vkui/dist/lib/layouts/gaps.js
var columnGapClassNames = {
  "2xs": "vkuistyles__-column-gap--2xs",
  "xs": "vkuistyles__-column-gap--xs",
  "s": "vkuistyles__-column-gap--s",
  "m": "vkuistyles__-column-gap--m",
  "l": "vkuistyles__-column-gap--l",
  "xl": "vkuistyles__-column-gap--xl",
  "2xl": "vkuistyles__-column-gap--2xl",
  "3xl": "vkuistyles__-column-gap--3xl",
  "4xl": "vkuistyles__-column-gap--4xl"
};
var rowGapClassNames = {
  "2xs": "vkuistyles__-row-gap--2xs",
  "xs": "vkuistyles__-row-gap--xs",
  "s": "vkuistyles__-row-gap--s",
  "m": "vkuistyles__-row-gap--m",
  "l": "vkuistyles__-row-gap--l",
  "xl": "vkuistyles__-row-gap--xl",
  "2xl": "vkuistyles__-row-gap--2xl",
  "3xl": "vkuistyles__-row-gap--3xl",
  "4xl": "vkuistyles__-row-gap--4xl"
};
function calculateGap(gap) {
  if (typeof gap === "number" || typeof gap === "string") {
    return [
      gap,
      gap
    ];
  }
  return gap;
}

// node_modules/@vkontakte/vkui/dist/lib/layouts/helpers.js
function generateConstantClassName(prefix, value) {
  return `vkui-${prefix}-${value}`;
}
function generateVariableClassName(prefix) {
  return `vkui-${prefix}`;
}
function generateVariable(prefix) {
  return `--vkui_internal--${prefix}`;
}

// node_modules/@vkontakte/vkui/dist/lib/layouts/layoutProps.js
var DESIGN_SYSTEM_SIZES = [
  "2xs",
  "xs",
  "s",
  "m",
  "l",
  "xl",
  "2xl",
  "3xl",
  "4xl"
];
var CSS_INTRINSIC_KEYWORDS = [
  "auto",
  "max-content",
  "min-content",
  "fit-content"
];
var CSS_GLOBAL_KEYWORDS = [
  "inherit",
  "initial",
  "unset"
];
var CSS_KEYWORDS = [
  ...CSS_INTRINSIC_KEYWORDS,
  ...CSS_GLOBAL_KEYWORDS
];
var PADDING_VALUES = [
  ...DESIGN_SYSTEM_SIZES,
  ...CSS_GLOBAL_KEYWORDS
];
var SIZE_VALUES = CSS_KEYWORDS;
var MINMAX_SIZE_VALUES = [
  ...CSS_KEYWORDS.filter((opt) => opt !== "auto")
];
var FLEX_VALUES = CSS_GLOBAL_KEYWORDS;
var FLEX_BASIS_VALUES = [
  ...CSS_KEYWORDS,
  "content"
];
var INSET_VALUES = [
  ...DESIGN_SYSTEM_SIZES,
  ...CSS_GLOBAL_KEYWORDS,
  "auto"
];
var POSITION_VALUES = [
  "static",
  "relative",
  "absolute",
  "fixed"
];
var OVERFLOW_VALUES = [
  "visible",
  "hidden",
  "clip",
  "scroll",
  "auto",
  ...CSS_GLOBAL_KEYWORDS
];
var LAYOUT_PROPS = {
  padding: PADDING_VALUES,
  paddingInline: PADDING_VALUES,
  paddingBlock: PADDING_VALUES,
  paddingInlineStart: PADDING_VALUES,
  paddingInlineEnd: PADDING_VALUES,
  paddingBlockStart: PADDING_VALUES,
  paddingBlockEnd: PADDING_VALUES,
  inlineSize: SIZE_VALUES,
  minInlineSize: MINMAX_SIZE_VALUES,
  maxInlineSize: MINMAX_SIZE_VALUES,
  blockSize: SIZE_VALUES,
  minBlockSize: MINMAX_SIZE_VALUES,
  maxBlockSize: MINMAX_SIZE_VALUES,
  inset: INSET_VALUES,
  insetInline: INSET_VALUES,
  insetBlock: INSET_VALUES,
  insetInlineStart: INSET_VALUES,
  insetInlineEnd: INSET_VALUES,
  insetBlockStart: INSET_VALUES,
  insetBlockEnd: INSET_VALUES,
  position: POSITION_VALUES,
  flexGrow: FLEX_VALUES,
  flexShrink: FLEX_VALUES,
  flexBasis: FLEX_BASIS_VALUES,
  overflow: OVERFLOW_VALUES,
  overflowBlock: OVERFLOW_VALUES,
  overflowInline: OVERFLOW_VALUES
};

// node_modules/@vkontakte/vkui/dist/lib/layouts/resolveLayoutProps.js
function resolveLayoutProps(props) {
  const outProps = _object_spread({}, props);
  let resolvedClassName;
  let resolvedStyle;
  for (const key in LAYOUT_PROPS) {
    if (key in outProps && outProps[key] !== void 0) {
      const propDef = LAYOUT_PROPS[key];
      const value = outProps[key];
      const cssProperty = key.replace(/([A-Z])/g, "-$1").toLowerCase();
      if (typeof value === "string" && propDef.includes(value)) {
        resolvedClassName = clsx(resolvedClassName, generateConstantClassName(cssProperty, value));
      } else if (key !== "position" && !key.startsWith("overflow")) {
        resolvedClassName = clsx(resolvedClassName, generateVariableClassName(cssProperty));
        resolvedStyle = mergeStyle(resolvedStyle, {
          [generateVariable(cssProperty)]: typeof value === "number" && key !== "flexGrow" && key !== "flexShrink" ? `${value}px` : value
        });
      }
      delete outProps[key];
    }
  }
  outProps.className = clsx(resolvedClassName, outProps.className);
  outProps.style = mergeStyle(resolvedStyle, outProps.style);
  return outProps;
}

// node_modules/@vkontakte/vkui/dist/lib/spacings/sizes.js
var spacingSizeClassNames = {
  "2xs": "vkuistyles__-spacing--2xs",
  "xs": "vkuistyles__-spacing--xs",
  "s": "vkuistyles__-spacing--s",
  "m": "vkuistyles__-spacing--m",
  "l": "vkuistyles__-spacing--l",
  "xl": "vkuistyles__-spacing--xl",
  "2xl": "vkuistyles__-spacing--2xl",
  "3xl": "vkuistyles__-spacing--3xl",
  "4xl": "vkuistyles__-spacing--4xl"
};
function resolveSpacingSize(cssVariable, size5) {
  if (typeof size5 === "string") {
    if (size5.startsWith("--")) {
      return [
        void 0,
        {
          [cssVariable]: `var(${size5})`
        }
      ];
    } else {
      return [
        spacingSizeClassNames[size5],
        void 0
      ];
    }
  }
  return [
    void 0,
    typeof size5 === "number" ? {
      [cssVariable]: `${size5}px`
    } : void 0
  ];
}

// node_modules/@vkontakte/vkui/dist/components/Separator/Separator.js
var CUSTOM_CSS_TOKEN_FOR_USER_SIZE = "--vkui_internal--spacing_size";
var appearanceClassNames = {
  "primary": "vkuiSeparator__appearancePrimary",
  "secondary": "vkuiSeparator__appearanceSecondary",
  "primary-alpha": "vkuiSeparator__appearancePrimaryAlpha"
};
var directionClassNames = {
  horizontal: "vkuiSeparator__directionHorizontal",
  vertical: "vkuiSeparator__directionVertical"
};
var alignClassNames = {
  start: "vkuiSeparator__alignStart",
  end: "vkuiSeparator__alignEnd"
};
var Separator = (_param) => {
  var { padding = false, appearance = "primary", direction = "horizontal", align = "center", size: size5 } = _param, restProps = _object_without_properties(_param, [
    "padding",
    "appearance",
    "direction",
    "align",
    "size"
  ]);
  const [spacingSizeClassName, spacingSizeStyle] = resolveSpacingSize(CUSTOM_CSS_TOKEN_FOR_USER_SIZE, size5);
  const resolvedProps = resolveLayoutProps(restProps);
  return (0, import_jsx_runtime45.jsx)(RootComponent, _object_spread_props(_object_spread({}, resolvedProps), {
    baseClassName: clsx(padding && "vkuiSeparator__padded", appearanceClassNames[appearance], directionClassNames[direction], size5 !== void 0 && "vkuiSeparator__sized", align !== "center" && alignClassNames[align], spacingSizeClassName),
    baseStyle: spacingSizeStyle,
    children: (0, import_jsx_runtime45.jsx)("hr", {
      className: "vkuiSeparator__in"
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Spacing/Spacing.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var React60 = __toESM(require_react(), 1);
var CUSTOM_CSS_TOKEN_FOR_USER_GAP = "--vkui_internal--spacing_size";
var Spacing = (_param) => {
  var { size: size5 = "m" } = _param, restProps = _object_without_properties(_param, [
    "size"
  ]);
  const [spacingSizeClassName, spacingSizeStyle] = resolveSpacingSize(CUSTOM_CSS_TOKEN_FOR_USER_GAP, size5);
  return (0, import_jsx_runtime46.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseStyle: spacingSizeStyle,
    baseClassName: clsx("vkuiSpacing__host", spacingSizeClassName)
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeader/PanelHeader.js
var platformClassNames2 = {
  ios: "vkuiPanelHeader__ios",
  android: "vkuiPanelHeader__android",
  vkcom: clsx("vkuiPanelHeader__vkcom", "vkuiInternalPanelHeader--vkcom")
};
var sizeXClassNames3 = {
  none: "vkuiPanelHeader__sizeXNone",
  regular: "vkuiPanelHeader__sizeXRegular"
};
var sizeYClassNames13 = {
  none: "vkuiPanelHeader__sizeYNone",
  compact: "vkuiPanelHeader__sizeYCompact"
};
var PanelHeaderIn = ({ before, after, children, typographyProps = {} }) => {
  const { Component: Component2 = "span" } = typographyProps, restProps = _object_without_properties(typographyProps, [
    "Component"
  ]);
  const { hasCustomPanelHeaderAfter, customPanelHeaderAfterMinWidth } = useConfigProvider();
  const isInsideModal = useModalContext().id !== null;
  const platform3 = usePlatform();
  const afterSlotProps = !hasCustomPanelHeaderAfter || isInsideModal ? {
    children: after
  } : {
    style: {
      minWidth: customPanelHeaderAfterMinWidth
    }
  };
  const typographyNode = platform3 === "vkcom" ? (0, import_jsx_runtime47.jsx)(Text, _object_spread_props(_object_spread({
    weight: "2",
    Component: Component2
  }, restProps), {
    children
  })) : (0, import_jsx_runtime47.jsx)(Component2, _object_spread_props(_object_spread({
    className: "vkuiPanelHeader__contentIn"
  }, restProps), {
    children
  }));
  return (0, import_jsx_runtime47.jsxs)(OnboardingTooltipContainer, {
    fixed: true,
    className: "vkuiPanelHeader__in",
    children: [
      (0, import_jsx_runtime47.jsx)("div", {
        className: clsx("vkuiPanelHeader__before", "vkuiInternalPanelHeader__before"),
        children: before
      }),
      (0, import_jsx_runtime47.jsx)("div", {
        className: "vkuiPanelHeader__content",
        children: typographyNode
      }),
      (0, import_jsx_runtime47.jsx)("div", _object_spread({
        className: clsx("vkuiPanelHeader__after", "vkuiInternalPanelHeader__after")
      }, afterSlotProps))
    ]
  });
};
var PanelHeader = (_param) => {
  var { before, children, after, float = false, transparent = false, delimiter = "auto", shadow, getRef, getRootRef, fixed, typographyProps } = _param, restProps = _object_without_properties(_param, [
    "before",
    "children",
    "after",
    "float",
    "transparent",
    "delimiter",
    "shadow",
    "getRef",
    "getRootRef",
    "fixed",
    "typographyProps"
  ]);
  const platform3 = usePlatform();
  const { sizeX = "none", sizeY = "none" } = useAdaptivity();
  const { sizeX: adaptiveSizeX } = useAdaptivityConditionalRender();
  const isVKCOM = platform3 === "vkcom";
  const isFixed = fixed !== void 0 ? fixed : !isVKCOM;
  const separatorVisible = delimiter === "auto" || delimiter === "separator";
  const staticSeparatorVisible = !float && separatorVisible;
  const staticSpacingVisible = !float && (delimiter === "auto" || delimiter === "spacing");
  return (0, import_jsx_runtime47.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiPanelHeader__host", "vkuiInternalPanelHeader", platformClassNames2.hasOwnProperty(platform3) ? platformClassNames2[platform3] : platformClassNames2.android, transparent && "vkuiPanelHeader__trnsp", shadow && "vkuiPanelHeader__shadow", !float && clsx("vkuiPanelHeader__static", "vkuiInternalPanelHeader--static"), staticSeparatorVisible && clsx("vkuiPanelHeader__sep", "vkuiInternalPanelHeader--sep"), !before && clsx("vkuiPanelHeader__noBefore", "vkuiInternalPanelHeader--no-before"), !after && "vkuiPanelHeader__noAfter", isFixed && "vkuiPanelHeader__hasFixed", sizeX !== "compact" && sizeXClassNames3[sizeX], sizeY !== "regular" && sizeYClassNames13[sizeY]),
    getRootRef: isFixed ? getRootRef : getRef,
    children: [
      isFixed ? (0, import_jsx_runtime47.jsx)(FixedLayout, {
        className: clsx("vkuiPanelHeader__fixed", "vkuiInternalPanelHeader__fixed"),
        vertical: "top",
        getRootRef: getRef,
        children: (0, import_jsx_runtime47.jsx)(PanelHeaderIn, {
          before,
          after,
          typographyProps,
          children
        })
      }) : (0, import_jsx_runtime47.jsx)(PanelHeaderIn, {
        before,
        after,
        typographyProps,
        children
      }),
      !isVKCOM && (0, import_jsx_runtime47.jsxs)(import_jsx_runtime47.Fragment, {
        children: [
          staticSeparatorVisible && adaptiveSizeX.compact && (0, import_jsx_runtime47.jsx)(Separator, {
            className: adaptiveSizeX.compact.className,
            padding: true
          }),
          staticSpacingVisible && adaptiveSizeX.regular && (0, import_jsx_runtime47.jsx)(Spacing, {
            className: adaptiveSizeX.regular.className,
            size: 16
          })
        ]
      }),
      separatorVisible && isVKCOM && (0, import_jsx_runtime47.jsx)(Separator, {
        className: "vkuiPanelHeader__separator"
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeaderContent/PanelHeaderContent.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
var React62 = __toESM(require_react(), 1);
var platformClassNames3 = {
  ios: "vkuiPanelHeaderContent__ios",
  android: "vkuiPanelHeaderContent__android",
  vkcom: "vkuiPanelHeaderContent__vkcom"
};
var sizeYClassNames14 = {
  none: "vkuiPanelHeaderContent__sizeYNone",
  compact: "vkuiPanelHeaderContent__sizeYCompact"
};
var PanelHeaderChildren = ({ hasSubtitle, hasBefore, children }) => {
  const platform3 = usePlatform();
  return hasSubtitle || hasBefore ? (0, import_jsx_runtime48.jsx)(Text, {
    className: "vkuiPanelHeaderContent__childrenText",
    Component: "div",
    weight: platform3 === "vkcom" ? "2" : void 0,
    children
  }) : (0, import_jsx_runtime48.jsx)("div", {
    className: "vkuiPanelHeaderContent__childrenIn",
    children
  });
};
var PanelHeaderContent = (_param) => {
  var { aside, subtitle, before, children, onClick } = _param, restProps = _object_without_properties(_param, [
    "aside",
    "subtitle",
    "before",
    "children",
    "onClick"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const InComponent = onClick ? Tappable : "div";
  const rootProps = onClick ? {} : restProps;
  const platform3 = usePlatform();
  const inProps = onClick ? _object_spread_props(_object_spread({}, restProps), {
    onClick,
    activeEffectDelay: 200,
    hasActive: platform3 === "ios",
    activeMode: "opacity"
  }) : {};
  return (0, import_jsx_runtime48.jsxs)(RootComponent, _object_spread_props(_object_spread({}, rootProps), {
    baseClassName: clsx("vkuiPanelHeaderContent__host", platformClassNames3.hasOwnProperty(platform3) ? platformClassNames3[platform3] : platformClassNames3.android, sizeY !== "regular" && sizeYClassNames14[sizeY]),
    children: [
      hasReactNode(before) && (0, import_jsx_runtime48.jsx)("div", {
        className: "vkuiPanelHeaderContent__before",
        children: before
      }),
      (0, import_jsx_runtime48.jsxs)(InComponent, _object_spread_props(_object_spread({}, inProps), {
        className: clsx("vkuiPanelHeaderContent__in", !before && platform3 !== "android" && "vkuiPanelHeaderContent__inCentered"),
        children: [
          hasReactNode(subtitle) && (0, import_jsx_runtime48.jsx)(Footnote, {
            className: "vkuiPanelHeaderContent__subtitle",
            children: subtitle
          }),
          (0, import_jsx_runtime48.jsxs)("div", {
            className: "vkuiPanelHeaderContent__children",
            children: [
              (0, import_jsx_runtime48.jsx)(PanelHeaderChildren, {
                hasSubtitle: hasReactNode(subtitle),
                hasBefore: hasReactNode(before),
                children
              }),
              hasReactNode(aside) && (0, import_jsx_runtime48.jsx)("div", {
                className: "vkuiPanelHeaderContent__aside",
                children: aside
              })
            ]
          }),
          hasReactNode(before) && (0, import_jsx_runtime48.jsx)("div", {
            className: "vkuiPanelHeaderContent__width"
          })
        ]
      }))
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeaderContext/PanelHeaderContext.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var React63 = __toESM(require_react(), 1);
var sizeXClassNames4 = {
  none: "vkuiPanelHeaderContext__sizeXNone",
  compact: "vkuiPanelHeaderContext__sizeXCompact",
  regular: "vkuiPanelHeaderContext__sizeXRegular"
};
var PanelHeaderContext = (_param) => {
  var { children, opened = false, className, onClose } = _param, restProps = _object_without_properties(_param, [
    "children",
    "opened",
    "className",
    "onClose"
  ]);
  const platform3 = usePlatform();
  const { sizeX = "none" } = useAdaptivity();
  const elementRef = React63.useRef(null);
  const [animationState, animationHandlers] = useCSSKeyframesAnimationController(opened ? "enter" : "exit", void 0, true);
  const visible = animationState !== "exited";
  useScrollLock(platform3 !== "vkcom" && visible);
  const handleGlobalOnClickOutside = React63.useCallback((event) => {
    if (opened) {
      event.stopPropagation();
      onClose();
    }
  }, [
    opened,
    onClose
  ]);
  useGlobalOnClickOutside(handleGlobalOnClickOutside, visible ? elementRef : null);
  if (!visible) {
    return null;
  }
  return (0, import_jsx_runtime49.jsxs)(FixedLayout, _object_spread_props(_object_spread({}, restProps), {
    className: clsx("vkuiPanelHeaderContext__host", platform3 === "ios" && "vkuiPanelHeaderContext__ios", opened ? "vkuiPanelHeaderContext__opened" : "vkuiPanelHeaderContext__closing", sizeXClassNames4[sizeX], className),
    vertical: "top",
    children: [
      (0, import_jsx_runtime49.jsx)("div", {
        onClick: (event) => {
          event.stopPropagation();
          onClose();
        },
        className: "vkuiPanelHeaderContext__fade"
      }),
      (0, import_jsx_runtime49.jsx)("div", _object_spread_props(_object_spread({
        "data-testid": false ? "content" : void 0,
        className: "vkuiPanelHeaderContext__in",
        ref: elementRef
      }, animationHandlers), {
        children: (0, import_jsx_runtime49.jsx)("div", {
          className: "vkuiPanelHeaderContext__content",
          children
        })
      }))
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/SplitLayout/SplitLayout.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
var React64 = __toESM(require_react(), 1);
var warn7 = warnOnce("SplitLayout");
var SplitLayout = (_param) => {
  var { header, children, getRootRef, getRef, className, center, modal, popout, slotProps } = _param, restProps = _object_without_properties(_param, [
    "header",
    "children",
    "getRootRef",
    "getRef",
    "className",
    "center",
    "modal",
    "popout",
    "slotProps"
  ]);
  if (getRef) {
    warn7("Свойство `getRef` устаревшее, используйте `slotProps={ content: { getRootRef: ... } }`");
  }
  const rootRest = useMergeProps({
    getRootRef
  }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.root);
  const contentRest = useMergeProps(_object_spread({
    getRootRef: getRef,
    className
  }, restProps), slotProps === null || slotProps === void 0 ? void 0 : slotProps.content);
  const platform3 = usePlatform();
  return (0, import_jsx_runtime50.jsxs)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: clsx("vkuiSplitLayout__host", platform3 === "ios" && "vkuiSplitLayout__ios")
  }, rootRest), {
    children: [
      header,
      (0, import_jsx_runtime50.jsxs)(RootComponent, _object_spread_props(_object_spread({
        baseClassName: clsx("vkuiSplitLayout__inner", !!header && "vkuiSplitLayout__innerHeader", center && "vkuiSplitLayout__innerCenter")
      }, contentRest), {
        children: [
          children,
          modal,
          popout
        ]
      }))
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/SplitCol/SplitCol.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);
var React66 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useMediaQueries.js
var React65 = __toESM(require_react(), 1);
var mediaQueriesCache = /* @__PURE__ */ new WeakMap();
function getMediaQueries(matchMedia2) {
  return {
    desktopPlus: matchMedia2(MEDIA_QUERIES.DESKTOP_PLUS),
    smallTabletPlus: matchMedia2(MEDIA_QUERIES.SMALL_TABLET_PLUS),
    tablet: matchMedia2(MEDIA_QUERIES.TABLET),
    smallTablet: matchMedia2(MEDIA_QUERIES.SMALL_TABLET),
    mobile: matchMedia2(MEDIA_QUERIES.MOBILE),
    mediumHeight: matchMedia2(MEDIA_QUERIES.MEDIUM_HEIGHT),
    mobileLandscapeHeight: matchMedia2(MEDIA_QUERIES.MOBILE_LANDSCAPE_HEIGHT)
  };
}
var useMediaQueries = () => {
  const { window: window2 } = useDOM();
  return React65.useMemo(function initializeStoreOrUpdateStoreIfWindowChanges() {
    if (!window2) {
      return getMediaQueries(mediaQueryNull);
    }
    const storedMediaQueries = mediaQueriesCache.get(window2);
    if (storedMediaQueries) {
      return storedMediaQueries;
    }
    const mediaQueries = getMediaQueries(window2.matchMedia.bind(window2));
    mediaQueriesCache.set(window2, mediaQueries);
    return mediaQueries;
  }, [
    window2
  ]);
};

// node_modules/@vkontakte/vkui/dist/components/SplitCol/SplitCol.js
var breakpointClassNames = {
  none: clsx("vkuiSplitCol__viewWidthNone", "vkuiInternalSplitCol--viewWidth-none"),
  tabletMinus: "vkuiSplitCol__viewWidthTabletMinus",
  smallTabletPlus: "vkuiSplitCol__viewWidthSmallTabletPlus",
  tabletPlus: "vkuiInternalSplitCol--viewWidth-tabletPlus"
};
function useTransitionAnimate(animateProp) {
  const { viewWidth } = useAdaptivity();
  const [animate3, setAnimate] = React66.useState(Boolean(animateProp));
  const mediaQueries = useMediaQueries();
  React66.useEffect(() => {
    if (animateProp !== void 0) {
      setAnimate(animateProp);
      return;
    }
    if (viewWidth !== void 0) {
      setAnimate(viewWidth < ViewWidth.TABLET);
      return;
    }
    const listener = () => setAnimate(!mediaQueries.smallTabletPlus.matches);
    listener();
    matchMediaListAddListener(mediaQueries.smallTabletPlus, listener);
    return () => {
      matchMediaListRemoveListener(mediaQueries.smallTabletPlus, listener);
    };
  }, [
    animateProp,
    viewWidth,
    mediaQueries
  ]);
  return animate3;
}
var SplitCol = (props) => {
  const { children, width, maxWidth, minWidth, animate: animateProp, fixed, autoSpaced, stretchedOnMobile, getRootRef } = props, restProps = _object_without_properties(props, [
    "children",
    "width",
    "maxWidth",
    "minWidth",
    "animate",
    "fixed",
    "autoSpaced",
    "stretchedOnMobile",
    "getRootRef"
  ]);
  const baseRef = useExternRef(getRootRef);
  const { viewWidth } = useAdaptivity();
  const animate3 = useTransitionAnimate(animateProp);
  const contextValue = React66.useMemo(() => ({
    colRef: baseRef,
    animate: animate3
  }), [
    animate3,
    baseRef
  ]);
  return (0, import_jsx_runtime51.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseStyle: {
      width,
      maxWidth,
      minWidth
    },
    getRootRef: baseRef,
    baseClassName: clsx("vkuiSplitCol__host", viewWidthToClassName(breakpointClassNames, viewWidth), autoSpaced && clsx("vkuiSplitCol__spacedAuto", "vkuiInternalSplitCol--spaced-auto"), fixed && "vkuiSplitCol__fixed", stretchedOnMobile && "vkuiSplitCol__stretchedOnMobile"),
    children: (0, import_jsx_runtime51.jsx)(SplitColContext.Provider, {
      value: contextValue,
      children: fixed ? (0, import_jsx_runtime51.jsx)("div", {
        className: "vkuiSplitCol__fixedInner",
        children
      }) : children
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Epic/Epic.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
var React68 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/Epic/ScrollSaver.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var React67 = __toESM(require_react(), 1);
var ScrollSaver = ({ children, initialScroll, saveScroll }) => {
  const { getScroll, scrollTo } = React67.useContext(ScrollContext);
  useIsomorphicLayoutEffect(() => {
    if (typeof initialScroll === "number") {
      scrollTo(0, initialScroll);
    }
    return () => saveScroll(getScroll().y);
  }, []);
  return (0, import_jsx_runtime52.jsx)(React67.Fragment, {
    children
  });
};

// node_modules/@vkontakte/vkui/dist/components/Epic/Epic.js
var warn8 = warnOnce("Epic");
var Epic = (_param) => {
  var { activeStory, tabbar, children } = _param, restProps = _object_without_properties(_param, [
    "activeStory",
    "tabbar",
    "children"
  ]);
  const scroll = React68.useRef({}).current;
  var _React_Children_toArray_find;
  const story = (_React_Children_toArray_find = React68.Children.toArray(children).find((story2) => React68.isValidElement(story2) && getNavId(story2.props, warn8) === activeStory)) !== null && _React_Children_toArray_find !== void 0 ? _React_Children_toArray_find : null;
  return (0, import_jsx_runtime53.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiEpic__host", tabbar && "vkuiInternalEpic--hasTabbar"),
    children: [
      (0, import_jsx_runtime53.jsx)(ScrollSaver, {
        initialScroll: scroll[activeStory] || 0,
        saveScroll: (value) => scroll[activeStory] = value,
        children: story
      }, activeStory),
      tabbar
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Tabbar/Tabbar.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
var React69 = __toESM(require_react(), 1);
var getItemsLayoutClassName = (itemsLayout, children) => {
  switch (itemsLayout) {
    case "horizontal":
      return "vkuiInternalTabbar--layout-horizontal";
    case "vertical":
      return "vkuiInternalTabbar--layout-vertical";
    default:
      return React69.Children.count(children) > 2 ? getItemsLayoutClassName("vertical", []) : getItemsLayoutClassName("horizontal", []);
  }
};
var Tabbar = (_param) => {
  var { plain = false, mode } = _param, restProps = _object_without_properties(_param, [
    "plain",
    "mode"
  ]);
  const platform3 = usePlatform();
  return (0, import_jsx_runtime54.jsx)(RootComponent, _object_spread({
    baseClassName: clsx("vkuiInternalTabbar", "vkuiTabbar__host", platform3 === "ios" && "vkuiTabbar__ios", getItemsLayoutClassName(mode, restProps.children), !plain && "vkuiTabbar__shadow")
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/TabbarItem/TabbarItem.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
var React70 = __toESM(require_react(), 1);
var warn9 = warnOnce("TabbarItem");
var TabbarItem = (_param) => {
  var { children, selected, indicator, label, href, Component: Component2 = href ? "a" : "button", disabled, onFocus: onFocusProp, onBlur: onBlurProp } = _param, restProps = _object_without_properties(_param, [
    "children",
    "selected",
    "indicator",
    "label",
    "href",
    "Component",
    "disabled",
    "onFocus",
    "onBlur"
  ]);
  const platform3 = usePlatform();
  if (true) {
    const hasAccessibleName2 = label || restProps["aria-label"] || restProps["aria-labelledby"];
    if (!hasAccessibleName2) {
      warn9(COMMON_WARNINGS.a11y[Component2 === "a" ? "link-name" : "button-name"], "error");
    }
  }
  const { focusVisible, onFocus: handleFocusVisibleOnFocus, onBlur: handleFocusVisibleOnBlur } = useFocusVisible();
  const focusVisibleClassNames = useFocusVisibleClassName({
    focusVisible
  });
  return (0, import_jsx_runtime55.jsxs)(RootComponent, _object_spread_props(_object_spread({
    Component: Component2
  }, restProps), {
    disabled,
    onFocus: callMultiple(handleFocusVisibleOnFocus, onFocusProp),
    onBlur: callMultiple(handleFocusVisibleOnBlur, onBlurProp),
    href,
    baseClassName: clsx("vkuiTabbarItem__host", platform3 === "ios" && "vkuiTabbarItem__ios", platform3 === "android" && "vkuiTabbarItem__android", selected && "vkuiTabbarItem__selected"),
    children: [
      (0, import_jsx_runtime55.jsx)(Tappable, {
        role: "presentation",
        disabled,
        activeMode: platform3 === "ios" ? "vkuiTabbarItem__tappableActive" : "background",
        activeEffectDelay: platform3 === "ios" ? 0 : 300,
        hasHover: false,
        className: clsx("vkuiTabbarItem__tappable", focusVisibleClassNames),
        onClick: noop,
        tabIndex: -1
      }),
      (0, import_jsx_runtime55.jsxs)("div", {
        className: "vkuiTabbarItem__in",
        children: [
          (0, import_jsx_runtime55.jsxs)("div", {
            className: "vkuiTabbarItem__icon",
            children: [
              children,
              (0, import_jsx_runtime55.jsx)("div", {
                className: "vkuiInternalTabbarItem__label",
                children: hasReactNode(indicator) && indicator
              })
            ]
          }),
          label && (0, import_jsx_runtime55.jsx)(Footnote, {
            Component: "div",
            className: "vkuiTabbarItem__label",
            weight: "2",
            children: label
          })
        ]
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ScrollArrow/ScrollArrow.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var React71 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useConfigDirection.js
function useConfigDirection() {
  const { direction } = useConfigProvider();
  return direction || "ltr";
}

// node_modules/@vkontakte/vkui/dist/components/ScrollArrow/ScrollArrow.js
var stylesSize2 = {
  s: "vkuiScrollArrow__sizeS",
  m: "vkuiScrollArrow__sizeM"
};
var stylesDirection2 = {
  up: "vkuiScrollArrow__directionUp",
  right: "vkuiScrollArrow__directionRight",
  down: "vkuiScrollArrow__directionDown",
  left: "vkuiScrollArrow__directionLeft"
};
var labelDirection = {
  up: "Назад",
  right: "Вперед",
  down: "Вперед",
  left: "Назад"
};
var ArrowIcon = ({ size: size5 }) => {
  let Icon = Icon24Chevron;
  if (size5 === "s") {
    Icon = Icon16Chevron;
  }
  return (0, import_jsx_runtime56.jsx)(Icon, {
    className: "vkuiScrollArrow__defaultIcon"
  });
};
var ScrollArrow = (_param) => {
  var { size: size5 = "m", offsetY, direction, label: labelProp, children = (0, import_jsx_runtime56.jsx)(ArrowIcon, {
    size: size5
  }) } = _param, restProps = _object_without_properties(_param, [
    "size",
    "offsetY",
    "direction",
    "label",
    "children"
  ]);
  const textDirection = useConfigDirection();
  const label = labelProp !== null && labelProp !== void 0 ? labelProp : labelDirection[direction];
  return (0, import_jsx_runtime56.jsxs)(RootComponent, _object_spread_props(_object_spread({
    Component: "button",
    type: "button",
    baseClassName: clsx("vkuiScrollArrow__host", stylesSize2[size5], stylesDirection2[direction], textDirection === "rtl" && "vkuiScrollArrow__rtl")
  }, restProps), {
    children: [
      label && (0, import_jsx_runtime56.jsx)(VisuallyHidden, {
        children: label
      }),
      (0, import_jsx_runtime56.jsx)("span", {
        className: "vkuiScrollArrow__icon",
        style: offsetY ? {
          top: offsetY
        } : void 0,
        children
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/HorizontalScroll/HorizontalScroll.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
var React72 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/lib/fx.js
function easeInOutSine(x) {
  return 0.5 * (1 - Math.cos(Math.PI * x));
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
    throw new Error("Bezier x values must be in [0, 1] range");
  }
  if (mX1 === mY1 && mX2 === mY2) {
    return LinearEasing;
  }
  const a = 6 * (3 * mX1 - 3 * mX2 + 1);
  const b = 6 * (mX2 - 2 * mX1);
  const c = 3 * mX1;
  const a2 = a * a;
  const b2 = b * b;
  const d = b / a;
  const e = 3 * b * c / a2 - b2 * b / (a2 * a);
  const w1 = 2 * c / a - b2 / a2;
  const w = w1 * w1 * w1;
  const o = 3 / a;
  const ay = 3 * mY1 - 3 * mY2 + 1;
  const by = mY2 - 2 * mY1;
  const cy = 3 * mY1;
  const funcX2T = a ? x2t : LinearEasing;
  return (x) => {
    if (x === 0 || x === 1) {
      return x;
    }
    return funcY(funcX2T(x, e, o, w, d), ay, by, cy);
  };
}
function LinearEasing(x) {
  return x;
}
function x2t(x, a, b, c, d) {
  const q = a + b * x;
  const s = q ** 2 + c;
  if (s > 0) {
    const root = Math.sqrt(s);
    return Math.cbrt(q + root) + Math.cbrt(q - root) - d;
  }
  const l = Math.cbrt(Math.sqrt(q * q - s));
  const angle = q ? Math.atan(Math.sqrt(-s) / q) : -Math.PI / 2;
  let φ;
  if (b < 0) {
    φ = (q > 0 ? 2 * Math.PI : Math.PI) - angle;
  } else if (d < 0) {
    φ = (q > 0 ? 2 * Math.PI : -3 * Math.PI) + angle;
  } else {
    φ = (q > 0 ? 0 : Math.PI) + angle;
  }
  return 2 * l * Math.cos(φ / 3) - d;
}
function funcY(t, ay, by, cy) {
  return ((ay * t + 3 * by) * t + cy) * t;
}

// node_modules/@vkontakte/vkui/dist/components/HorizontalScroll/HorizontalScroll.js
function now() {
  return performance && performance.now ? performance.now() : Date.now();
}
function roundingAwayFromZero(value) {
  return value > 0 ? Math.ceil(value) : Math.floor(value);
}
var roundUpElementScrollLeft = (el) => roundingAwayFromZero(el.scrollLeft);
var SCROLL_ONE_FRAME_TIME = 250;
function doScroll({ scrollElement, getScrollPosition, animationQueue, onScrollToEndBorder, onScrollEnd, onScrollStart, initialScrollWidth, scrollAnimationDuration, textDirection }) {
  if (!scrollElement || !getScrollPosition) {
    return;
  }
  const extremeScrollLeft = (textDirection === "ltr" ? 1 : -1) * (initialScrollWidth - scrollElement.offsetWidth);
  const startScrollLeft = roundUpElementScrollLeft(scrollElement);
  const remappedStartScrollLeft = startScrollLeft * (textDirection === "rtl" ? -1 : 1);
  let endScrollLeft = getScrollPosition(remappedStartScrollLeft);
  const diff = endScrollLeft - remappedStartScrollLeft;
  if (textDirection === "rtl") {
    endScrollLeft = startScrollLeft - diff;
  }
  onScrollStart();
  if (startScrollLeft * endScrollLeft < 0) {
    endScrollLeft = 0;
  }
  if (Math.abs(endScrollLeft) >= Math.abs(extremeScrollLeft)) {
    onScrollToEndBorder();
    endScrollLeft = extremeScrollLeft;
  }
  const startTime = now();
  (function scroll() {
    const time = now();
    const elapsed = Math.min((time - startTime) / scrollAnimationDuration, 1);
    const value = easeInOutSine(elapsed);
    const currentScrollLeft = startScrollLeft + (endScrollLeft - startScrollLeft) * value;
    scrollElement.scrollLeft = roundingAwayFromZero(currentScrollLeft);
    const scrollEnd = textDirection === "ltr" ? Math.max(0, endScrollLeft) : Math.min(0, endScrollLeft);
    if (roundUpElementScrollLeft(scrollElement) !== scrollEnd && elapsed !== 1) {
      requestAnimationFrame(scroll);
      return;
    }
    onScrollEnd();
    animationQueue.shift();
    if (animationQueue.length > 0) {
      animationQueue[0]();
    }
  })();
}
var HorizontalScroll = (_param) => {
  var {
    children,
    getScrollToLeft,
    getScrollToRight,
    showArrows = true,
    arrowSize = "m",
    arrowOffsetY,
    scrollAnimationDuration = SCROLL_ONE_FRAME_TIME,
    getRef,
    scrollOnAnyWheel = false,
    prevButtonTestId,
    nextButtonTestId,
    // ContentWrapper
    ContentWrapperComponent = "div",
    contentWrapperRef,
    contentWrapperClassName,
    withPadding,
    onPointerEnter,
    onPointerLeave,
    onMouseEnter
  } = _param, restProps = _object_without_properties(_param, [
    "children",
    "getScrollToLeft",
    "getScrollToRight",
    "showArrows",
    "arrowSize",
    "arrowOffsetY",
    "scrollAnimationDuration",
    "getRef",
    "scrollOnAnyWheel",
    "prevButtonTestId",
    "nextButtonTestId",
    "ContentWrapperComponent",
    "contentWrapperRef",
    "contentWrapperClassName",
    "withPadding",
    "onPointerEnter",
    "onPointerLeave",
    "onMouseEnter"
  ]);
  const [canScrollStart, setCanScrollStart] = React72.useState(false);
  const [canScrollEnd, setCanScrollEnd] = React72.useState(false);
  const _useFocusVisible = useFocusVisible(), { focusVisible } = _useFocusVisible, focusEvents = _object_without_properties(_useFocusVisible, [
    "focusVisible"
  ]);
  const focusVisibleClassNames = useFocusVisibleClassName({
    focusVisible
  });
  const direction = useConfigDirection();
  const isRtl = direction === "rtl";
  const isCustomScrollingRef = React72.useRef(false);
  const scrollerRef = useExternRef(getRef);
  const animationQueue = React72.useRef([]);
  const _useHover = useHover(), { isHovered } = _useHover, hoverHandlers = _object_without_properties(_useHover, [
    "isHovered"
  ]);
  const scrollTo = React72.useCallback((getScrollPosition) => {
    const scrollElement = scrollerRef.current;
    animationQueue.current.push(() => {
      var _scrollElement_firstElementChild;
      return doScroll({
        scrollElement,
        getScrollPosition,
        animationQueue: animationQueue.current,
        onScrollToEndBorder: () => setCanScrollEnd(false),
        onScrollEnd: () => isCustomScrollingRef.current = false,
        onScrollStart: () => isCustomScrollingRef.current = true,
        initialScrollWidth: (scrollElement === null || scrollElement === void 0 ? void 0 : (_scrollElement_firstElementChild = scrollElement.firstElementChild) === null || _scrollElement_firstElementChild === void 0 ? void 0 : _scrollElement_firstElementChild.scrollWidth) || 0,
        scrollAnimationDuration,
        textDirection: direction
      });
    });
    if (animationQueue.current.length === 1) {
      animationQueue.current[0]();
    }
  }, [
    scrollerRef,
    scrollAnimationDuration,
    direction,
    setCanScrollEnd
  ]);
  const scrollToStart = React72.useCallback(() => {
    const getScrollPosition = getScrollToLeft !== null && getScrollToLeft !== void 0 ? getScrollToLeft : (i) => i - scrollerRef.current.offsetWidth;
    scrollTo(getScrollPosition);
  }, [
    getScrollToLeft,
    scrollTo,
    scrollerRef
  ]);
  const scrollToEnd = React72.useCallback(() => {
    const getScrollPosition = getScrollToRight !== null && getScrollToRight !== void 0 ? getScrollToRight : (i) => i + scrollerRef.current.offsetWidth;
    scrollTo(getScrollPosition);
  }, [
    getScrollToRight,
    scrollTo,
    scrollerRef
  ]);
  const calculateArrowsVisibility = React72.useCallback(() => {
    if (showArrows && scrollerRef.current && !isCustomScrollingRef.current) {
      const scrollElement = scrollerRef.current;
      const scrollLeft = scrollElement.scrollLeft;
      setCanScrollStart(isRtl ? scrollLeft < 0 : scrollLeft > 0);
      setCanScrollEnd(Math.abs(roundUpElementScrollLeft(scrollElement)) + scrollElement.offsetWidth < scrollElement.scrollWidth);
    }
  }, [
    showArrows,
    scrollerRef,
    isRtl
  ]);
  React72.useEffect(calculateArrowsVisibility, [
    calculateArrowsVisibility,
    children
  ]);
  useIsomorphicLayoutEffect(function addWheelEventHandler() {
    const scrollEl = scrollerRef.current;
    if (!scrollEl) {
      return noop;
    }
    const onWheel = (e) => {
      scrollerRef.current.scrollBy({
        left: e.deltaX + e.deltaY,
        behavior: "auto"
      });
      e.preventDefault();
    };
    const listenerOptions = {
      passive: false
    };
    if (scrollOnAnyWheel) {
      scrollEl.addEventListener("wheel", onWheel, listenerOptions);
    }
    scrollEl.addEventListener("scroll", calculateArrowsVisibility, listenerOptions);
    return () => {
      if (scrollOnAnyWheel) {
        scrollEl.removeEventListener("wheel", onWheel, listenerOptions);
      }
      scrollEl.removeEventListener("scroll", calculateArrowsVisibility, listenerOptions);
    };
  }, [
    scrollOnAnyWheel,
    calculateArrowsVisibility,
    scrollerRef
  ]);
  const handlers = mergeCalls(hoverHandlers, {
    onPointerEnter,
    onPointerLeave
  });
  return (0, import_jsx_runtime57.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps, handlers), {
    baseClassName: clsx("vkuiHorizontalScroll__host", "vkuiInternalHorizontalScroll", (showArrows === "always" || isHovered) && "vkuiHorizontalScroll__showArrows", isRtl && "vkuiHorizontalScroll__rtl", withPadding && "vkuiHorizontalScroll__withPadding"),
    // FIXME: onMouseEnter из restProps затирается, а при callMultiply орет линтер на рефы.
    onMouseEnter: calculateArrowsVisibility,
    children: [
      showArrows && canScrollStart && (0, import_jsx_runtime57.jsx)(ScrollArrow, {
        "data-testid": prevButtonTestId,
        size: arrowSize,
        offsetY: arrowOffsetY,
        direction: "left",
        "aria-hidden": true,
        tabIndex: -1,
        className: clsx("vkuiHorizontalScroll__arrow", "vkuiHorizontalScroll__arrowLeft"),
        onClick: scrollToStart
      }),
      showArrows && canScrollEnd && (0, import_jsx_runtime57.jsx)(ScrollArrow, {
        "data-testid": nextButtonTestId,
        size: arrowSize,
        offsetY: arrowOffsetY,
        direction: "right",
        "aria-hidden": true,
        tabIndex: -1,
        className: clsx("vkuiHorizontalScroll__arrow", "vkuiHorizontalScroll__arrowRight"),
        onClick: scrollToEnd
      }),
      (0, import_jsx_runtime57.jsx)("div", _object_spread_props(_object_spread({
        className: clsx("vkuiHorizontalScroll__in", focusVisibleClassNames),
        ref: scrollerRef
      }, focusEvents), {
        children: (0, import_jsx_runtime57.jsx)(ContentWrapperComponent, {
          className: clsx("vkuiHorizontalScroll__inWrapper", contentWrapperClassName),
          ref: contentWrapperRef,
          children
        })
      }))
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/AspectRatio/AspectRatio.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
var React73 = __toESM(require_react(), 1);
function AspectRatio(_param) {
  var { ratio, mode = "stretch" } = _param, props = _object_without_properties(_param, [
    "ratio",
    "mode"
  ]);
  const style = {
    "--vkui_internal--aspect_ratio": typeof ratio === "number" ? String(ratio) : ratio
  };
  return (0, import_jsx_runtime58.jsx)(RootComponent, _object_spread({
    baseClassName: clsx("vkuiAspectRatio__host", mode === "stretch" && "vkuiAspectRatio__modeStretch"),
    baseStyle: style
  }, props));
}

// node_modules/@vkontakte/vkui/dist/components/Flex/Flex.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);

// node_modules/@vkontakte/vkui/dist/components/Flex/FlexItem/FlexItem.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
var flexClassNames = {
  grow: "vkuiFlexItem__flexGrow",
  shrink: "vkuiFlexItem__flexShrink",
  content: "vkuiFlexItem__flexContent",
  fixed: "vkuiFlexItem__flexFixed"
};
var alignSelfClassNames = {
  start: "vkuiFlexItem__alignSelfStart",
  end: "vkuiFlexItem__alignSelfEnd",
  center: "vkuiFlexItem__alignSelfCenter",
  baseline: "vkuiFlexItem__alignSelfBaseline",
  stretch: "vkuiFlexItem__alignSelfStretch"
};
var warn10 = warnOnce("Flex.Item");
var FlexItem = (_param) => {
  var { children, alignSelf, flex, flexBasis } = _param, rest = _object_without_properties(_param, [
    "children",
    "alignSelf",
    "flex",
    "flexBasis"
  ]);
  if (true) {
    warn10("Компонент Flex.Item устарел, используйте компонент Flex в качестве альтернативы.");
  }
  return (0, import_jsx_runtime59.jsx)(RootComponent, _object_spread_props(_object_spread({}, rest), {
    baseStyle: {
      flexBasis
    },
    baseClassName: clsx(alignSelf && alignSelfClassNames[alignSelf], flex && flexClassNames[flex]),
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Flex/Flex.js
var justifyClassNames = {
  "start": "vkuiFlex__justifyStart",
  "end": "vkuiFlex__justifyEnd",
  "center": "vkuiFlex__justifyCenter",
  "space-around": "vkuiFlex__justifySpaceAround",
  "space-between": "vkuiFlex__justifySpaceBetween",
  "space-evenly": "vkuiFlex__justifySpaceEvenly"
};
var alignClassNames2 = {
  start: "vkuiFlex__alignStart",
  end: "vkuiFlex__alignEnd",
  center: "vkuiFlex__alignCenter",
  stretch: "vkuiFlex__alignStretch",
  baseline: "vkuiFlex__alignBaseline"
};
var alignSelfClassNames2 = {
  start: "vkuiFlexItem__alignSelfStart",
  end: "vkuiFlexItem__alignSelfEnd",
  center: "vkuiFlexItem__alignSelfCenter",
  baseline: "vkuiFlexItem__alignSelfBaseline",
  stretch: "vkuiFlexItem__alignSelfStretch"
};
var displayClassNames = {
  "none": "vkuiFlex__displayNone",
  "inline-flex": "vkuiFlex__displayInlineFlex"
};
var Flex = (_param) => {
  var { gap = 0, align, justify, margin = "none", noWrap = false, direction = "row", reverse = false, children, alignSelf, display = "flex" } = _param, restProps = _object_without_properties(_param, [
    "gap",
    "align",
    "justify",
    "margin",
    "noWrap",
    "direction",
    "reverse",
    "children",
    "alignSelf",
    "display"
  ]);
  const [rowGap, columnGap] = calculateGap(gap);
  const resolvedProps = resolveLayoutProps(restProps);
  return (0, import_jsx_runtime60.jsx)(RootComponent, _object_spread_props(_object_spread({}, resolvedProps), {
    baseClassName: clsx("vkuiFlex__host", !noWrap && "vkuiFlex__wrap", reverse && "vkuiFlex__reverse", direction !== "row" && "vkuiFlex__directionColumn", margin !== "none" && "vkuiFlex__marginAuto", align && alignClassNames2[align], alignSelf && alignSelfClassNames2[alignSelf], justify && justifyClassNames[justify], getGapsPresets(rowGap, columnGap), display !== "flex" && displayClassNames[display]),
    baseStyle: getGapsByUser(rowGap, columnGap),
    children
  }));
};
function getGapsPresets(rowGap, columnGap) {
  return clsx(typeof rowGap === "string" && rowGapClassNames[rowGap], typeof columnGap === "string" && columnGapClassNames[columnGap]);
}
function getGapsByUser(rowGap, columnGap) {
  const style = {};
  if (typeof rowGap === "number") {
    style["--vkui_internal--row_gap"] = `${rowGap}px`;
  }
  if (typeof columnGap === "number") {
    style["--vkui_internal--column_gap"] = `${columnGap}px`;
  }
  return style;
}
Flex.Item = FlexItem;

// node_modules/@vkontakte/vkui/dist/components/SimpleGrid/SimpleGrid.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);
var marginClassNames = {
  "auto": "vkuiSimpleGrid__marginAuto",
  "auto-inline": "vkuiSimpleGrid__marginAutoInline",
  "auto-block": "vkuiSimpleGrid__marginAutoBlock"
};
var alignClassNames3 = {
  start: "vkuiSimpleGrid__alignStart",
  end: "vkuiSimpleGrid__alignEnd",
  center: "vkuiSimpleGrid__alignCenter",
  stretch: "vkuiSimpleGrid__alignStretch",
  baseline: "vkuiSimpleGrid__alignBaseline"
};
var displayClassNames2 = {
  "none": "vkuiSimpleGrid__displayNone",
  "inline-grid": "vkuiSimpleGrid__displayInlineGrid"
};
var SimpleGrid = (_param) => {
  var { columns = 1, gap = 0, margin = "none", minColWidth, align = "stretch", display = "grid" } = _param, restProps = _object_without_properties(_param, [
    "columns",
    "gap",
    "margin",
    "minColWidth",
    "align",
    "display"
  ]);
  const resolvedProps = resolveLayoutProps(restProps);
  const style = {};
  const [rowGap, columnGap] = calculateGap(gap);
  if (typeof rowGap === "number") {
    style["--vkui_internal--row_gap"] = `${rowGap}px`;
  }
  if (typeof columnGap === "number") {
    style["--vkui_internal--column_gap"] = `${columnGap}px`;
  }
  style["--vkui_internal--grid_columns"] = `${columns}`;
  if (minColWidth) {
    style["--vkui_internal--min_col_width"] = `${minColWidth}px`;
  }
  return (0, import_jsx_runtime61.jsx)(RootComponent, _object_spread_props(_object_spread({}, resolvedProps), {
    baseClassName: clsx("vkuiSimpleGrid__host", margin !== "none" && marginClassNames[margin], alignClassNames3[align], minColWidth && "vkuiSimpleGrid__withMinWidth", typeof columnGap === "string" && columnGapClassNames[columnGap], typeof rowGap === "string" && rowGapClassNames[rowGap], display !== "grid" && displayClassNames2[display]),
    baseStyle: style
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PopoutWrapper/PopoutWrapper.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
var React74 = __toESM(require_react(), 1);
var stylesAlignX = {
  center: "vkuiPopoutWrapper__alignXCenter",
  left: "vkuiPopoutWrapper__alignXLeft",
  right: "vkuiPopoutWrapper__alignXRight"
};
var stylesAlignY = {
  center: "vkuiPopoutWrapper__alignYCenter",
  top: "vkuiPopoutWrapper__alignYTop",
  bottom: "vkuiPopoutWrapper__alignYBottom"
};
var stylesStrategy = {
  fixed: "vkuiPopoutWrapper__fixed",
  absolute: "vkuiPopoutWrapper__absolute",
  none: void 0
};
var PopoutWrapper = (_param) => {
  var {
    alignY = "center",
    alignX = "center",
    closing = false,
    noBackground = false,
    strategy: strategyProp,
    // TODO [>=8]: удалить свойство
    fixed = true,
    children,
    onClick,
    zIndex = "var(--vkui--z_index_popout)"
  } = _param, restProps = _object_without_properties(_param, [
    "alignY",
    "alignX",
    "closing",
    "noBackground",
    "strategy",
    "fixed",
    "children",
    "onClick",
    "zIndex"
  ]);
  const strategy = strategyProp || (fixed ? "fixed" : "none");
  return (0, import_jsx_runtime62.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiPopoutWrapper__host", stylesAlignY[alignY], stylesAlignX[alignX], closing ? "vkuiPopoutWrapper__closing" : "vkuiPopoutWrapper__opened", strategy && stylesStrategy[strategy], !noBackground && "vkuiPopoutWrapper__masked"),
    baseStyle: {
      zIndex
    },
    children: (0, import_jsx_runtime62.jsxs)("div", {
      className: "vkuiPopoutWrapper__container",
      children: [
        (0, import_jsx_runtime62.jsx)("div", {
          className: "vkuiPopoutWrapper__overlay",
          onClick
        }),
        (0, import_jsx_runtime62.jsx)("div", {
          className: "vkuiPopoutWrapper__content",
          children
        })
      ]
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Alert/Alert.js
var import_jsx_runtime70 = __toESM(require_jsx_runtime(), 1);
var React82 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/Alert/AlertBase.js
var import_jsx_runtime69 = __toESM(require_jsx_runtime(), 1);
var React81 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityWithJSMediaQueries.js
var React75 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/helpers/getOrDefault.js
function getOrDefault(value, defaultValue) {
  return value !== null && value !== void 0 ? value : defaultValue;
}

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityWithJSMediaQueries.js
var warn11 = warnOnce("useAdaptivityWithJSMediaQueries");
var useAdaptivityWithJSMediaQueries = () => {
  if (!canUseDOM) {
    warn11(`Похоже, вы пытаетесь использовать хук вне браузера.

Постарайтесь этого избегать, чтобы не было ошибок при гидратации: при SSR нет информации о размерах экрана.

Используйте CSS Media Query или библиотеку по типу https://github.com/artsy/fresnel.`, "error");
  }
  const { viewWidth: viewWidthContext, viewHeight: viewHeightContext, sizeX: sizeXContext, sizeY: sizeYContext, hasPointer: hasPointerContext, hasHover: hasHoverContext } = React75.useContext(AdaptivityContext);
  const platform3 = usePlatform();
  const mediaQueries = useMediaQueries();
  const [[viewWidthLocal, viewHeightLocal], setViewSizeLocal] = React75.useState(() => [
    getOrDefault(viewWidthContext, getViewWidthByMediaQueries(mediaQueries)),
    getOrDefault(viewHeightContext, getViewHeightByMediaQueries(mediaQueries))
  ]);
  const adaptivityProps = React75.useMemo(() => {
    const hasPointer = getOrDefault(hasPointerContext, hasMouse);
    const hasHover2 = getOrDefault(hasHoverContext, hasHover);
    const viewWidth = getOrDefault(viewWidthContext, viewWidthLocal);
    const viewHeight = getOrDefault(viewHeightContext, viewHeightLocal);
    const sizeX = getOrDefault(sizeXContext, getSizeX(viewWidth));
    const sizeY = getOrDefault(sizeYContext, getSizeY(viewWidth, viewHeight, hasPointer));
    const isDesktop = tryToCheckIsDesktop(viewWidth, viewHeight, hasPointer, platform3);
    return {
      viewWidth,
      viewHeight,
      sizeX,
      sizeY,
      hasPointer,
      hasHover: hasHover2,
      isDesktop
    };
  }, [
    viewWidthLocal,
    viewHeightLocal,
    viewWidthContext,
    viewHeightContext,
    sizeXContext,
    sizeYContext,
    hasPointerContext,
    hasHoverContext,
    platform3
  ]);
  React75.useEffect(() => {
    const handleMediaQuery = () => {
      setViewSizeLocal((prevSizeLocal) => {
        const newViewWidthLocal = getOrDefault(viewWidthContext, getViewWidthByMediaQueries(mediaQueries));
        const newViewHeightLocal = getOrDefault(viewHeightContext, getViewHeightByMediaQueries(mediaQueries));
        const [prevViewWidthLocal, prevViewHeightLocal] = prevSizeLocal;
        if (prevViewWidthLocal !== newViewWidthLocal || prevViewHeightLocal !== newViewHeightLocal) {
          return [
            newViewWidthLocal,
            newViewHeightLocal
          ];
        }
        return prevSizeLocal;
      });
    };
    if (!viewWidthContext) {
      [
        mediaQueries.desktopPlus,
        mediaQueries.tablet,
        mediaQueries.smallTablet,
        mediaQueries.mobile
      ].forEach((matchMediaListener) => matchMediaListAddListener(matchMediaListener, handleMediaQuery));
    }
    if (!viewHeightContext) {
      [
        mediaQueries.mediumHeight,
        mediaQueries.mobileLandscapeHeight
      ].forEach((matchMediaListener) => matchMediaListAddListener(matchMediaListener, handleMediaQuery));
    }
    return () => {
      [
        mediaQueries.desktopPlus,
        mediaQueries.tablet,
        mediaQueries.smallTablet,
        mediaQueries.mobile,
        mediaQueries.mediumHeight,
        mediaQueries.mobileLandscapeHeight
      ].forEach((matchMediaListener) => matchMediaListRemoveListener(matchMediaListener, handleMediaQuery));
    };
  }, [
    mediaQueries,
    viewWidthContext,
    viewHeightContext
  ]);
  return adaptivityProps;
};

// node_modules/@vkontakte/vkui/dist/components/FocusTrap/FocusTrap.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useFocusTrap.js
var import_react10 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/helpers/array.js
function arraysEquals(arrA, arrB) {
  if (arrA.length !== arrB.length) {
    return false;
  }
  return arrA.every((item, index2) => item === arrB[index2]);
}

// node_modules/@vkontakte/vkui/dist/hooks/useMutationObserver.js
var DEFAULT_MUTATION_OBSERVER_OPTIONS = {
  subtree: true,
  childList: true
};
var useMutationObserver = (ref, callback, options = DEFAULT_MUTATION_OBSERVER_OPTIONS) => {
  const stableCallback = useStableCallback(callback);
  useIsomorphicLayoutEffect(() => {
    if (!ref || !ref.current) {
      return;
    }
    const observer = new MutationObserver(stableCallback);
    observer.observe(ref.current, options);
    return () => observer.disconnect();
  }, [
    ref,
    stableCallback
  ]);
};

// node_modules/@vkontakte/vkui/dist/hooks/useFocusTrap.js
function isFocusableElement(el) {
  return FOCUSABLE_ELEMENTS_LIST.some((sel) => el.matches(sel));
}
var useRestoreFocus = ({ restoreFocus, timeout, mount, ref }) => {
  const restoreFocusRef = (0, import_react10.useRef)(restoreFocus);
  restoreFocusRef.current = restoreFocus;
  const [restoreFocusTo, setRestoreFocusTo] = (0, import_react10.useState)(null);
  const restoreFocusImpl = useStableCallback(() => {
    var _ref_current;
    const shouldRestoreFocus = typeof restoreFocusRef.current === "function" ? restoreFocusRef.current() : restoreFocusRef.current;
    if (!shouldRestoreFocus) {
      return;
    }
    const activeElement = getActiveElementByAnotherElement(ref.current);
    if (activeElement && !((_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.contains(activeElement)) && isFocusableElement(activeElement)) {
      return;
    }
    setTimeout(() => {
      const restoreFocusElement = isHTMLElement(shouldRestoreFocus) && shouldRestoreFocus || isHTMLElement(restoreFocusTo) && restoreFocusTo || null;
      if (restoreFocusElement) {
        restoreFocusElement.focus();
        setRestoreFocusTo(null);
      }
    }, timeout);
  });
  useIsomorphicLayoutEffect(function calculateRestoreFocusTo() {
    if (!ref.current || !restoreFocusRef.current || !mount) {
      setRestoreFocusTo(null);
      return;
    }
    setRestoreFocusTo(getActiveElementByAnotherElement(ref.current));
  }, [
    ref,
    mount
  ]);
  useIsomorphicLayoutEffect(function tryToRestoreFocusOnUnmount() {
    return () => {
      restoreFocusImpl();
    };
  }, [
    restoreFocusImpl
  ]);
  useIsomorphicLayoutEffect(function tryToRestoreFocusWhenFakeUnmount() {
    if (!mount) {
      restoreFocusImpl();
    }
  }, [
    mount,
    restoreFocusImpl
  ]);
};
var FOCUSABLE_ELEMENTS = FOCUSABLE_ELEMENTS_LIST.join();
var useFocusTrap = (ref, { mount = true, disabled = false, autoFocus = true, restoreFocus = true, timeout = 0, onClose, captureEscapeKeyboardEvent = true, mutationObserverOptions }) => {
  const { document: document2 } = useDOM();
  const focusableNodesRef = (0, import_react10.useRef)([]);
  const focusNodeByIndex = (nodeIndex) => {
    const element = focusableNodesRef.current[nodeIndex];
    if (element) {
      element.focus({
        preventScroll: true
      });
    }
  };
  useRestoreFocus({
    restoreFocus,
    mount,
    timeout,
    ref
  });
  const recalculateFocusableNodesRef = (parentNode) => {
    const newFocusableElements = parentNode.querySelectorAll(FOCUSABLE_ELEMENTS);
    const nodes = [];
    newFocusableElements.forEach((focusableEl) => {
      const { display, visibility } = getComputedStyle(focusableEl);
      if (display !== "none" && visibility !== "hidden") {
        nodes.push(focusableEl);
      }
    });
    if (nodes.length === 0) {
      nodes.push(parentNode);
    }
    focusableNodesRef.current = nodes;
  };
  const onMutateParentHandler = (parentNode) => {
    const oldFocusableNodes = [
      ...focusableNodesRef.current
    ];
    recalculateFocusableNodesRef(parentNode);
    if (disabled || !autoFocus || arraysEquals(oldFocusableNodes, focusableNodesRef.current)) {
      return;
    }
    if (document2) {
      const activeElement = document2.activeElement;
      const currentElementIndex = Math.max(document2.activeElement ? focusableNodesRef.current.indexOf(activeElement) : -1, 0);
      focusNodeByIndex(currentElementIndex);
    }
  };
  useMutationObserver(ref, () => ref.current && onMutateParentHandler(ref.current), mutationObserverOptions);
  useIsomorphicLayoutEffect(() => {
    ref.current && recalculateFocusableNodesRef(ref.current);
  }, [
    ref
  ]);
  useIsomorphicLayoutEffect(function tryToAutoFocusToFirstNode() {
    if (!ref.current || !autoFocus || disabled) {
      return;
    }
    const autoFocusToNode = () => {
      if (!ref.current || !focusableNodesRef.current.length) {
        return;
      }
      const activeElement = getActiveElementByAnotherElement(ref.current);
      if (!contains(ref.current, activeElement)) {
        if (autoFocus === "root") {
          var _ref_current;
          (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.focus();
        } else {
          focusableNodesRef.current[0].focus();
        }
      }
    };
    const timeoutId = setTimeout(autoFocusToNode, timeout);
    return () => {
      clearTimeout(timeoutId);
    };
  }, [
    autoFocus,
    timeout,
    disabled
  ]);
  useIsomorphicLayoutEffect(function initializeFocusTrap() {
    if (!ref.current) {
      return;
    }
    const onDocumentKeydown = (event) => {
      if (disabled) {
        return;
      }
      const pressedKeyResult = pressedKey(event);
      switch (pressedKeyResult) {
        case Keys.TAB: {
          if (!focusableNodesRef.current.length) {
            return false;
          }
          const lastIdx = focusableNodesRef.current.length - 1;
          const targetIdx = focusableNodesRef.current.findIndex((node) => node === event.target);
          const shouldFocusFirstNode = targetIdx === -1 || targetIdx === lastIdx && !event.shiftKey;
          if (shouldFocusFirstNode || targetIdx === 0 && event.shiftKey) {
            event.preventDefault();
            const node = focusableNodesRef.current[shouldFocusFirstNode ? 0 : lastIdx];
            if (node !== getActiveElementByAnotherElement(node)) {
              node.focus();
            }
            return false;
          }
          break;
        }
      }
      return true;
    };
    const onEscapeKeydown = (event) => {
      if (disabled) {
        return;
      }
      const pressedKeyResult = pressedKey(event);
      if (pressedKeyResult === Keys.ESCAPE) {
        if (onClose) {
          event.preventDefault();
          onClose();
        }
      }
      return true;
    };
    const doc = getWindow(ref.current).document;
    doc.addEventListener("keydown", onDocumentKeydown, {
      capture: true
    });
    doc.addEventListener("keydown", onEscapeKeydown, {
      capture: captureEscapeKeyboardEvent
    });
    return () => {
      doc.removeEventListener("keydown", onDocumentKeydown, true);
      doc.removeEventListener("keydown", onEscapeKeydown, captureEscapeKeyboardEvent);
    };
  }, [
    onClose,
    ref,
    disabled
  ]);
};

// node_modules/@vkontakte/vkui/dist/components/FocusTrap/FocusTrap.js
var FocusTrap = (_param) => {
  var { Component: Component2 = "div", onClose, autoFocus = true, restoreFocus = true, disabled = false, mount = true, timeout = 0, getRootRef, children, captureEscapeKeyboardEvent = true, mutationObserverOptions = DEFAULT_MUTATION_OBSERVER_OPTIONS } = _param, restProps = _object_without_properties(_param, [
    "Component",
    "onClose",
    "autoFocus",
    "restoreFocus",
    "disabled",
    "mount",
    "timeout",
    "getRootRef",
    "children",
    "captureEscapeKeyboardEvent",
    "mutationObserverOptions"
  ]);
  const ref = useExternRef(getRootRef);
  useFocusTrap(ref, {
    autoFocus,
    restoreFocus,
    disabled,
    mount,
    timeout,
    onClose,
    captureEscapeKeyboardEvent,
    mutationObserverOptions
  });
  return (0, import_jsx_runtime63.jsx)(Component2, _object_spread_props(_object_spread({
    tabIndex: -1,
    ref
  }, restProps), {
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ModalDismissButton/ModalDismissButton.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
var React77 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/ModalOutsideButton/ModalOutsideButton.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);
var React76 = __toESM(require_react(), 1);
var ModalOutsideButton = (_param) => {
  var { children, "aria-label": ariaLabel } = _param, restProps = _object_without_properties(_param, [
    "children",
    "aria-label"
  ]);
  return (0, import_jsx_runtime64.jsxs)(Tappable, _object_spread_props(_object_spread({
    baseClassName: "vkuiModalOutsideButton__host",
    activeMode: "vkuiModalOutsideButton__active",
    hoverMode: "vkuiModalOutsideButton__hover"
  }, restProps), {
    children: [
      ariaLabel && (0, import_jsx_runtime64.jsx)(VisuallyHidden, {
        children: ariaLabel
      }),
      children
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ModalDismissButton/ModalDismissButton.js
var ModalDismissButton = (_param) => {
  var { children = "Закрыть", className } = _param, restProps = _object_without_properties(_param, [
    "children",
    "className"
  ]);
  return (0, import_jsx_runtime65.jsxs)(ModalOutsideButton, _object_spread_props(_object_spread({
    className: clsx("vkuiModalDismissButton__host", className)
  }, restProps), {
    children: [
      children && (0, import_jsx_runtime65.jsx)(VisuallyHidden, {
        children
      }),
      (0, import_jsx_runtime65.jsx)(Icon20Cancel, {})
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Alert/AlertActions.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime(), 1);
var React79 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/Alert/AlertAction.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);
var React78 = __toESM(require_react(), 1);
var AlertActionIos = (_param) => {
  var { mode } = _param, restProps = _object_without_properties(_param, [
    "mode"
  ]);
  return (0, import_jsx_runtime66.jsx)(Tappable, _object_spread({
    Component: restProps.href ? "a" : "button",
    baseClassName: clsx("vkuiAlert__action", mode === "destructive" && "vkuiAlert__actionModeDestructive", mode === "cancel" && "vkuiAlert__actionModeCancel")
  }, restProps));
};
var AlertActionBase = (_param) => {
  var { mode } = _param, restProps = _object_without_properties(_param, [
    "mode"
  ]);
  const platform3 = usePlatform();
  let buttonMode = "tertiary";
  if (platform3 === "vkcom") {
    buttonMode = mode === "cancel" ? "secondary" : "primary";
  }
  return (0, import_jsx_runtime66.jsx)(Button, _object_spread({
    className: clsx("vkuiAlert__button", mode === "cancel" && "vkuiAlert__buttonModeCancel"),
    mode: buttonMode,
    size: "m"
  }, restProps));
};
var AlertAction = (props) => {
  const platform3 = usePlatform();
  if (platform3 === "ios") {
    return (0, import_jsx_runtime66.jsx)(AlertActionIos, _object_spread({}, props));
  }
  return (0, import_jsx_runtime66.jsx)(AlertActionBase, _object_spread({}, props));
};

// node_modules/@vkontakte/vkui/dist/components/Alert/AlertActions.js
var alignStyles = {
  left: "vkuiAlert__actionsAlignLeft",
  center: "vkuiAlert__actionsAlignCenter",
  right: "vkuiAlert__actionsAlignRight"
};
var directionStyles = {
  vertical: "vkuiAlert__actionsDirectionVertical",
  horizontal: "vkuiAlert__actionsDirectionHorizontal"
};
var AlertActions = ({ actions = [], renderAction = (props) => (0, import_jsx_runtime67.jsx)(AlertAction, _object_spread({}, props)), onItemClick, actionsAlign, actionsLayout }) => {
  const platform3 = usePlatform();
  const direction = platform3 === "vkcom" ? "horizontal" : actionsLayout;
  return (0, import_jsx_runtime67.jsx)("div", {
    className: clsx("vkuiAlert__actions", actionsAlign && alignStyles[actionsAlign], direction && directionStyles[direction]),
    children: actions.map((action, i) => {
      const { title: children, action: _, autoCloseDisabled } = action, restProps = _object_without_properties(action, [
        "title",
        "action",
        "autoCloseDisabled"
      ]);
      return (0, import_jsx_runtime67.jsx)(React79.Fragment, {
        children: renderAction(_object_spread({
          children,
          onClick: () => onItemClick(action)
        }, restProps))
      }, i);
    })
  });
};

// node_modules/@vkontakte/vkui/dist/components/Alert/AlertTypography.js
var import_jsx_runtime68 = __toESM(require_jsx_runtime(), 1);
var React80 = __toESM(require_react(), 1);
var AlertTitle = (props) => {
  const platform3 = usePlatform();
  switch (platform3) {
    case "ios":
      return (0, import_jsx_runtime68.jsx)(Title, _object_spread({
        className: "vkuiAlert__title",
        weight: "1",
        level: "3"
      }, props));
    default:
      return (0, import_jsx_runtime68.jsx)(Title, _object_spread({
        className: "vkuiAlert__title",
        weight: "2",
        level: "2"
      }, props));
  }
};
var AlertDescription = (props) => {
  const platform3 = usePlatform();
  switch (platform3) {
    case "vkcom":
      return (0, import_jsx_runtime68.jsx)(Footnote, _object_spread({
        className: "vkuiAlert__description"
      }, props));
    case "ios":
      return (0, import_jsx_runtime68.jsx)(Caption, _object_spread({
        className: "vkuiAlert__description"
      }, props));
    default:
      return (0, import_jsx_runtime68.jsx)(Text, _object_spread({
        Component: "span",
        className: "vkuiAlert__description",
        weight: "3"
      }, props));
  }
};

// node_modules/@vkontakte/vkui/dist/components/Alert/AlertBase.js
var AlertBase = (_param) => {
  var { actions, actionsLayout = "horizontal", children, title, description, onClose, dismissLabel = "Закрыть предупреждение", renderAction, actionsAlign, dismissButtonMode = "outside", dismissButtonTestId, onClick, allowClickPropagation = false, titleTestId, descriptionTestId, closing, setClosing } = _param, restProps = _object_without_properties(_param, [
    "actions",
    "actionsLayout",
    "children",
    "title",
    "description",
    "onClose",
    "dismissLabel",
    "renderAction",
    "actionsAlign",
    "dismissButtonMode",
    "dismissButtonTestId",
    "onClick",
    "allowClickPropagation",
    "titleTestId",
    "descriptionTestId",
    "closing",
    "setClosing"
  ]);
  const generatedId = React81.useId();
  const titleId = `vkui-alert-${generatedId}-title`;
  const descriptionId = `vkui-alert-${generatedId}-description`;
  const platform3 = usePlatform();
  const { isDesktop } = useAdaptivityWithJSMediaQueries();
  const itemActionCallbackRef = React81.useRef(noop);
  const [animationState, animationHandlers] = useCSSKeyframesAnimationController(closing ? "exit" : "enter", {
    onExited() {
      itemActionCallbackRef.current();
      itemActionCallbackRef.current = noop;
      onClose();
    }
  });
  const isDismissButtonVisible = isDesktop && platform3 !== "ios";
  const elementRef = React81.useRef(null);
  const close = React81.useCallback(() => {
    setClosing === null || setClosing === void 0 ? void 0 : setClosing(true);
  }, [
    setClosing
  ]);
  const onItemClick = React81.useCallback((item) => {
    const { action: itemAction, autoCloseDisabled = false } = item;
    if (autoCloseDisabled) {
      itemAction && itemAction({
        close
      });
    } else {
      if (itemAction) {
        itemActionCallbackRef.current = itemAction;
      }
      setClosing === null || setClosing === void 0 ? void 0 : setClosing(true);
    }
  }, [
    close,
    setClosing
  ]);
  const handleClick = allowClickPropagation ? onClick : (event) => {
    stopPropagation(event);
    onClick === null || onClick === void 0 ? void 0 : onClick(event);
  };
  return (0, import_jsx_runtime69.jsxs)(FocusTrap, _object_spread_props(_object_spread(_object_spread_props(_object_spread({}, animationHandlers), {
    onClick: handleClick,
    getRootRef: elementRef,
    onClose: close,
    autoFocus: animationState === "entered",
    className: clsx("vkuiAlert__host", platform3 === "ios" && "vkuiAlert__ios", platform3 === "vkcom" && "vkuiAlert__vkcom", closing ? "vkuiAlert__closing" : "vkuiAlert__opening", isDesktop && "vkuiAlert__desktop"),
    role: "alertdialog",
    "aria-modal": true,
    "aria-labelledby": titleId,
    "aria-describedby": descriptionId
  }), restProps), {
    children: [
      (0, import_jsx_runtime69.jsxs)("div", {
        className: clsx("vkuiAlert__content", dismissButtonMode === "inside" && "vkuiAlert__contentWithButton"),
        children: [
          hasReactNode(title) && (0, import_jsx_runtime69.jsx)(AlertTitle, {
            "data-testid": titleTestId,
            id: titleId,
            children: title
          }),
          hasReactNode(description) && (0, import_jsx_runtime69.jsx)(AlertDescription, {
            "data-testid": descriptionTestId,
            id: descriptionId,
            children: description
          }),
          children,
          isDismissButtonVisible && dismissButtonMode === "inside" && (0, import_jsx_runtime69.jsx)(IconButton, {
            label: dismissLabel,
            className: clsx("vkuiAlert__dismiss", "vkuiInternalAlert__dismiss"),
            onClick: close,
            hoverMode: "opacity",
            activeMode: "opacity",
            "data-testid": dismissButtonTestId,
            children: (0, import_jsx_runtime69.jsx)(Icon20Cancel, {})
          })
        ]
      }),
      isDismissButtonVisible && dismissButtonMode === "outside" && (0, import_jsx_runtime69.jsx)(ModalDismissButton, {
        onClick: close,
        "data-testid": dismissButtonTestId,
        children: dismissLabel
      }),
      (0, import_jsx_runtime69.jsx)(AlertActions, {
        actions,
        actionsAlign,
        actionsLayout,
        renderAction,
        onItemClick
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Alert/Alert.js
var warn12 = warnOnce("Alert");
var Alert = (_param) => {
  var { usePortal, style, className, getRootRef } = _param, restProps = _object_without_properties(_param, [
    "usePortal",
    "style",
    "className",
    "getRootRef"
  ]);
  const [closing, setClosing] = React82.useState(false);
  const close = React82.useCallback(() => {
    setClosing(true);
  }, []);
  useScrollLock();
  if (!restProps.title && !restProps["aria-label"] && !restProps["aria-labelledby"]) {
    warn12('Если "title" не используется, то необходимо задать либо "aria-label", либо "aria-labelledby" (см. правило axe aria-dialog-name)');
  }
  return (0, import_jsx_runtime70.jsx)(AppRootPortal, {
    usePortal,
    children: (0, import_jsx_runtime70.jsx)(PopoutWrapper, {
      className,
      closing,
      style,
      onClick: close,
      getRootRef,
      strategy: "fixed",
      children: (0, import_jsx_runtime70.jsx)(AlertBase, _object_spread_props(_object_spread({}, restProps), {
        closing,
        setClosing
      }))
    })
  });
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheet.js
var import_jsx_runtime79 = __toESM(require_jsx_runtime(), 1);
var React93 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheetContext.js
var React83 = __toESM(require_react(), 1);
var ActionSheetContext = React83.createContext({});

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheetDefaultIosCloseItem.js
var import_jsx_runtime73 = __toESM(require_jsx_runtime(), 1);

// node_modules/@vkontakte/vkui/dist/components/ActionSheetItem/ActionSheetItem.js
var import_jsx_runtime72 = __toESM(require_jsx_runtime(), 1);
var React85 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/ActionSheetItem/helpers.js
var isRealClickEvent = (event) => {
  return event.type === "click" && event.clientX !== 0 && event.clientY !== 0;
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheetItem/subcomponents/Radio/Radio.js
var import_jsx_runtime71 = __toESM(require_jsx_runtime(), 1);
var React84 = __toESM(require_react(), 1);
var adaptiveIcon = (0, import_jsx_runtime71.jsx)(AdaptiveIconRenderer, {
  IconCompact: Icon20CheckCircleOn,
  IconRegular: Icon24CheckCircleOn
});
var Radio = (_param) => {
  var { children = adaptiveIcon, getRootRef, getRef, className, style } = _param, restProps = _object_without_properties(_param, [
    "children",
    "getRootRef",
    "getRef",
    "className",
    "style"
  ]);
  return (0, import_jsx_runtime71.jsxs)(RootComponent, {
    getRootRef,
    className,
    style,
    children: [
      (0, import_jsx_runtime71.jsx)(VisuallyHidden, _object_spread({
        Component: "input",
        getRootRef: getRef,
        type: "radio",
        className: "vkuiRadio__input"
      }, restProps)),
      children
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheetItem/ActionSheetItem.js
var ActionSheetItem = (_param) => {
  var { children, autoCloseDisabled = false, mode = "default", meta, subtitle, before, after, selectable, value, name, checked, defaultChecked, onChange, onClick, onImmediateClick, multiline = false, iconChecked, isCancelItem } = _param, restProps = _object_without_properties(_param, [
    "children",
    "autoCloseDisabled",
    "mode",
    "meta",
    "subtitle",
    "before",
    "after",
    "selectable",
    "value",
    "name",
    "checked",
    "defaultChecked",
    "onChange",
    "onClick",
    "onImmediateClick",
    "multiline",
    "iconChecked",
    "isCancelItem"
  ]);
  const platform3 = usePlatform();
  const { onItemClick = () => noop, mode: actionSheetMode, onClose: onActionSheetClose } = React85.useContext(ActionSheetContext);
  const { sizeY } = useAdaptivityWithJSMediaQueries();
  const Component2 = selectable ? "label" : void 0;
  const isRich = subtitle || meta || selectable;
  const isCentered = !isRich && !before && platform3 === "ios";
  const onItemClickHandler = React85.useCallback((e) => {
    var _onItemClick;
    (_onItemClick = onItemClick({
      action: onClick,
      immediateAction: onImmediateClick,
      autoClose: !autoCloseDisabled,
      isCancelItem: Boolean(isCancelItem)
    })) === null || _onItemClick === void 0 ? void 0 : _onItemClick(e);
  }, [
    autoCloseDisabled,
    isCancelItem,
    onClick,
    onImmediateClick,
    onItemClick
  ]);
  const onKeyDown = React85.useCallback((event) => {
    if (pressedKey(event) === Keys.ENTER) {
      onActionSheetClose === null || onActionSheetClose === void 0 ? void 0 : onActionSheetClose();
    }
  }, [
    onActionSheetClose
  ]);
  const onItemClickImpl = React85.useCallback((event) => {
    if (selectable) {
      if (isRealClickEvent(event)) {
        onItemClickHandler(event);
      }
    } else {
      onItemClickHandler(event);
    }
  }, [
    onItemClickHandler,
    selectable
  ]);
  return (0, import_jsx_runtime72.jsxs)(Tappable, _object_spread_props(_object_spread({}, Component2 && {
    Component: Component2
  }, restProps), {
    onClick: onItemClickImpl,
    activeMode: platform3 === "ios" ? "vkuiActionSheetItem__active" : void 0,
    baseClassName: clsx("vkuiActionSheetItem__host", platform3 === "ios" && "vkuiActionSheetItem__ios", mode === "cancel" && "vkuiActionSheetItem__modeCancel", mode === "destructive" && "vkuiActionSheetItem__modeDestructive", sizeY === "compact" && "vkuiActionSheetItem__sizeYCompact", isRich && "vkuiActionSheetItem__rich", actionSheetMode === "menu" && "vkuiActionSheetItem__menu", restProps.disabled && "vkuiActionSheetItem__disabled"),
    onKeyDown,
    children: [
      before && (0, import_jsx_runtime72.jsx)("div", {
        className: "vkuiActionSheetItem__before",
        children: before
      }),
      (0, import_jsx_runtime72.jsxs)("div", {
        className: clsx("vkuiActionSheetItem__container", !multiline && "vkuiActionSheetItem__ellipsis"),
        children: [
          (0, import_jsx_runtime72.jsxs)("div", {
            className: clsx("vkuiActionSheetItem__content", isCentered && "vkuiActionSheetItem__centered"),
            children: [
              platform3 === "ios" ? (0, import_jsx_runtime72.jsx)(Title, {
                className: "vkuiActionSheetItem__children",
                weight: mode === "cancel" ? "2" : "3",
                level: isCentered ? "2" : "3",
                children
              }) : (0, import_jsx_runtime72.jsx)(Text, {
                className: "vkuiActionSheetItem__children",
                children
              }),
              meta && (0, import_jsx_runtime72.jsx)(Text, {
                className: "vkuiActionSheetItem__meta",
                children: meta
              })
            ]
          }),
          subtitle && (0, import_jsx_runtime72.jsx)(Subhead, {
            className: "vkuiActionSheetItem__subtitle",
            children: subtitle
          })
        ]
      }),
      (selectable || after) && (0, import_jsx_runtime72.jsxs)("div", {
        className: "vkuiActionSheetItem__after",
        children: [
          after,
          selectable && (0, import_jsx_runtime72.jsx)(Radio, {
            name,
            value,
            onChange,
            defaultChecked,
            checked,
            disabled: restProps.disabled,
            children: iconChecked
          })
        ]
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheetDefaultIosCloseItem.js
var ActionSheetDefaultIosCloseItem = (_param) => {
  var { children = "Отмена" } = _param, restProps = _object_without_properties(_param, [
    "children"
  ]);
  return (0, import_jsx_runtime73.jsx)(ActionSheetItem, _object_spread_props(_object_spread({
    mode: "cancel",
    isCancelItem: true
  }, restProps), {
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheetDropdownMenu.js
var import_jsx_runtime77 = __toESM(require_jsx_runtime(), 1);
var React91 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useEffectDev.js
var import_react11 = __toESM(require_react(), 1);
var useEffectDev = true ? import_react11.useEffect : noop;

// node_modules/@vkontakte/vkui/dist/hooks/useEventListener.js
var React86 = __toESM(require_react(), 1);
var _target = /* @__PURE__ */ new WeakMap();
var _listener = /* @__PURE__ */ new WeakMap();
var EventListener = class {
  constructor(type, callback, options) {
    _define_property(this, "callback", noop);
    _define_property(this, "options", void 0);
    _define_property(this, "eventType", void 0);
    _class_private_field_init(this, _target, {
      writable: true,
      value: null
    });
    _class_private_field_init(this, _listener, {
      writable: true,
      value: (ev) => {
        this.callback(ev);
      }
    });
    _define_property(this, "add", (el) => {
      if (!canUseDOM) {
        return;
      }
      this.remove();
      if (!el) {
        return;
      }
      el.addEventListener(this.eventType, _class_private_field_get(this, _listener), this.options);
      _class_private_field_set(this, _target, el);
    });
    _define_property(this, "remove", () => {
      if (!canUseDOM || !_class_private_field_get(this, _target)) {
        return;
      }
      _class_private_field_get(this, _target).removeEventListener(this.eventType, _class_private_field_get(this, _listener), this.options);
      _class_private_field_set(this, _target, null);
    });
    this.options = options;
    this.eventType = type;
    if (callback) {
      this.callback = callback;
    }
  }
};
function useEventListener(event, _cb, _options) {
  const ref = React86.useRef(null);
  if (ref.current === null) {
    ref.current = new EventListener(event, _cb, _options);
  } else {
    ref.current.eventType = event;
    ref.current.options = _options;
    if (_cb) {
      ref.current.callback = _cb;
    }
  }
  React86.useEffect(() => {
    var _ref_current;
    const detach = (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.remove.bind(ref.current);
    return detach;
  }, []);
  return ref.current;
}

// node_modules/@vkontakte/vkui/dist/components/Popper/Popper.js
var import_jsx_runtime76 = __toESM(require_jsx_runtime(), 1);
var React90 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/lib/floating/useReferenceHiddenChangeCallback.js
var React87 = __toESM(require_react(), 1);
function useReferenceHiddenChangeCallback(hideMiddleware, onReferenceHiddenChange) {
  const prevHiddenRef = React87.useRef(hideMiddleware === null || hideMiddleware === void 0 ? void 0 : hideMiddleware.referenceHidden);
  React87.useEffect(() => {
    prevHiddenRef.current = hideMiddleware === null || hideMiddleware === void 0 ? void 0 : hideMiddleware.referenceHidden;
  });
  useIsomorphicLayoutEffect(function checkHiddenChanged() {
    if (!onReferenceHiddenChange) {
      return;
    }
    if ((hideMiddleware === null || hideMiddleware === void 0 ? void 0 : hideMiddleware.referenceHidden) !== prevHiddenRef.current) {
      onReferenceHiddenChange((hideMiddleware === null || hideMiddleware === void 0 ? void 0 : hideMiddleware.referenceHidden) || false);
    }
  }, [
    hideMiddleware === null || hideMiddleware === void 0 ? void 0 : hideMiddleware.referenceHidden,
    onReferenceHiddenChange
  ]);
}

// node_modules/@vkontakte/vkui/dist/components/FloatingArrow/DefaultIcon.js
var import_jsx_runtime74 = __toESM(require_jsx_runtime(), 1);
var React88 = __toESM(require_react(), 1);
var DEFAULT_ARROW_WIDTH = 20;
var DEFAULT_ARROW_HEIGHT = 8;
var DEFAULT_ARROW_PADDING = 10;
var PLATFORM_HEIGHT = 1;
var ARROW_HEIGHT_WITH_WHITE_SPACE = DEFAULT_ARROW_HEIGHT + PLATFORM_HEIGHT;
var DefaultIcon = (props) => {
  return (0, import_jsx_runtime74.jsx)("svg", _object_spread_props(_object_spread({
    width: DEFAULT_ARROW_WIDTH,
    height: ARROW_HEIGHT_WITH_WHITE_SPACE,
    viewBox: `0 0 ${DEFAULT_ARROW_WIDTH} ${ARROW_HEIGHT_WITH_WHITE_SPACE}`,
    xmlns: "http://www.w3.org/2000/svg"
  }, props), {
    children: (0, import_jsx_runtime74.jsx)("path", {
      d: "M10 0c3 0 6 8 10 8v1H0V8c3.975 0 7-8 10-8Z",
      fill: "currentColor"
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/FloatingArrow/FloatingArrow.js
var import_jsx_runtime75 = __toESM(require_jsx_runtime(), 1);
var React89 = __toESM(require_react(), 1);
var placementClassNames = {
  right: "vkuiFloatingArrow__placementRight",
  bottom: "vkuiFloatingArrow__placementBottom",
  left: "vkuiFloatingArrow__placementLeft"
};
var FloatingArrow = (_param) => {
  var { offset: offset5, isStaticOffset, coords, iconStyle, iconClassName: iconClassName2, placement = "bottom", Icon = DefaultIcon } = _param, restProps = _object_without_properties(_param, [
    "offset",
    "isStaticOffset",
    "coords",
    "iconStyle",
    "iconClassName",
    "placement",
    "Icon"
  ]);
  const [arrowPlacement, arrowStyles] = getArrowPositionData(placement, coords, offset5, isStaticOffset);
  return (0, import_jsx_runtime75.jsx)(RootComponent, _object_spread_props(_object_spread({
    baseStyle: arrowStyles,
    baseClassName: clsx("vkuiFloatingArrow__host", arrowPlacement && placementClassNames[arrowPlacement])
  }, restProps), {
    children: (0, import_jsx_runtime75.jsx)(Icon, {
      className: clsx("vkuiFloatingArrow__in", iconClassName2),
      style: iconStyle
    })
  }));
};
function getArrowPositionData(placement, coords = {
  x: 0,
  y: 0
}, offset5 = 0, isStaticOffset = false) {
  const withOffset = (isVerticalPlacement) => {
    const parsedCoords = {
      x: coords.x || 0,
      y: coords.y || 0
    };
    if (isVerticalPlacement) {
      return isStaticOffset ? offset5 : parsedCoords.y + offset5;
    } else {
      return isStaticOffset ? offset5 : parsedCoords.x + offset5;
    }
  };
  if (placement.startsWith("top")) {
    const xOffsetProp = getXOffsetProp(placement, isStaticOffset);
    return [
      "bottom",
      {
        top: "100%",
        [xOffsetProp]: withOffset(false)
      }
    ];
  } else if (placement.startsWith("right")) {
    const yOffsetProp = getYOffsetProp(placement, isStaticOffset);
    return [
      "left",
      {
        [yOffsetProp]: withOffset(true),
        left: 0
      }
    ];
  } else if (placement.startsWith("bottom")) {
    const xOffsetProp = getXOffsetProp(placement, isStaticOffset);
    return [
      void 0,
      {
        bottom: "100%",
        [xOffsetProp]: withOffset(false)
      }
    ];
  } else {
    const yOffsetProp = getYOffsetProp(placement, isStaticOffset);
    return [
      "right",
      {
        [yOffsetProp]: withOffset(true),
        right: 0
      }
    ];
  }
}
function getXOffsetProp(placement, isStaticOffset) {
  return placement.endsWith("end") && isStaticOffset ? "right" : "left";
}
function getYOffsetProp(placement, isStaticOffset) {
  return placement.endsWith("end") && isStaticOffset ? "bottom" : "top";
}

// node_modules/@vkontakte/vkui/dist/components/Popper/Popper.js
var Popper = (_param) => {
  var {
    // UseFloatingMiddlewaresBootstrapProps
    placement: placementProp = "bottom-start",
    sameWidth,
    hideWhenReferenceHidden,
    offsetByMainAxis = 8,
    offsetByCrossAxis = 0,
    arrow: arrow5,
    arrowHeight = DEFAULT_ARROW_HEIGHT,
    arrowPadding = DEFAULT_ARROW_PADDING,
    customMiddlewares,
    disableFlipMiddleware = false,
    disableShiftMiddleware = false,
    flipMiddlewareFallbackAxisSideDirection,
    overflowPadding,
    // UseFloatingProps
    autoUpdateOnTargetResize = false,
    autoUpdateOnAnimationFrame = false,
    strategy: strategyProp,
    // ArrowProps
    arrowProps,
    ArrowIcon: ArrowIcon2 = DefaultIcon,
    // rest
    targetRef,
    getRootRef,
    children,
    usePortal = true,
    onPlacementChange,
    onReferenceHiddenChange,
    zIndex,
    style
  } = _param, restProps = _object_without_properties(_param, [
    "placement",
    "sameWidth",
    "hideWhenReferenceHidden",
    "offsetByMainAxis",
    "offsetByCrossAxis",
    "arrow",
    "arrowHeight",
    "arrowPadding",
    "customMiddlewares",
    "disableFlipMiddleware",
    "disableShiftMiddleware",
    "flipMiddlewareFallbackAxisSideDirection",
    "overflowPadding",
    "autoUpdateOnTargetResize",
    "autoUpdateOnAnimationFrame",
    "strategy",
    "arrowProps",
    "ArrowIcon",
    "targetRef",
    "getRootRef",
    "children",
    "usePortal",
    "onPlacementChange",
    "onReferenceHiddenChange",
    "zIndex",
    "style"
  ]);
  const [arrowRef, setArrowRef] = React90.useState(null);
  const { strictPlacement, middlewares } = useFloatingMiddlewaresBootstrap({
    placement: placementProp,
    sameWidth,
    arrow: arrow5,
    arrowRef,
    arrowHeight,
    arrowPadding,
    offsetByMainAxis,
    offsetByCrossAxis,
    hideWhenReferenceHidden,
    customMiddlewares,
    disableFlipMiddleware,
    disableShiftMiddleware,
    flipMiddlewareFallbackAxisSideDirection,
    overflowPadding
  });
  const { x: floatingDataX, y: floatingDataY, strategy: floatingPositionStrategy, placement: resolvedPlacement, refs, middlewareData } = useFloating({
    placement: strictPlacement,
    strategy: strategyProp,
    middleware: middlewares,
    whileElementsMounted(...args) {
      return autoUpdateFloatingElement(...args, {
        elementResize: autoUpdateOnTargetResize,
        animationFrame: autoUpdateOnAnimationFrame
      });
    }
  });
  usePlacementChangeCallback(placementProp, resolvedPlacement, onPlacementChange);
  useReferenceHiddenChangeCallback(middlewareData.hide, onReferenceHiddenChange);
  const { arrow: arrowCoords } = middlewareData;
  const handleRootRef = useExternRef(refs.setFloating, getRootRef);
  useIsomorphicLayoutEffect(() => {
    refs.setReference("current" in targetRef ? targetRef.current : targetRef);
  }, [
    refs.setReference,
    targetRef
  ]);
  const dropdownStyle = typeof zIndex !== "undefined" ? {
    zIndex
  } : void 0;
  const dropdown = (0, import_jsx_runtime76.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    style: mergeStyle(dropdownStyle, style),
    baseClassName: "vkuiPopper__host",
    getRootRef: handleRootRef,
    baseStyle: convertFloatingDataToReactCSSProperties({
      strategy: floatingPositionStrategy,
      x: floatingDataX,
      y: floatingDataY,
      initialWidth: sameWidth ? null : void 0,
      middlewareData
    }),
    children: [
      arrow5 && (0, import_jsx_runtime76.jsx)(FloatingArrow, _object_spread_props(_object_spread({}, arrowProps), {
        coords: arrowCoords,
        placement: resolvedPlacement,
        getRootRef: setArrowRef,
        Icon: ArrowIcon2
      })),
      children
    ]
  }));
  return (0, import_jsx_runtime76.jsx)(AppRootPortal, {
    usePortal,
    children: dropdown
  });
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheetDropdownMenu.js
var warn13 = warnOnce("ActionSheet");
function getEl(ref) {
  return ref && "current" in ref ? ref.current : ref;
}
var ActionSheetDropdownMenu = (_param) => {
  var { children, toggleRef, closing, onClose, className, style, popupOffsetDistance = 0, placement, onAnimationStart, onAnimationEnd, allowClickPropagation = false, onClick } = _param, restProps = _object_without_properties(_param, [
    "children",
    "toggleRef",
    "closing",
    "onClose",
    "className",
    "style",
    "popupOffsetDistance",
    "placement",
    "onAnimationStart",
    "onAnimationEnd",
    "allowClickPropagation",
    "onClick"
  ]);
  const { document: document2 } = useDOM();
  const platform3 = usePlatform();
  const { sizeY } = useAdaptivityWithJSMediaQueries();
  const elementRef = React91.useRef(null);
  useEffectDev(() => {
    const toggleEl = getEl(toggleRef);
    if (!toggleEl) {
      warn13(`Свойство "toggleRef" не передано`, "error");
    }
  }, [
    toggleRef
  ]);
  const bodyClickListener = useEventListener("click", (e) => {
    const dropdownElement = elementRef === null || elementRef === void 0 ? void 0 : elementRef.current;
    if (dropdownElement && !dropdownElement.contains(e.target)) {
      onClose === null || onClose === void 0 ? void 0 : onClose();
    }
  });
  React91.useEffect(() => {
    setTimeout(() => {
      bodyClickListener.add(document2.body);
    });
  }, [
    bodyClickListener,
    document2
  ]);
  const targetRef = React91.useMemo(() => {
    if (isRefObject(toggleRef)) {
      return toggleRef;
    }
    return {
      current: toggleRef
    };
  }, [
    toggleRef
  ]);
  const handleClick = allowClickPropagation ? onClick : (event) => {
    stopPropagation(event);
    onClick === null || onClick === void 0 ? void 0 : onClick(event);
  };
  return (0, import_jsx_runtime77.jsx)(Popper, {
    targetRef,
    offsetByMainAxis: popupOffsetDistance,
    placement,
    className: clsx("vkuiActionSheet__host", platform3 === "ios" && "vkuiActionSheet__ios", "vkuiActionSheet__menu", closing ? "vkuiActionSheet__closing" : "vkuiActionSheet__opening", sizeY === "compact" && "vkuiActionSheet__sizeYCompact", className),
    style,
    getRootRef: elementRef,
    usePortal: false,
    onAnimationStart,
    onAnimationEnd,
    children: (0, import_jsx_runtime77.jsx)(FocusTrap, _object_spread_props(_object_spread({
      onClose
    }, restProps), {
      onClick: handleClick,
      children
    }))
  });
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheetDropdownSheet.js
var import_jsx_runtime78 = __toESM(require_jsx_runtime(), 1);
var React92 = __toESM(require_react(), 1);
var ActionSheetDropdownSheet = (_param) => {
  var {
    children,
    closing,
    // these 2 props are only omitted - ActionSheetDesktop compat
    toggleRef,
    className,
    onClick,
    allowClickPropagation = false
  } = _param, restProps = _object_without_properties(_param, [
    "children",
    "closing",
    "toggleRef",
    "className",
    "onClick",
    "allowClickPropagation"
  ]);
  const { sizeY } = useAdaptivityWithJSMediaQueries();
  const platform3 = usePlatform();
  const handleClick = allowClickPropagation ? onClick : (event) => {
    stopPropagation(event);
    onClick === null || onClick === void 0 ? void 0 : onClick(event);
  };
  return (0, import_jsx_runtime78.jsx)(FocusTrap, _object_spread_props(_object_spread({}, restProps), {
    onClick: handleClick,
    className: clsx("vkuiActionSheet__host", platform3 === "ios" && "vkuiActionSheet__ios", closing ? "vkuiActionSheet__closing" : "vkuiActionSheet__opening", sizeY === "compact" && "vkuiActionSheet__sizeYCompact", className),
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheet.js
var ActionSheet = (_param) => {
  var { children, className, title, description, style, iosCloseItem, popupOffsetDistance, placement, mode: modeProp, onClose } = _param, restProps = _object_without_properties(_param, [
    "children",
    "className",
    "title",
    "description",
    "style",
    "iosCloseItem",
    "popupOffsetDistance",
    "placement",
    "mode",
    "onClose"
  ]);
  const platform3 = usePlatform();
  const [closingBy, setClosingBy] = React93.useState(void 0);
  const onCloseWithOther = React93.useCallback(() => setClosingBy("other"), []);
  const actionCallbackRef = React93.useRef(noop);
  const [animationState, animationHandlers] = useCSSKeyframesAnimationController(closingBy !== void 0 ? "exit" : "enter", {
    onExited() {
      onClose({
        closedBy: closingBy || "other"
      });
      actionCallbackRef.current();
      actionCallbackRef.current = noop;
    }
  });
  const { isDesktop } = useAdaptivityWithJSMediaQueries();
  const mode = modeProp !== null && modeProp !== void 0 ? modeProp : isDesktop ? "menu" : "sheet";
  useScrollLock(mode === "sheet");
  const onItemClick = React93.useCallback(({ action, immediateAction, autoClose, isCancelItem }) => (event) => {
    event.persist();
    immediateAction && immediateAction(event);
    if (autoClose) {
      if (action) {
        actionCallbackRef.current = () => action(event);
      }
      setClosingBy(isCancelItem ? "cancel-item" : "action-item");
    } else {
      action && action(event);
    }
  }, []);
  const contextValue = React93.useMemo(() => ({
    onItemClick,
    mode,
    onClose: onCloseWithOther
  }), [
    mode,
    onCloseWithOther,
    onItemClick
  ]);
  const DropdownComponent = mode === "menu" ? ActionSheetDropdownMenu : ActionSheetDropdownSheet;
  const dropdownProps = mode === "menu" ? Object.assign(restProps, {
    popupOffsetDistance,
    placement
  }) : restProps;
  const actionSheet = (0, import_jsx_runtime79.jsx)(ActionSheetContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime79.jsxs)(DropdownComponent, _object_spread_props(_object_spread({
      closing: Boolean(closingBy),
      role: "dialog",
      "aria-modal": "true",
      autoFocus: animationState === "entered"
    }, dropdownProps, animationHandlers), {
      onClose: onCloseWithOther,
      className: mode === "menu" ? className : void 0,
      style: mode === "menu" ? style : void 0,
      children: [
        (0, import_jsx_runtime79.jsxs)("div", {
          className: "vkuiActionSheet__contentWrapper",
          children: [
            (title || description) && (0, import_jsx_runtime79.jsxs)("div", {
              className: "vkuiActionSheet__header",
              children: [
                title && (0, import_jsx_runtime79.jsx)(Footnote, {
                  weight: "2",
                  className: "vkuiActionSheet__title",
                  children: title
                }),
                description && (0, import_jsx_runtime79.jsx)(Footnote, {
                  className: "vkuiActionSheet__description",
                  children: description
                })
              ]
            }),
            children
          ]
        }),
        platform3 === "ios" && mode === "sheet" && (0, import_jsx_runtime79.jsx)("div", {
          className: "vkuiActionSheet__closeItemWrapperIos",
          children: iosCloseItem !== null && iosCloseItem !== void 0 ? iosCloseItem : (0, import_jsx_runtime79.jsx)(ActionSheetDefaultIosCloseItem, {})
        })
      ]
    }))
  });
  return (0, import_jsx_runtime79.jsx)(AppRootPortal, {
    children: (0, import_jsx_runtime79.jsx)(PopoutWrapper, {
      noBackground: mode === "menu",
      closing: Boolean(closingBy),
      alignY: "bottom",
      className,
      style,
      onClick: onCloseWithOther,
      strategy: "fixed",
      children: actionSheet
    })
  });
};

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/ScreenSpinner.js
var import_jsx_runtime85 = __toESM(require_jsx_runtime(), 1);
var React99 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/ScreenSpinnerContainer.js
var import_jsx_runtime80 = __toESM(require_jsx_runtime(), 1);

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/context.js
var React94 = __toESM(require_react(), 1);
var ScreenSpinnerContext = React94.createContext({
  state: "loading",
  label: void 0,
  customIcon: void 0
});

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/ScreenSpinnerContainer.js
var stateClassNames = {
  cancelable: "vkuiScreenSpinner__stateCancelable",
  done: "vkuiScreenSpinner__stateDone",
  error: "vkuiScreenSpinner__stateError",
  custom: "vkuiScreenSpinner__stateCustom"
};
var modeClassNames = {
  shadow: "vkuiScreenSpinner__modeShadow",
  overlay: "vkuiScreenSpinner__modeOverlay"
};
var ScreenSpinnerContainer = (_param) => {
  var { state = "loading", mode = "shadow", customIcon, label, children, visibilityDelay } = _param, restProps = _object_without_properties(_param, [
    "state",
    "mode",
    "customIcon",
    "label",
    "children",
    "visibilityDelay"
  ]);
  return (0, import_jsx_runtime80.jsx)(ScreenSpinnerContext.Provider, {
    value: {
      state,
      label,
      customIcon
    },
    children: (0, import_jsx_runtime80.jsxs)(RootComponent, _object_spread_props(_object_spread({
      baseClassName: clsx("vkuiScreenSpinner__host", modeClassNames[mode], state !== "loading" && stateClassNames[state], hasReactNode(label) && "vkuiScreenSpinner__hasLabel", visibilityDelay && "vkuistyles__visibilityDelay")
    }, restProps), {
      children: [
        (0, import_jsx_runtime80.jsx)("div", {
          className: "vkuiScreenSpinner__iconSlot",
          children
        }),
        hasReactNode(label) && (0, import_jsx_runtime80.jsx)(Footnote, {
          className: "vkuiScreenSpinner__label",
          "aria-hidden": true,
          children: label
        })
      ]
    }))
  });
};

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/ScreenSpinnerLoader.js
var import_jsx_runtime81 = __toESM(require_jsx_runtime(), 1);
var React95 = __toESM(require_react(), 1);
var ScreenSpinnerLoader = (_param) => {
  var { children } = _param, restProps = _object_without_properties(_param, [
    "children"
  ]);
  const { label } = React95.useContext(ScreenSpinnerContext);
  const a11yText = children !== null && children !== void 0 ? children : label;
  return (0, import_jsx_runtime81.jsx)(Spinner, _object_spread_props(_object_spread({
    className: clsx("vkuiScreenSpinner__spinner", !label && "vkuiScreenSpinner__spinnerTransition"),
    size: "xl",
    noColor: true
  }, restProps), {
    children: a11yText
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/ScreenSpinnerSwapIcon.js
var import_jsx_runtime84 = __toESM(require_jsx_runtime(), 1);
var React98 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/Icon48CancelCircle.js
var import_jsx_runtime82 = __toESM(require_jsx_runtime(), 1);
var React96 = __toESM(require_react(), 1);
var Icon48CancelCircle = (props) => (0, import_jsx_runtime82.jsx)("svg", _object_spread_props(_object_spread({
  className: "vkuiIcon",
  width: "48",
  height: "48",
  viewBox: "0 0 48 48",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, props), {
  children: (0, import_jsx_runtime82.jsx)("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M40 24c0 8.837-7.163 16-16 16S8 32.837 8 24 15.163 8 24 8s16 7.163 16 16Zm-10.08-4.33a1.125 1.125 0 0 0-1.59-1.59L24 22.409l-4.33-4.33a1.125 1.125 0 0 0-1.59 0l-.101.116a1.125 1.125 0 0 0 .1 1.476L22.41 24l-4.33 4.33a1.125 1.125 0 0 0 1.591 1.59L24 25.591l4.33 4.33c.439.439 1.151.439 1.59 0l.101-.116a1.125 1.125 0 0 0-.1-1.476L25.59 24l4.33-4.33Z",
    fill: "currentColor"
  })
}));

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/Icon48DoneOutline.js
var import_jsx_runtime83 = __toESM(require_jsx_runtime(), 1);
var React97 = __toESM(require_react(), 1);
var Icon48DoneOutline = (props) => (0, import_jsx_runtime83.jsx)("svg", _object_spread_props(_object_spread({
  className: "vkuiIcon",
  width: "48",
  height: "48",
  viewBox: "0 0 48 48",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, props), {
  children: (0, import_jsx_runtime83.jsx)("path", {
    d: "M9 24L19 34L39 14",
    stroke: "currentColor",
    strokeWidth: "3.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })
}));

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/ScreenSpinnerSwapIcon.js
var ScreenSpinnerCancelIcon = (_param) => {
  var { onKeyDown, "aria-label": ariaLabel = "Отменить" } = _param, restProps = _object_without_properties(_param, [
    "onKeyDown",
    "aria-label"
  ]);
  const handlers = mergeCalls({
    onKeyDown: clickByKeyboardHandler
  }, {
    onKeyDown
  });
  let clickableProps = _object_spread_props(_object_spread({}, handlers), {
    "tabIndex": 0,
    "role": "button",
    "aria-label": ariaLabel
  });
  return (0, import_jsx_runtime84.jsx)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: "vkuiScreenSpinner__icon"
  }, clickableProps, restProps), {
    children: (0, import_jsx_runtime84.jsx)(Icon24Cancel, {})
  }));
};
var ScreenSpinnerSwapIcon = (_param) => {
  var { cancelLabel } = _param, restProps = _object_without_properties(_param, [
    "cancelLabel"
  ]);
  const { state, customIcon } = React98.useContext(ScreenSpinnerContext);
  if (state === "cancelable") {
    return (0, import_jsx_runtime84.jsx)(ScreenSpinnerCancelIcon, _object_spread({
      "aria-label": cancelLabel
    }, restProps));
  }
  const getContent = () => {
    if (state === "custom") {
      return customIcon;
    }
    const Icon = {
      loading: () => null,
      done: Icon48DoneOutline,
      error: Icon48CancelCircle
    }[state];
    return (0, import_jsx_runtime84.jsx)(Icon, {});
  };
  return (0, import_jsx_runtime84.jsx)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: "vkuiScreenSpinner__icon"
  }, restProps), {
    children: getContent()
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/ScreenSpinner.js
var ScreenSpinner = (_param) => {
  var { style, className, state = "loading", onClick, cancelLabel, mode, label, customIcon, usePortal, visibilityDelay } = _param, restProps = _object_without_properties(_param, [
    "style",
    "className",
    "state",
    "onClick",
    "cancelLabel",
    "mode",
    "label",
    "customIcon",
    "usePortal",
    "visibilityDelay"
  ]);
  useScrollLock();
  return (0, import_jsx_runtime85.jsx)(AppRootPortal, {
    usePortal,
    children: (0, import_jsx_runtime85.jsx)(PopoutWrapper, {
      className,
      style,
      noBackground: true,
      strategy: "fixed",
      children: (0, import_jsx_runtime85.jsxs)(ScreenSpinnerContainer, {
        state,
        mode,
        label,
        customIcon,
        visibilityDelay,
        children: [
          (0, import_jsx_runtime85.jsx)(ScreenSpinnerLoader, _object_spread({}, restProps)),
          (0, import_jsx_runtime85.jsx)(ScreenSpinnerSwapIcon, {
            onClick,
            cancelLabel
          })
        ]
      })
    })
  });
};
ScreenSpinner.Container = ScreenSpinnerContainer;
ScreenSpinner.Loader = ScreenSpinnerLoader;
ScreenSpinner.SwapIcon = ScreenSpinnerSwapIcon;
if (true) {
  defineComponentDisplayNames(ScreenSpinner.Container, "ScreenSpinner.Container");
  defineComponentDisplayNames(ScreenSpinner.Loader, "ScreenSpinner.Loader");
  defineComponentDisplayNames(ScreenSpinner.SwapIcon, "ScreenSpinner.SwapIcon");
}

// node_modules/@vkontakte/vkui/dist/components/Snackbar/Snackbar.js
var import_jsx_runtime87 = __toESM(require_jsx_runtime(), 1);
var React101 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useGlobalEscKeyDown.js
var EVENT_OPTIONS2 = {
  passive: true,
  capture: true
};
var useGlobalEscKeyDown = (init, callback) => {
  const { document: document2 } = useDOM();
  useIsomorphicLayoutEffect(() => {
    if (!document2 || !init || !callback) {
      return;
    }
    const handleKeyDown = (event) => {
      if (pressedKey(event) === Keys.ESCAPE) {
        callback(event);
      }
    };
    document2.addEventListener("keydown", handleKeyDown, EVENT_OPTIONS2);
    return () => {
      document2.removeEventListener("keydown", handleKeyDown, EVENT_OPTIONS2);
    };
  }, [
    init,
    document2,
    callback
  ]);
};

// node_modules/@vkontakte/vkui/dist/components/Snackbar/subcomponents/Basic/Basic.js
var import_jsx_runtime86 = __toESM(require_jsx_runtime(), 1);
var React100 = __toESM(require_react(), 1);
var stylesLayout = {
  none: "vkuiBasic__layoutNone",
  vertical: "vkuiBasic__layoutVertical",
  horizontal: "vkuiBasic__layoutHorizontal"
};
var sizeYClassNames15 = {
  none: "vkuiBasic__sizeYNone",
  regular: "vkuiBasic__sizeYRegular"
};
function Basic(_param) {
  var { layout: layoutProps, action, after, before, mode, subtitle, children } = _param, restProps = _object_without_properties(_param, [
    "layout",
    "action",
    "after",
    "before",
    "mode",
    "subtitle",
    "children"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const layout = after || subtitle ? "vertical" : "none";
  return (0, import_jsx_runtime86.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiBasic__body", stylesLayout[layoutProps || layout], sizeY !== "compact" && sizeYClassNames15[sizeY], mode === "dark" && "vkuiBasic__modeDark"),
    children: [
      before && (0, import_jsx_runtime86.jsx)("div", {
        className: "vkuiBasic__before",
        children: before
      }),
      (0, import_jsx_runtime86.jsxs)("div", {
        className: "vkuiBasic__content",
        children: [
          (0, import_jsx_runtime86.jsx)(Paragraph, {
            className: "vkuiBasic__contentText",
            children
          }),
          subtitle && !action && (0, import_jsx_runtime86.jsx)(Subhead, {
            className: "vkuiBasic__contentSubtitle",
            children: subtitle
          }),
          action && !subtitle && (0, import_jsx_runtime86.jsx)("div", {
            className: "vkuiBasic__action",
            children: action
          })
        ]
      }),
      after && (0, import_jsx_runtime86.jsx)("div", {
        className: "vkuiBasic__after",
        children: after
      })
    ]
  }));
}

// node_modules/@vkontakte/vkui/dist/components/Snackbar/utils.js
function resolveOffsetYCssStyle(placement, offsetY) {
  if (offsetY === void 0) {
    return void 0;
  }
  switch (placement) {
    case "top-start":
    case "top":
    case "top-end":
      return {
        top: offsetY
      };
    case "bottom-start":
    case "bottom":
    case "bottom-end":
      return {
        bottom: offsetY
      };
  }
}
function revertRtlValue(value, isRtl) {
  return isRtl ? -1 * value : value;
}
function getInitialShiftData(width, height, mediaQueries) {
  return {
    shifted: false,
    direction: null,
    isDesktop: mediaQueries.smallTabletPlus.matches,
    x: 0,
    y: 0,
    width,
    height
  };
}
function getMovedShiftData(placement, shiftData, nextShift, isRtl = false) {
  if (shiftData.isDesktop) {
    if (placement.endsWith("start")) {
      shiftData.x = isRtl ? rubberbandIfOutOfBounds(nextShift.x, 0, shiftData.width) : rubberbandIfOutOfBounds(nextShift.x, -shiftData.width, 0);
    } else if (placement.endsWith("end")) {
      shiftData.x = isRtl ? rubberbandIfOutOfBounds(nextShift.x, -shiftData.width, 0) : rubberbandIfOutOfBounds(nextShift.x, 0, shiftData.width);
    }
    if (placement.startsWith("bottom")) {
      shiftData.y = rubberbandIfOutOfBounds(nextShift.y, 0, shiftData.height);
    }
  } else if (placement.startsWith("bottom")) {
    shiftData.x = nextShift.x;
    const movingToLeft = nextShift.x < 0 ? -1 : null;
    const movingToRight = nextShift.x > 0 ? 1 : null;
    shiftData.direction = movingToLeft || movingToRight;
  }
  if (placement.startsWith("top")) {
    shiftData.y = rubberbandIfOutOfBounds(nextShift.y, -shiftData.height, 0);
  }
  shiftData.shifted = true;
  return shiftData;
}
var MINIMUM_PAN_GESTURE_FOR_TRIGGER_CLOSE = 200;
function shouldBeClosedByShiftData(placement, shiftData, relativeClientRect, velocity, isRtl = false) {
  if (!shiftData.shifted) {
    return false;
  }
  const shouldBeClosedThreshold = {
    x: false,
    y: false
  };
  const shouldBeClosedByVelocity = {
    x: false,
    y: false
  };
  if (shiftData.isDesktop) {
    if (placement.endsWith("start")) {
      shouldBeClosedThreshold.x = revertRtlValue(relativeClientRect.x, isRtl) < -relativeClientRect.width / 2;
      shouldBeClosedByVelocity.x = revertRtlValue(relativeClientRect.x, isRtl) < 0 ? revertRtlValue(velocity.x, isRtl) < revertRtlValue(-MINIMUM_PAN_GESTURE_FOR_TRIGGER_CLOSE, isRtl) : false;
    } else if (placement.endsWith("end")) {
      shouldBeClosedThreshold.x = revertRtlValue(relativeClientRect.x, isRtl) > relativeClientRect.width / 2;
      shouldBeClosedByVelocity.x = revertRtlValue(relativeClientRect.x, isRtl) > 0 ? revertRtlValue(velocity.x, isRtl) > revertRtlValue(MINIMUM_PAN_GESTURE_FOR_TRIGGER_CLOSE, isRtl) : false;
    }
    if (placement.startsWith("bottom")) {
      shouldBeClosedThreshold.y = relativeClientRect.y > relativeClientRect.height / 2;
      shouldBeClosedByVelocity.y = relativeClientRect.y > 0 ? velocity.y > MINIMUM_PAN_GESTURE_FOR_TRIGGER_CLOSE : false;
    }
  } else if (placement.startsWith("bottom")) {
    shouldBeClosedThreshold.x = relativeClientRect.x < -relativeClientRect.width / 2 || relativeClientRect.x > relativeClientRect.width / 2;
    shouldBeClosedByVelocity.x = relativeClientRect.x < 0 && velocity.x < -MINIMUM_PAN_GESTURE_FOR_TRIGGER_CLOSE || relativeClientRect.x > 0 && velocity.x > MINIMUM_PAN_GESTURE_FOR_TRIGGER_CLOSE;
  }
  if (placement.startsWith("top")) {
    shouldBeClosedThreshold.y = relativeClientRect.y < -relativeClientRect.height / 2;
    shouldBeClosedByVelocity.y = relativeClientRect.y < 0 ? velocity.y < -MINIMUM_PAN_GESTURE_FOR_TRIGGER_CLOSE : false;
  }
  return shouldBeClosedThreshold.x || shouldBeClosedByVelocity.x || shouldBeClosedThreshold.y || /* istanbul ignore next: подсвечивает жёлтым и пишет "branch not covered" */
  shouldBeClosedByVelocity.y;
}

// node_modules/@vkontakte/vkui/dist/components/Snackbar/Snackbar.js
var placementClassNames2 = {
  "top-start": "vkuiSnackbar__placementTopStart",
  "top": "vkuiSnackbar__placementTop",
  "top-end": "vkuiSnackbar__placementTopEnd",
  "bottom-start": "vkuiSnackbar__placementBottomStart",
  "bottom": "vkuiSnackbar__placementBottom",
  "bottom-end": "vkuiSnackbar__placementBottomEnd"
};
var animationStateClassNames = {
  enter: "vkuiSnackbar__stateEnter",
  entering: "vkuiSnackbar__stateEntering",
  entered: "vkuiSnackbar__stateEntered",
  exit: "vkuiSnackbar__stateExit",
  exiting: "vkuiSnackbar__stateExiting",
  exited: void 0
};
var Snackbar = (_param) => {
  var { placement = "bottom-start", children, layout, action, before, after, duration = 4e3, onActionClick: onActionClickProp, onClose, mode = "default", subtitle, offsetY, getRootRef: getRootRefProp, slotProps } = _param, restProps = _object_without_properties(_param, [
    "placement",
    "children",
    "layout",
    "action",
    "before",
    "after",
    "duration",
    "onActionClick",
    "onClose",
    "mode",
    "subtitle",
    "offsetY",
    "getRootRef",
    "slotProps"
  ]);
  const _useMergeProps = useMergeProps(_object_spread({
    getRootRef: getRootRefProp
  }, restProps), slotProps === null || slotProps === void 0 ? void 0 : slotProps.root), { getRootRef } = _useMergeProps, rootRest = _object_without_properties(_useMergeProps, [
    "getRootRef"
  ]);
  const _useMergeProps1 = useMergeProps({
    onClick: onActionClickProp
  }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.action), { onClick: onActionClick } = _useMergeProps1, actionRest = _object_without_properties(_useMergeProps1, [
    "onClick"
  ]);
  const platform3 = usePlatform();
  const [open, setOpen] = React101.useState(true);
  const [touched, setTouched] = React101.useState(false);
  const direction = useConfigDirection();
  const isRtl = direction === "rtl";
  const rootRef = useExternRef(getRootRef);
  const focused = useFocusWithin(rootRef);
  const inRef = React101.useRef(null);
  const panGestureRecognizer = React101.useRef(null);
  const shiftDataRef = React101.useRef(null);
  const rafRef = React101.useRef(null);
  const closeTimeoutIdRef = React101.useRef(void 0);
  const mediaQueries = useMediaQueries();
  const [animationState, animationHandlers] = useCSSKeyframesAnimationController(open ? "enter" : "exit", {
    onExited: onClose
  });
  const clearRAF = React101.useCallback(() => {
    if (rafRef.current !== null) {
      cancelAnimationFrame(rafRef.current);
      rafRef.current = null;
    }
  }, []);
  const updateShiftAxisCSSProperties = React101.useCallback((x, y, direction2) => {
    rafRef.current = requestAnimationFrame(() => {
      if (rootRef.current) {
        x === null ? rootRef.current.style.removeProperty("--vkui_internal--snackbar_shift_x") : rootRef.current.style.setProperty("--vkui_internal--snackbar_shift_x", `${x}px`);
        y === null ? rootRef.current.style.removeProperty("--vkui_internal--snackbar_shift_y") : rootRef.current.style.setProperty("--vkui_internal--snackbar_shift_y", `${y}px`);
        direction2 === null ? rootRef.current.style.removeProperty("--vkui_internal--snackbar_direction") : (
          /* istanbul ignore next: TODO чтобы протестировать кейс, нужно мокать useMediaQueries(), чтобы перебивать mediaQueries.smallTabletPlus.matches */
          rootRef.current.style.setProperty("--vkui_internal--snackbar_direction", `${direction2}`)
        );
      }
    });
  }, [
    rootRef
  ]);
  const close = React101.useCallback(() => {
    setOpen(false);
  }, []);
  const handleActionClick = (event) => {
    close();
    if (action) {
      onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick(event);
    }
  };
  const handleTouchStart = (event) => {
    panGestureRecognizer.current = new UIPanGestureRecognizer();
    panGestureRecognizer.current.setStartCoords(event.nativeEvent);
    shiftDataRef.current = getInitialShiftData(rootRef.current.offsetWidth, rootRef.current.offsetHeight, mediaQueries);
    setTouched(true);
  };
  const handleTouchMove = (event) => {
    if (shiftDataRef.current && panGestureRecognizer.current) {
      panGestureRecognizer.current.setInitialTimeOnce();
      panGestureRecognizer.current.setEndCoords(event.nativeEvent);
      shiftDataRef.current = getMovedShiftData(placement, shiftDataRef.current, panGestureRecognizer.current.delta(), isRtl);
      if (shiftDataRef.current.shifted) {
        updateShiftAxisCSSProperties(shiftDataRef.current.x, shiftDataRef.current.y, shiftDataRef.current.direction);
      }
    }
  };
  const handleTouchEnd = () => {
    if (touched && shiftDataRef.current && panGestureRecognizer.current && shouldBeClosedByShiftData(placement, shiftDataRef.current, getRelativeBoundingClientRect(rootRef.current, inRef.current), panGestureRecognizer.current.velocity(), isRtl)) {
      close();
    }
    setTouched(false);
  };
  useIsomorphicLayoutEffect(function closeAfterDelay() {
    if (!open || focused || touched || animationState !== "entered") {
      return;
    }
    closeTimeoutIdRef.current = setTimeout(close, duration);
    return function preventCloseAfterDelayOnUnmount() {
      clearTimeout(closeTimeoutIdRef.current);
    };
  }, [
    open,
    focused,
    touched,
    animationState,
    close,
    duration
  ]);
  useIsomorphicLayoutEffect(function clearUserInteractionDataAfterTouchEnd() {
    if (!touched) {
      clearRAF();
      shiftDataRef.current = null;
      panGestureRecognizer.current = null;
      if (open) {
        updateShiftAxisCSSProperties(null, null, null);
      }
    }
  }, [
    touched,
    open,
    updateShiftAxisCSSProperties,
    clearRAF
  ]);
  React101.useEffect(() => clearRAF, [
    clearRAF
  ]);
  useGlobalEscKeyDown(open, close);
  if (animationState === "exited") {
    return null;
  }
  return (0, import_jsx_runtime87.jsx)(RootComponent, _object_spread_props(_object_spread({
    role: "presentation",
    baseClassName: clsx("vkuiSnackbar__host", platform3 === "ios" && "vkuiSnackbar__ios", touched && "vkuiSnackbar__touched", placementClassNames2[placement], animationStateClassNames[animationState], isRtl && "vkuiSnackbar__rtl"),
    baseStyle: resolveOffsetYCssStyle(placement, offsetY),
    getRootRef: rootRef
  }, rootRest), {
    children: (0, import_jsx_runtime87.jsx)("div", _object_spread_props(_object_spread({
      role: "alert",
      className: "vkuiSnackbar__in",
      ref: inRef,
      // mobile
      onTouchStart: handleTouchStart,
      onTouchMove: handleTouchMove,
      onTouchEnd: handleTouchEnd,
      // desktop
      onMouseDown: handleTouchStart,
      onMouseMove: handleTouchMove,
      onMouseUp: handleTouchEnd,
      onMouseLeave: handleTouchEnd
    }, animationHandlers), {
      children: (0, import_jsx_runtime87.jsx)(Basic, {
        mode,
        layout,
        before,
        after,
        subtitle,
        action: action && (0, import_jsx_runtime87.jsx)(Button, _object_spread_props(_object_spread({
          align: "left",
          mode: "link",
          appearance: mode === "dark" ? (
            /* istanbul ignore next: проверяется в e2e */
            "overlay"
          ) : "accent",
          size: "s",
          onClick: handleActionClick
        }, actionRest), {
          children: action
        })),
        children
      })
    }))
  }));
};
Snackbar.Basic = Basic;

// node_modules/@vkontakte/vkui/dist/components/Tooltip/Tooltip.js
var import_jsx_runtime91 = __toESM(require_jsx_runtime(), 1);
var React106 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useReferenceElement.js
var import_jsx_runtime88 = __toESM(require_jsx_runtime(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/usePatchChildren.js
var React102 = __toESM(require_react(), 1);
var warn14 = warnOnce("usePatchChildren");
var usePatchChildren = (children, injectProps, externRef) => {
  const isValidElementResult = isValidNotReactFragmentElement(children);
  const isDOMTypeElementResult = isValidElementResult && isDOMTypeElement(children);
  const isForwardedRefElementResult = isValidElementResult && isForwardRefElement(children);
  const shouldUseRef = isDOMTypeElementResult || isForwardedRefElementResult;
  const childRef = useExternRef(shouldUseRef ? children.ref : isValidElementResult ? children.props.getRootRef : void 0, externRef);
  const mergedEventsByInjectProps = getMergedSameEventsByProps(injectProps ? injectProps : {}, isValidElementResult ? children.props : {});
  const props = shouldUseRef ? _object_spread({
    ref: childRef
  }, injectProps, mergedEventsByInjectProps) : isValidElementResult ? _object_spread({
    getRootRef: childRef
  }, injectProps, mergedEventsByInjectProps) : void 0;
  const patchedChildren = isValidElementResult ? React102.cloneElement(children, props) : children;
  useEffectDev(() => {
    if (!childRef.current && !shouldUseRef) {
      warn14("Кажется, в children передан компонент, который не поддерживает свойство getRootRef. Мы не можем получить ссылку на корневой dom-элемент этого компонента", "error");
    }
  }, [
    isValidElementResult ? children.type : null,
    shouldUseRef,
    childRef
  ]);
  return [
    childRef,
    patchedChildren
  ];
};

// node_modules/@vkontakte/vkui/dist/hooks/useReferenceElement.js
var useReferenceElement = (...args) => {
  const [children, injectProps, externRef] = args;
  const child = isValidNotReactFragmentElement(children) ? children : (0, import_jsx_runtime88.jsx)("span", {
    children
  });
  const [, patchedChild] = usePatchChildren(child, injectProps, externRef);
  return patchedChild;
};

// node_modules/@vkontakte/vkui/dist/components/Tooltip/useTooltip.js
var import_jsx_runtime90 = __toESM(require_jsx_runtime(), 1);
var React105 = __toESM(require_react(), 1);
var import_react13 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useFloatingElement.js
var React103 = __toESM(require_react(), 1);
var import_react12 = __toESM(require_react(), 1);
var useFloatingElement = ({
  // useFloatingMiddlewaresBootstrap
  placement = "bottom-start",
  arrow: arrow5,
  arrowHeight,
  arrowPadding,
  sameWidth,
  offsetByMainAxis = 0,
  offsetByCrossAxis = 0,
  customMiddlewares,
  hideWhenReferenceHidden,
  disableFlipMiddleware = false,
  disableShiftMiddleware = false,
  overflowPadding,
  // useFloatingWithInteractions
  trigger,
  hoverDelay,
  closeAfterClick,
  disabled,
  disableInteractive,
  disableCloseOnClickOutside,
  disableCloseOnEscKey,
  defaultShown,
  shown: shownProp,
  onShownChange,
  onShownChanged,
  strategy,
  onReferenceHiddenChange,
  onPlacementChange,
  renderFloatingComponent,
  externalFloatingElementRef,
  remapReferenceProps
}) => {
  const [arrowRef, setArrowRef] = React103.useState(null);
  const { middlewares, strictPlacement } = useFloatingMiddlewaresBootstrap({
    placement,
    offsetByMainAxis,
    offsetByCrossAxis,
    customMiddlewares,
    hideWhenReferenceHidden,
    sameWidth,
    arrow: arrow5,
    arrowRef,
    arrowPadding,
    arrowHeight,
    disableFlipMiddleware,
    disableShiftMiddleware,
    overflowPadding
  });
  const { placement: resolvedPlacement, shown, willBeHide, refs, referenceProps, floatingProps, middlewareData, onClose, onRestoreFocus, onEscapeKeyDown } = useFloatingWithInteractions({
    middlewares,
    strategy,
    placement: strictPlacement,
    trigger,
    hoverDelay,
    closeAfterClick,
    disabled,
    disableInteractive,
    disableCloseOnClickOutside,
    disableCloseOnEscKey,
    defaultShown,
    shown: shownProp,
    onShownChange,
    onShownChanged
  });
  const resultRef = useExternRef(externalFloatingElementRef, refs.setFloating);
  usePlacementChangeCallback(placement, resolvedPlacement, onPlacementChange);
  useReferenceHiddenChangeCallback(middlewareData.hide, onReferenceHiddenChange);
  const component2 = renderFloatingComponent({
    shown,
    willBeHide,
    floatingProps,
    floatingRef: resultRef,
    middlewareData,
    placement: resolvedPlacement,
    onClose,
    onRestoreFocus,
    setArrowRef
  });
  useGlobalEscKeyDown(shown, onEscapeKeyDown);
  const remappedReferenceProps = (0, import_react12.useMemo)(() => remapReferenceProps ? remapReferenceProps(_object_spread_props(_object_spread({}, referenceProps), {
    shown
  })) : referenceProps, [
    remapReferenceProps,
    shown,
    referenceProps
  ]);
  return {
    anchorRef: refs.setReference,
    anchorProps: remappedReferenceProps,
    component: component2
  };
};

// node_modules/@vkontakte/vkui/dist/components/TooltipBase/TooltipBase.js
var import_jsx_runtime89 = __toESM(require_jsx_runtime(), 1);
var React104 = __toESM(require_react(), 1);
var TOOLTIP_MAX_WIDTH = 220;
var stylesAppearance3 = {
  accent: "vkuiTooltipBase__appearanceAccent",
  white: "vkuiTooltipBase__appearanceWhite",
  black: "vkuiTooltipBase__appearanceBlack",
  inversion: "vkuiTooltipBase__appearanceInversion"
};
var TooltipBase = (_param) => {
  var { appearance = "accent", arrowProps, ArrowIcon: ArrowIcon2 = DefaultIcon, description, title, titleId, maxWidth = TOOLTIP_MAX_WIDTH, closeIconLabel = "Закрыть", onCloseIconClick, className } = _param, restProps = _object_without_properties(_param, [
    "appearance",
    "arrowProps",
    "ArrowIcon",
    "description",
    "title",
    "titleId",
    "maxWidth",
    "closeIconLabel",
    "onCloseIconClick",
    "className"
  ]);
  return (0, import_jsx_runtime89.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiTooltipBase__host", appearance !== "neutral" && stylesAppearance3[appearance], className),
    role: "tooltip",
    children: [
      arrowProps && (0, import_jsx_runtime89.jsx)(FloatingArrow, _object_spread_props(_object_spread({}, arrowProps), {
        iconClassName: clsx("vkuiTooltipBase__arrow", arrowProps.iconClassName),
        Icon: ArrowIcon2
      })),
      (0, import_jsx_runtime89.jsxs)("div", {
        className: "vkuiTooltipBase__content",
        style: maxWidth !== null ? {
          maxWidth
        } : void 0,
        children: [
          (0, import_jsx_runtime89.jsxs)("div", {
            children: [
              hasReactNode(title) && (0, import_jsx_runtime89.jsx)(Subhead, {
                id: titleId,
                className: "vkuiTooltipBase__title",
                weight: "2",
                children: title
              }),
              hasReactNode(description) && (0, import_jsx_runtime89.jsx)(Subhead, {
                className: "vkuiTooltipBase__description",
                children: description
              })
            ]
          }),
          typeof onCloseIconClick === "function" && (0, import_jsx_runtime89.jsxs)(Tappable, {
            Component: "button",
            className: "vkuiTooltipBase__closeButton",
            hoverMode: "opacity",
            activeMode: "opacity",
            onClick: onCloseIconClick,
            children: [
              (0, import_jsx_runtime89.jsx)(VisuallyHidden, {
                children: closeIconLabel
              }),
              (0, import_jsx_runtime89.jsx)(Icon16Cancel, {
                display: "block"
              })
            ]
          })
        ]
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Tooltip/useTooltip.js
var useTooltip = (_param) => {
  var {
    // UseFloatingMiddlewaresBootstrapOptions
    placement: placementProp = "bottom",
    arrowPadding = 10,
    arrowHeight = 8,
    offsetByMainAxis = 8,
    offsetByCrossAxis = 0,
    hideWhenReferenceHidden,
    disableFlipMiddleware = false,
    disableShiftMiddleware = false,
    disableTriggerOnFocus = false,
    onReferenceHiddenChange,
    overflowPadding,
    // useFloatingWithInteractions
    defaultShown,
    shown: shownProp,
    onShownChange,
    hoverDelay = 150,
    strategy,
    // инверсированные св-ва для useFloatingWithInteractions
    enableInteractive = false,
    disableArrow = false,
    disableCloseAfterClick = false,
    // AppRootProps
    usePortal,
    // TooltipBaseProps
    id: idProp,
    getRootRef,
    appearance = "neutral",
    style: styleProp,
    className,
    zIndex = "var(--vkui--z_index_popout)",
    closable,
    onPlacementChange
  } = _param, popperProps = _object_without_properties(_param, [
    "placement",
    "arrowPadding",
    "arrowHeight",
    "offsetByMainAxis",
    "offsetByCrossAxis",
    "hideWhenReferenceHidden",
    "disableFlipMiddleware",
    "disableShiftMiddleware",
    "disableTriggerOnFocus",
    "onReferenceHiddenChange",
    "overflowPadding",
    "defaultShown",
    "shown",
    "onShownChange",
    "hoverDelay",
    "strategy",
    "enableInteractive",
    "disableArrow",
    "disableCloseAfterClick",
    "usePortal",
    "id",
    "getRootRef",
    "appearance",
    "style",
    "className",
    "zIndex",
    "closable",
    "onPlacementChange"
  ]);
  const generatedId = React105.useId();
  const tooltipId = idProp || generatedId;
  const renderFloatingComponent = (0, import_react13.useCallback)(({ shown, floatingProps, floatingRef, placement: resultPlacement, middlewareData, setArrowRef, willBeHide, onClose }) => {
    if (!shown) {
      return null;
    }
    return (0, import_jsx_runtime90.jsx)(AppRootPortal, {
      usePortal,
      children: (0, import_jsx_runtime90.jsx)(TooltipBase, _object_spread_props(_object_spread({}, popperProps, floatingProps), {
        style: _object_spread(_object_spread_props(_object_spread({}, floatingProps.style), {
          zIndex
        }), styleProp),
        id: tooltipId,
        getRootRef: floatingRef,
        appearance,
        arrowProps: disableArrow ? void 0 : {
          placement: resultPlacement,
          coords: getArrowCoordsByMiddlewareData(middlewareData),
          getRootRef: setArrowRef
        },
        className: clsx(willBeHide ? animationFadeClassNames.out : animationFadeClassNames.in, className),
        onCloseIconClick: closable ? onClose : void 0
      }))
    });
  }, [
    appearance,
    className,
    closable,
    disableArrow,
    popperProps,
    styleProp,
    tooltipId,
    usePortal,
    zIndex
  ]);
  const remapReferenceProps = (0, import_react13.useCallback)((_param2) => {
    var { shown } = _param2, referenceProps = _object_without_properties(_param2, [
      "shown"
    ]);
    return _object_spread({}, referenceProps, shown && {
      "aria-describedby": tooltipId
    });
  }, [
    tooltipId
  ]);
  const { component: component2, anchorRef, anchorProps } = useFloatingElement({
    placement: placementProp,
    arrow: !disableArrow,
    arrowHeight,
    arrowPadding,
    offsetByMainAxis,
    offsetByCrossAxis,
    hideWhenReferenceHidden,
    disableFlipMiddleware,
    disableShiftMiddleware,
    overflowPadding,
    defaultShown,
    shown: shownProp,
    onShownChange,
    trigger: disableTriggerOnFocus ? "hover" : [
      "hover",
      "focus"
    ],
    onReferenceHiddenChange,
    hoverDelay,
    closeAfterClick: !disableCloseAfterClick,
    disableInteractive: !enableInteractive,
    strategy,
    onPlacementChange,
    renderFloatingComponent,
    externalFloatingElementRef: getRootRef,
    remapReferenceProps
  });
  return {
    anchorRef,
    anchorProps,
    tooltip: component2
  };
};

// node_modules/@vkontakte/vkui/dist/components/Tooltip/Tooltip.js
var Tooltip = (_param) => {
  var { children } = _param, restProps = _object_without_properties(_param, [
    "children"
  ]);
  const { anchorRef, anchorProps, tooltip } = useTooltip(restProps);
  const anchor = useReferenceElement(children, anchorProps, anchorRef);
  return (0, import_jsx_runtime91.jsxs)(React106.Fragment, {
    children: [
      anchor,
      tooltip
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/ModalRoot.js
var import_jsx_runtime93 = __toESM(require_jsx_runtime(), 1);
var React107 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/ModalOverlay/ModalOverlay.js
var import_jsx_runtime92 = __toESM(require_jsx_runtime(), 1);
var positionClassNames = {
  absolute: "vkuiModalOverlay__hostPositionAbsolute",
  fixed: "vkuiModalOverlay__hostPositionFixed"
};
var transitionStateClassNames = {
  appear: "vkuiModalOverlay__hostStateEnter",
  appearing: "vkuiModalOverlay__hostStateEntering",
  appeared: "vkuiModalOverlay__hostStateEntered",
  enter: "vkuiModalOverlay__hostStateEnter",
  entering: "vkuiModalOverlay__hostStateEntering",
  entered: "vkuiModalOverlay__hostStateEntered",
  exit: "vkuiModalOverlay__hostStateExit",
  exiting: "vkuiModalOverlay__hostStateExiting",
  exited: "vkuiModalOverlay__hostStateExited"
};
var ModalOverlay = (_param) => {
  var { visible = false, position = "absolute", getRootRef, onClick, disableOpenAnimation, disableCloseAnimation } = _param, restProps = _object_without_properties(_param, [
    "visible",
    "position",
    "getRootRef",
    "onClick",
    "disableOpenAnimation",
    "disableCloseAnimation"
  ]);
  const [transitionState, { ref, onTransitionEnd }] = useCSSTransition(visible, {
    enableAppear: !disableOpenAnimation,
    enableEnter: !disableOpenAnimation,
    enableExit: !disableCloseAnimation
  });
  const handleRef = useExternRef(getRootRef, ref);
  return (0, import_jsx_runtime92.jsx)("div", _object_spread_props(_object_spread({}, restProps), {
    ref: handleRef,
    "aria-hidden": "true",
    hidden: transitionState === "exited",
    className: clsx("vkuiModalOverlay__host", onClick === void 0 && "vkuiModalOverlay__nonInteractive", positionClassNames[position], transitionStateClassNames[transitionState]),
    onClick,
    onTransitionEnd
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/ModalRootContext.js
var import_react14 = __toESM(require_react(), 1);
var ModalRootOverlayContext = (0, import_react14.createContext)({
  current: null
});
var ModalRootContext = (0, import_react14.createContext)({
  updateModalHeight: noop,
  registerModal: noop,
  isInsideModal: false
});

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/ModalRoot.js
var warn15 = warnOnce("ModalRoot");
var ModalRoot = ({ activeModal, children, modalOverlayTestId, noFocusToDialog, disableModalOverlay, usePortal, onOpen, onOpened, onClose, onClosed }) => {
  const contextValue = React107.useMemo(() => ({
    isInsideModal: true,
    // base props
    activeModal,
    modalOverlayTestId,
    noFocusToDialog,
    disableModalOverlay,
    // callbacks
    onOpen,
    onOpened,
    onClose,
    onClosed,
    // TODO [>=8] Удалить метод
    updateModalHeight: (
      /* istanbul ignore next: deprecated */
      true ? () => {
        warn15("Метод updateModalHeight() устарел и будет удалён в VKUI v8");
      } : noop
    ),
    // TODO [>=8] Удалить метод
    registerModal: (
      /* istanbul ignore next: deprecated */
      true ? () => {
        warn15("Метод registerModal() устарел и будет удалён в VKUI v8");
      } : noop
    )
  }), [
    activeModal,
    disableModalOverlay,
    modalOverlayTestId,
    noFocusToDialog,
    onClose,
    onClosed,
    onOpen,
    onOpened
  ]);
  const modalOverlayRef = React107.useRef(null);
  return (0, import_jsx_runtime93.jsx)(AppRootPortal, {
    usePortal,
    children: (0, import_jsx_runtime93.jsx)(ModalRootContext.Provider, {
      value: contextValue,
      children: (0, import_jsx_runtime93.jsxs)(ModalRootOverlayContext.Provider, {
        value: modalOverlayRef,
        children: [
          !disableModalOverlay && (0, import_jsx_runtime93.jsx)(ModalOverlay, {
            position: "fixed",
            visible: typeof activeModal === "string",
            getRootRef: modalOverlayRef
          }),
          children
        ]
      })
    })
  });
};

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/withModalRootContext.js
var import_jsx_runtime94 = __toESM(require_jsx_runtime(), 1);
var React108 = __toESM(require_react(), 1);
function withModalRootContext(Component2) {
  function WithModalRootContext(props) {
    const { updateModalHeight } = React108.useContext(ModalRootContext);
    return (0, import_jsx_runtime94.jsx)(Component2, _object_spread_props(_object_spread({}, props), {
      updateModalHeight
    }));
  }
  return WithModalRootContext;
}

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/useModalRootContext.js
var import_react15 = __toESM(require_react(), 1);
var useModalRootContext = () => {
  const { activeModal, isInsideModal, onClose: onCloseContext, updateModalHeight, registerModal } = (0, import_react15.useContext)(ModalRootContext);
  const onClose = (0, import_react15.useCallback)(() => {
    if (onCloseContext && activeModal !== null && activeModal !== void 0) {
      onCloseContext(activeModal);
    }
  }, [
    activeModal,
    onCloseContext
  ]);
  return {
    activeModal,
    isInsideModal,
    onClose,
    updateModalHeight,
    registerModal
  };
};

// node_modules/@vkontakte/vkui/dist/components/ModalPageContent/ModalPageContent.js
var import_jsx_runtime96 = __toESM(require_jsx_runtime(), 1);

// node_modules/@vkontakte/vkui/dist/components/CustomScrollView/CustomScrollView.js
var import_jsx_runtime95 = __toESM(require_jsx_runtime(), 1);
var React109 = __toESM(require_react(), 1);
var overscrollBehaviorClassNames = {
  auto: void 0,
  contain: "vkuiCustomScrollView__overscrollBehaviorContain",
  none: "vkuiCustomScrollView__overscrollBehaviorNone"
};
var scrollBehaviorClassNames = {
  auto: void 0,
  smooth: "vkuiCustomScrollView__scrollBehaviorSmooth"
};
var CustomScrollView = (_param) => {
  var { className, children, enableHorizontalScroll = false, onScroll, getRootRef, overscrollBehavior = "auto", scrollBehavior = "auto", scrollbarHidden = false } = _param, restProps = _object_without_properties(_param, [
    "className",
    "children",
    "enableHorizontalScroll",
    "onScroll",
    "getRootRef",
    "overscrollBehavior",
    "scrollBehavior",
    "scrollbarHidden"
  ]);
  return (0, import_jsx_runtime95.jsx)("div", _object_spread_props(_object_spread({
    className: clsx(className, "vkuiCustomScrollView__host", enableHorizontalScroll && "vkuiCustomScrollView__horizontalScrollEnabled", overscrollBehaviorClassNames[overscrollBehavior], scrollBehaviorClassNames[scrollBehavior], scrollbarHidden && "vkuiCustomScrollView__scrollbarHidden"),
    ref: getRootRef,
    onScroll
  }, restProps), {
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ModalPageContent/ModalPageContent.js
var ModalPageContent = (_param) => {
  var { children, className, getRootRef } = _param, restProps = _object_without_properties(_param, [
    "children",
    "className",
    "getRootRef"
  ]);
  return (0, import_jsx_runtime96.jsx)(CustomScrollView, _object_spread_props(_object_spread({
    className: clsx(className, "vkuiModalPageContent__host"),
    getRootRef
  }, restProps), {
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ModalPage/ModalPage.js
var import_jsx_runtime102 = __toESM(require_jsx_runtime(), 1);
var import_react21 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/helpers/range.js
function range(from, to, step = 1) {
  const direction = from < to ? 1 : -1;
  const distance = Math.abs(from - to) + 1;
  const arrayLength = Math.ceil(distance / step);
  const arr = Array(arrayLength);
  for (let index2 = 0; index2 < arr.length; index2++) {
    arr[index2] = from + index2 * step * direction;
  }
  return arr;
}
function rangeIncrement(from, to, step = 1) {
  if (from > to) {
    return [];
  }
  return range(from, to, step);
}
function inRange(number, from, to) {
  return number >= from && number <= to;
}

// node_modules/@vkontakte/vkui/dist/lib/sheet/constants.js
var BLOCK_SHEET_BEHAVIOR_DATA_ATTRIBUTE_KEY = "data-vkui-block-sheet-behavior";
var BLOCK_SHEET_BEHAVIOR_DATA_ATTRIBUTE = {
  [BLOCK_SHEET_BEHAVIOR_DATA_ATTRIBUTE_KEY]: true
};
var DRAG_THRESHOLDS = {
  DISTANCE_FOR_MOVING_START: 12,
  VELOCITY: 500
};
var SNAP_POINT_SAFE_RANGE = {
  LOWER: 25,
  HIGHEST: 90
};
var SNAP_POINT_DETENTS = {
  MIN: 0,
  MEDIUM: 50,
  LARGE: 100
};
var DYNAMIC_SNAP_POINT_DATA = {
  IDLE_POINT_VALUE: 0,
  COMPUTED_INDEX: 1
};

// node_modules/@vkontakte/vkui/dist/lib/sheet/useBottomSheet.js
var import_react16 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/lib/sheet/controllers/BottomSheetController.js
var BottomSheetController = class _BottomSheetController {
  init(snapPoint) {
    this.isInitialized = true;
    if (snapPoint === "auto") {
      this.unit = "px";
      this.currentSnapPoint = DYNAMIC_SNAP_POINT_DATA.IDLE_POINT_VALUE;
      this.snapPointDetents = [
        SNAP_POINT_DETENTS.MIN,
        DYNAMIC_SNAP_POINT_DATA.IDLE_POINT_VALUE
      ];
    } else {
      this.unit = "%";
      this.currentSnapPoint = snapPoint.initial;
      this.snapPointDetents = snapPoint.detents;
    }
  }
  destroy() {
    var _this_backdropTransitionController;
    this.isInitialized = false;
    this.pannedEl = null;
    this.sheetTransitionController.cleanup();
    (_this_backdropTransitionController = this.backdropTransitionController) === null || _this_backdropTransitionController === void 0 ? void 0 : _this_backdropTransitionController.cleanup();
    this.disableVerticalScrollBouncingDispose();
    this.disableVerticalScrollBouncingDispose = noop;
  }
  panStart(event) {
    if (!this.isInitialized || this.panState !== "idle" || hasSelectionWithRangeType(event.target)) {
      return;
    }
    this.panState = "start";
    this.pannedEl = event.target;
    this.panGestureRecognizer.setStartCoords(event);
  }
  panMove(event) {
    switch (this.panState) {
      case "start":
        this.panGestureRecognizer.setInitialTimeOnce();
        this.panGestureRecognizer.setEndCoords(event);
        if (this.preventUntilPanGestureBecomesExpected()) {
          return;
        }
        if (this.preventImmediatelyIfPannedElIsNotValid()) {
          this.panState = "idle";
          return;
        }
        if (this.preventUntilVerticalScrollingOnSheetScrollElBecomesExpected()) {
          return;
        }
        if (this.preventImmediatelyIfVerticalScrollingOnPannedElIsScrolled()) {
          this.panState = "idle";
          return;
        }
        this.panState = "moving";
        this.panGestureRecognizer.setStartCoords(event);
        this.sheetHeight = this.sheetEl.offsetHeight;
        this.disableVerticalScrollBouncingDispose = _BottomSheetController.disableVerticalScrollBouncingIfNeeded(this.sheetScrollEl, this.pannedEl);
        if (this.isDynamicSnapPoint) {
          this.currentSnapPoint = this.sheetHeight;
          this.snapPointDetents[DYNAMIC_SNAP_POINT_DATA.COMPUTED_INDEX] = this.sheetHeight;
        }
        break;
      case "moving":
        this.panGestureRecognizer.setEndCoords(event);
        const { y1, y2 } = this.panGestureRecognizer;
        this.nextSnapPoint = rubberbandIfOutOfBounds(this.currentSnapPoint - (y2 - y1) / this.sheetHeight * this.currentSnapPoint, SNAP_POINT_DETENTS.MIN, this.isDynamicSnapPoint ? this.sheetHeight : SNAP_POINT_DETENTS.LARGE);
        this.calculateSnapPoint(this.nextSnapPoint, true);
        break;
    }
  }
  panEnd() {
    switch (this.panState) {
      case "moving":
        const prevCurrentSnapPoint = this.currentSnapPoint;
        this.currentSnapPoint = this.getSnapPointTo(this.nextSnapPoint);
        if (prevCurrentSnapPoint !== this.currentSnapPoint && this.currentSnapPoint > SNAP_POINT_DETENTS.MIN) {
          this.onSnapPointChange(this.currentSnapPoint);
        }
        this.calculateSnapPoint(this.currentSnapPoint);
        break;
    }
    this.panState = "idle";
    this.panGestureRecognizer.reset();
    this.disableVerticalScrollBouncingDispose();
    this.disableVerticalScrollBouncingDispose = noop;
  }
  get isDynamicSnapPoint() {
    return this.unit === "px";
  }
  calculateSnapPoint(nextSnapPoint, immediately = false) {
    if (this.rafId !== null) {
      cancelAnimationFrame(this.rafId);
    }
    if (nextSnapPoint <= SNAP_POINT_DETENTS.MIN) {
      var _this_backdropTransitionController;
      this.sheetTransitionController.enableTransition();
      (_this_backdropTransitionController = this.backdropTransitionController) === null || _this_backdropTransitionController === void 0 ? void 0 : _this_backdropTransitionController.enableTransition();
      this.panState = "idle";
      this.onDismiss();
      return;
    }
    const backdropOpacity = clamp2(this.isDynamicSnapPoint ? nextSnapPoint / this.sheetHeight : nextSnapPoint * 2 / SNAP_POINT_DETENTS.LARGE, 0, 1);
    this.rafId = requestAnimationFrame(() => {
      var _this_backdropTransitionController2;
      if (immediately) {
        var _this_backdropTransitionController1;
        (_this_backdropTransitionController1 = this.backdropTransitionController) === null || _this_backdropTransitionController1 === void 0 ? void 0 : _this_backdropTransitionController1.disableTransition().set(backdropOpacity);
        this.sheetTransitionController.disableTransition().set(`${nextSnapPoint}${this.unit}`);
        return;
      }
      if (this.isDynamicSnapPoint) {
        this.sheetTransitionController.cleanupOnTransitionEnd();
      }
      (_this_backdropTransitionController2 = this.backdropTransitionController) === null || _this_backdropTransitionController2 === void 0 ? void 0 : _this_backdropTransitionController2.unset();
      this.sheetTransitionController.enableTransition().set(`${this.currentSnapPoint}${this.unit}`);
    });
  }
  getSnapPointTo(nextSnapPoint) {
    const closestSnapPoint = _BottomSheetController.getClosestSnapPoint(this.snapPointDetents, nextSnapPoint);
    if (closestSnapPoint !== this.currentSnapPoint) {
      return closestSnapPoint;
    }
    const panDirection = this.panGestureRecognizer.direction();
    if (panDirection.axis !== "y" || panDirection.direction === null) {
      return this.currentSnapPoint;
    }
    const velocity = this.panGestureRecognizer.velocity();
    if (Math.abs(velocity.y) < DRAG_THRESHOLDS.VELOCITY) {
      return this.currentSnapPoint;
    }
    const closestSnapPointByDirection = _BottomSheetController.getClosestSnapPointByDirection(this.snapPointDetents, closestSnapPoint, panDirection.direction);
    return closestSnapPointByDirection;
  }
  preventUntilPanGestureBecomesExpected() {
    return this.panGestureRecognizer.direction().axis === "x" || this.panGestureRecognizer.distance() < DRAG_THRESHOLDS.DISTANCE_FOR_MOVING_START;
  }
  preventImmediatelyIfPannedElIsNotValid() {
    return this.pannedEl === null || // Элемент со специальным атрибутом
    this.pannedEl.closest(`[${BLOCK_SHEET_BEHAVIOR_DATA_ATTRIBUTE_KEY}=true]`) !== null || // eslint-disable-line no-restricted-properties
    // Элемент за пределами панели.
    !this.sheetEl.contains(this.pannedEl);
  }
  preventUntilVerticalScrollingOnSheetScrollElBecomesExpected() {
    if (this.sheetScrollEl === null || !this.sheetScrollEl.contains(this.pannedEl) || this.sheetScrollEl.scrollHeight <= this.sheetScrollEl.clientHeight) {
      return false;
    }
    if (this.sheetScrollEl.scrollTop === 0) {
      return this.panGestureRecognizer.direction().direction === -1 && _BottomSheetController.isLastSnapPointDetents(this.snapPointDetents, this.currentSnapPoint);
    }
    return true;
  }
  preventImmediatelyIfVerticalScrollingOnPannedElIsScrolled() {
    if (
      /* istanbul ignore next: покрываем TypeScript */
      this.pannedEl === null || this.pannedEl === this.sheetEl || this.pannedEl === this.sheetScrollEl
    ) {
      return false;
    }
    const overflowAncestor = getNearestOverflowAncestor(this.pannedEl, this.sheetEl);
    if (overflowAncestor === null || this.sheetScrollEl === overflowAncestor || overflowAncestor.scrollHeight <= overflowAncestor.clientHeight) {
      return false;
    }
    return overflowAncestor.scrollTop !== 0 || this.panGestureRecognizer.direction().direction === -1;
  }
  static disableVerticalScrollBouncingIfNeeded(sheetScrollEl, targetEl) {
    if (sheetScrollEl !== null && sheetScrollEl.scrollTop <= 0 && sheetScrollEl.contains(targetEl) && sheetScrollEl.scrollHeight > sheetScrollEl.clientHeight) {
      sheetScrollEl.style.setProperty("overflow-y", "hidden");
      return function dispose() {
        sheetScrollEl.style.removeProperty("overflow-y");
      };
    }
    return noop;
  }
  static isLastSnapPointDetents(snapPointDetents, currentY) {
    return currentY === snapPointDetents[snapPointDetents.length - 1];
  }
  static getClosestSnapPointByDirection(snapPointDetents, currentY, direction) {
    const foundIndex = snapPointDetents.indexOf(currentY);
    switch (direction) {
      case -1:
        var _snapPointDetents_;
        return (_snapPointDetents_ = snapPointDetents[foundIndex + 1]) !== null && _snapPointDetents_ !== void 0 ? _snapPointDetents_ : snapPointDetents[snapPointDetents.length - 1];
      case 1:
        var _snapPointDetents_1;
        return (_snapPointDetents_1 = snapPointDetents[foundIndex - 1]) !== null && _snapPointDetents_1 !== void 0 ? _snapPointDetents_1 : snapPointDetents[0];
    }
  }
  static getClosestSnapPoint(snapPointDetents, currentY) {
    let closest = snapPointDetents[0];
    let minDifference = Math.abs(snapPointDetents[0] - currentY);
    for (let i = 1; i < snapPointDetents.length; i += 1) {
      const difference2 = Math.abs(snapPointDetents[i] - currentY);
      if (difference2 < minDifference) {
        closest = snapPointDetents[i];
        minDifference = difference2;
      }
    }
    return closest;
  }
  constructor(sheetEl, { sheetScrollEl, sheetTransitionController, backdropTransitionController, onSnapPointChange, onDismiss }) {
    _define_property(this, "sheetEl", void 0);
    _define_property(this, "isInitialized", false);
    _define_property(this, "panState", "idle");
    _define_property(this, "pannedEl", null);
    _define_property(this, "sheetHeight", 0);
    _define_property(this, "rafId", null);
    _define_property(this, "currentSnapPoint", 0);
    _define_property(this, "nextSnapPoint", 0);
    _define_property(this, "snapPointDetents", [
      0,
      0
    ]);
    _define_property(this, "unit", "%");
    _define_property(this, "disableVerticalScrollBouncingDispose", noop);
    _define_property(this, "sheetScrollEl", void 0);
    _define_property(this, "sheetTransitionController", void 0);
    _define_property(this, "backdropTransitionController", void 0);
    _define_property(this, "panGestureRecognizer", void 0);
    _define_property(this, "onSnapPointChange", void 0);
    _define_property(this, "onDismiss", void 0);
    this.sheetEl = sheetEl;
    this.onSnapPointChange = onSnapPointChange;
    this.onDismiss = onDismiss;
    this.panGestureRecognizer = new UIPanGestureRecognizer();
    this.sheetScrollEl = sheetScrollEl;
    this.sheetTransitionController = sheetTransitionController;
    this.backdropTransitionController = backdropTransitionController;
  }
};

// node_modules/@vkontakte/vkui/dist/lib/sheet/controllers/CSSTransitionController.js
var CSSTransitionController = class {
  set(to) {
    this.el.style.setProperty(this.property, `${to}`);
    return this;
  }
  unset() {
    return this.cleanup();
  }
  enableTransition() {
    this.el.style.removeProperty("transition");
    return this;
  }
  disableTransition() {
    this.el.style.setProperty("transition", "none");
    return this;
  }
  cleanup() {
    this.el.removeEventListener("transitionend", this.handleTransitionEnd);
    this.el.style.removeProperty("transition");
    this.el.style.removeProperty(this.property);
    return this;
  }
  cleanupOnTransitionEnd() {
    this.el.addEventListener("transitionend", this.handleTransitionEnd, {
      once: true
    });
    return this;
  }
  constructor(el, property) {
    _define_property(this, "el", void 0);
    _define_property(this, "property", void 0);
    _define_property(this, "handleTransitionEnd", () => {
      this.cleanup();
      return this;
    });
    this.el = el;
    this.property = property;
  }
};

// node_modules/@vkontakte/vkui/dist/lib/sheet/useBottomSheet.js
var useBottomSheet = (enabled, { blocked, snapPoint, sheetCSSProperty, backdropCSSProperty, onSnapPointChange: onSnapPointChangeProp, onDismiss: onDismissProp }) => {
  const [sheetScrollEl, setSheetScrollEl] = (0, import_react16.useState)(null);
  const [sheetEl, setSheetEl] = (0, import_react16.useState)(null);
  const [backdropEl, setBackdropEl] = (0, import_react16.useState)(null);
  const initialStyle = (0, import_react16.useMemo)(() => enabled && snapPoint !== "auto" ? {
    [sheetCSSProperty]: `${snapPoint.initial}%`
  } : void 0, [
    enabled,
    snapPoint,
    sheetCSSProperty
  ]);
  const onSnapPointChange = useStableCallback(onSnapPointChangeProp || noop);
  const onDismiss = useStableCallback(onDismissProp || noop);
  const bsController = (0, import_react16.useMemo)(() => {
    if (!enabled || sheetEl === null) {
      return null;
    }
    return new BottomSheetController(sheetEl, {
      sheetScrollEl: sheetScrollEl || null,
      sheetTransitionController: new CSSTransitionController(sheetEl, sheetCSSProperty),
      backdropTransitionController: backdropEl ? new CSSTransitionController(backdropEl, backdropCSSProperty) : null,
      onSnapPointChange,
      onDismiss
    });
  }, [
    enabled,
    sheetEl,
    sheetCSSProperty,
    sheetScrollEl,
    backdropEl,
    backdropCSSProperty,
    onSnapPointChange,
    onDismiss
  ]);
  const onPanStart = function onPanStart2(event) {
    if (!blocked) {
      bsController.panStart(event.nativeEvent);
    }
  };
  const onPanMove = function onPanMove2(event) {
    bsController.panMove(event.nativeEvent);
  };
  const onPanEnd = function onPanEnd2() {
    bsController.panEnd();
  };
  useIsomorphicLayoutEffect(function init() {
    if (bsController) {
      bsController.init(snapPoint);
    }
  }, [
    snapPoint,
    bsController
  ]);
  useIsomorphicLayoutEffect(() => function unmount() {
    if (bsController) {
      bsController.destroy();
    }
  }, [
    bsController
  ]);
  return [
    {
      initialStyle,
      setSheetEl,
      setSheetScrollEl,
      setBackdropEl
    },
    bsController !== null ? {
      onTouchStart: onPanStart,
      onTouchMove: onPanMove,
      onTouchEnd: onPanEnd,
      onTouchCancel: onPanEnd,
      onMouseDown: onPanStart,
      onMouseMove: onPanMove,
      onMouseUp: onPanEnd,
      onMouseLeave: onPanEnd
    } : void 0
  ];
};

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/useModalManager.js
var import_react18 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/VisuallyHiddenModalOverlay/VisuallyHiddenModalOverlay.js
var import_jsx_runtime97 = __toESM(require_jsx_runtime(), 1);
var import_react17 = __toESM(require_react(), 1);
var VisuallyHiddenModalOverlay = (_param) => {
  var { visible: visibleExcluded, position: positionExcluded, getRootRef, disableOpenAnimation, disableCloseAnimation } = _param, restProps = _object_without_properties(_param, [
    "visible",
    "position",
    "getRootRef",
    "disableOpenAnimation",
    "disableCloseAnimation"
  ]);
  const ref = (0, import_react17.useContext)(ModalRootOverlayContext);
  return (0, import_jsx_runtime97.jsx)("div", _object_spread_props(_object_spread({}, restProps), {
    "aria-hidden": "true",
    className: "vkuiVisuallyHiddenModalOverlay__host",
    ref: function handleCurrentRefForForwardContextRef() {
      setRef(ref.current, getRootRef);
    }
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/useModalManager.js
var warn16 = warnOnce("useModalManager");
var useModalManager = ({ id: idProp, open, keepMounted, modalOverlayTestId, noFocusToDialog, disableModalOverlay, onOpen, onOpened, onClose, onClosed }) => {
  const context = (0, import_react18.useContext)(ModalRootContext);
  const generatingId = (0, import_react18.useId)();
  const id = getNavId({
    nav: idProp
  }, context.isInsideModal ? warn16 : void 0) || generatingId;
  const opened = context.isInsideModal ? context.activeModal === id : open;
  const shouldPreserveSnapPoint = context.isInsideModal ? context.activeModal !== null : false;
  const [unmounted, setUnmounted] = (0, import_react18.useState)(keepMounted ? false : !opened);
  useIsomorphicLayoutEffect(function unsetUnmounted() {
    if (!keepMounted && opened) {
      setUnmounted((prev) => prev ? false : prev);
    }
  }, [
    opened,
    keepMounted
  ]);
  if (unmounted) {
    return {
      mounted: false,
      shouldPreserveSnapPoint,
      id
    };
  }
  return {
    id,
    mounted: true,
    open: opened,
    shouldPreserveSnapPoint,
    noFocusToDialog: noFocusToDialog || context.noFocusToDialog,
    modalOverlayTestId: modalOverlayTestId || context.modalOverlayTestId,
    disableModalOverlay: disableModalOverlay || context.disableModalOverlay,
    ModalOverlay: context.isInsideModal ? VisuallyHiddenModalOverlay : ModalOverlay,
    onOpen: onOpen || getContextCallback(id, context.onOpen),
    onOpened: onOpened || getContextCallback(id, context.onOpened),
    onClose: onClose || getContextCallback(id, context.onClose),
    onClosed: function handleClosed(...args) {
      if (!keepMounted) {
        setUnmounted(true);
      }
      if (onClosed) {
        onClosed(...args);
      } else {
        var _context_onClosed;
        (_context_onClosed = context.onClosed) === null || _context_onClosed === void 0 ? void 0 : _context_onClosed.call(context, id);
      }
    }
  };
};
function getContextCallback(id, fn) {
  return fn ? () => fn(id) : void 0;
}

// node_modules/@vkontakte/vkui/dist/components/ModalPage/ModalPageInternal.js
var import_jsx_runtime101 = __toESM(require_jsx_runtime(), 1);
var import_react20 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useVirtualKeyboardState.js
var import_react19 = __toESM(require_react(), 1);
function useVirtualKeyboardState(enabled = true) {
  const { window: window2, document: document2 } = useDOM();
  const [focusedEl, setFocusedEl] = (0, import_react19.useState)(null);
  const [keyboardOpened, setKeyboardOpened] = (0, import_react19.useState)(false);
  const prevVisualViewportRef = (0, import_react19.useRef)(null);
  (0, import_react19.useEffect)(function handleFocusedEl() {
    if (!enabled || !window2 || !document2) {
      return;
    }
    const handleFocus = (event) => {
      const activeElement = event === true ? document2.activeElement : event.target;
      if (isHTMLContentEditableElement(activeElement)) {
        const patchedEvent = event === true ? {
          type: "focusin"
        } : event;
        switch (patchedEvent.type) {
          case "focusin":
            prevVisualViewportRef.current = getVisualViewport(window2);
            setFocusedEl(activeElement);
            break;
          case "focusout":
            prevVisualViewportRef.current = null;
            setKeyboardOpened(false);
            setFocusedEl(null);
            break;
        }
      }
    };
    handleFocus(true);
    const eventOptions = {
      passive: true,
      capture: false
    };
    document2.addEventListener("focusin", handleFocus, eventOptions);
    document2.addEventListener("focusout", handleFocus, eventOptions);
    return () => {
      prevVisualViewportRef.current = null;
      document2.removeEventListener("focusin", handleFocus, eventOptions);
      document2.removeEventListener("focusout", handleFocus, eventOptions);
    };
  }, [
    enabled,
    window2,
    document2
  ]);
  (0, import_react19.useEffect)(function handleVirtualKeyboardOpened() {
    if (!focusedEl || !window2) {
      return;
    }
    const handleResize = debounce(() => {
      if (prevVisualViewportRef.current === null) {
        return;
      }
      const nextVisualViewport = getVisualViewport(window2);
      const { offsetTop: prevOffsetTop, height: prevHeight } = prevVisualViewportRef.current;
      const { offsetTop: nextOffsetTop, height: nextHeight } = nextVisualViewport;
      if (prevOffsetTop !== nextOffsetTop || prevHeight !== nextHeight) {
        setKeyboardOpened(true);
        prevVisualViewportRef.current = nextVisualViewport;
      }
    }, 100);
    if (window2.visualViewport) {
      window2.visualViewport.addEventListener("resize", handleResize);
    } else {
      window2.addEventListener("resize", handleResize);
    }
    return function dispose() {
      if (window2.visualViewport) {
        window2.visualViewport.removeEventListener("resize", handleResize);
      } else {
        window2.removeEventListener("resize", handleResize);
      }
    };
  }, [
    focusedEl,
    window2
  ]);
  (0, import_react19.useEffect)(function preventWindowScrollIfKeyboardOpened() {
    if (!keyboardOpened || !window2) {
      return;
    }
    const prevent = throttle(() => {
      if (prevVisualViewportRef.current) {
        window2.scrollTo(0, prevVisualViewportRef.current.offsetTop);
      }
    }, 100);
    window2.addEventListener("scroll", prevent, {
      passive: true
    });
    return function dispose() {
      window2.removeEventListener("scroll", prevent);
    };
  }, [
    keyboardOpened,
    window2
  ]);
  return {
    opened: keyboardOpened
  };
}

// node_modules/@vkontakte/vkui/dist/components/ModalOutlet/ModalOutlet.js
var import_jsx_runtime98 = __toESM(require_jsx_runtime(), 1);
var ModalOutlet = (_param) => {
  var { className, hidden, isDesktop, children, getRootRef, disableModalOverlay } = _param, restProps = _object_without_properties(_param, [
    "className",
    "hidden",
    "isDesktop",
    "children",
    "getRootRef",
    "disableModalOverlay"
  ]);
  return (0, import_jsx_runtime98.jsx)("div", _object_spread_props(_object_spread({
    ref: getRootRef,
    className: clsx(className, "vkuiModalOutlet__host", isDesktop && "vkuiModalOutlet__hostDesktop", disableModalOverlay && "vkuiModalOutlet__disableModalOverlay"),
    hidden,
    "aria-hidden": hidden
  }, restProps), {
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ModalPage/ModalPageBase.js
var import_jsx_runtime100 = __toESM(require_jsx_runtime(), 1);

// node_modules/@vkontakte/vkui/dist/components/ModalOutsideButtons/ModalOutsideButtons.js
var import_jsx_runtime99 = __toESM(require_jsx_runtime(), 1);
var ModalOutsideButtons = (_param) => {
  var { className, children } = _param, restProps = _object_without_properties(_param, [
    "className",
    "children"
  ]);
  return (0, import_jsx_runtime99.jsx)(Flex, _object_spread_props(_object_spread({
    direction: "column",
    className: clsx("vkuiModalOutsideButtons__host", className)
  }, restProps), {
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ModalPage/ModalPageBase.js
var ModalPageBase = (_param) => {
  var { isDesktop, getRef, disableContentPanningGesture, header, children, footer, outsideButtons, modalContentTestId, modalDismissButtonTestId, modalDismissButtonLabel, hideCloseButton, closable, onClose = noop } = _param, restProps = _object_without_properties(_param, [
    "isDesktop",
    "getRef",
    "disableContentPanningGesture",
    "header",
    "children",
    "footer",
    "outsideButtons",
    "modalContentTestId",
    "modalDismissButtonTestId",
    "modalDismissButtonLabel",
    "hideCloseButton",
    "closable",
    "onClose"
  ]);
  const disableContentPanningGestureProp = disableContentPanningGesture ? BLOCK_SHEET_BEHAVIOR_DATA_ATTRIBUTE : void 0;
  const closeButton = hideCloseButton || !isDesktop ? null : (0, import_jsx_runtime100.jsx)(ModalOutsideButton, {
    "data-testid": modalDismissButtonTestId,
    onClick: closable ? function handleDismissButtonClick(event) {
      onClose("click-close-button", event);
    } : noop,
    "aria-label": modalDismissButtonLabel,
    children: (0, import_jsx_runtime100.jsx)(Icon20Cancel, {})
  });
  return (0, import_jsx_runtime100.jsxs)(RootComponent, _object_spread_props(_object_spread({
    role: "document",
    baseClassName: "vkuiModalPage__document"
  }, restProps), {
    children: [
      (0, import_jsx_runtime100.jsxs)("div", {
        className: clsx("vkuiModalPage__children", isDesktop ? "vkuiModalPage__childrenDesktop" : "vkuiModalPage__childrenMobile"),
        children: [
          hasReactNode(header) && header,
          (0, import_jsx_runtime100.jsx)(ModalPageContent, _object_spread_props(_object_spread({
            getRootRef: getRef,
            "data-testid": modalContentTestId
          }, disableContentPanningGestureProp), {
            children
          })),
          hasReactNode(footer) && footer
        ]
      }),
      isDesktop && (closeButton || outsideButtons) && (0, import_jsx_runtime100.jsxs)(ModalOutsideButtons, {
        children: [
          closeButton,
          outsideButtons
        ]
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ModalPage/ModalPageInternal.js
var transitionStateClassNames2 = {
  appear: "vkuiModalPage__documentStateEnter",
  appearing: "vkuiModalPage__documentStateEntering",
  enter: "vkuiModalPage__documentStateEnter",
  entering: "vkuiModalPage__documentStateEntering",
  exiting: "vkuiModalPage__documentStateExiting",
  exited: "vkuiModalPage__documentStateExited"
};
var ModalPageInternal = (_param) => {
  var { open, header, footer, size: desktopMaxWidth, height, children, className, style, snapPoint, onSnapPointChange, getModalContentRef, ModalOverlay: ModalOverlay2 = ModalOverlay, modalOverlayTestId, modalContentTestId, modalDismissButtonTestId, modalDismissButtonLabel = "Закрыть", outsideButtons, noFocusToDialog, hideCloseButton, preventClose, disableContentPanningGesture, restoreFocus, onOpen, onOpened, onClose = noop, onClosed, disableFocusTrap, disableModalOverlay, disableOpenAnimation = false, disableCloseAnimation = false } = _param, restProps = _object_without_properties(_param, [
    "open",
    "header",
    "footer",
    "size",
    "height",
    "children",
    "className",
    "style",
    "snapPoint",
    "onSnapPointChange",
    "getModalContentRef",
    "ModalOverlay",
    "modalOverlayTestId",
    "modalContentTestId",
    "modalDismissButtonTestId",
    "modalDismissButtonLabel",
    "outsideButtons",
    "noFocusToDialog",
    "hideCloseButton",
    "preventClose",
    "disableContentPanningGesture",
    "restoreFocus",
    "onOpen",
    "onOpened",
    "onClose",
    "onClosed",
    "disableFocusTrap",
    "disableModalOverlay",
    "disableOpenAnimation",
    "disableCloseAnimation"
  ]);
  const { hasCustomPanelHeaderAfter } = useConfigProvider();
  const [transitionState, { ref, onTransitionEnd }] = useCSSTransition(open, {
    enableAppear: !disableOpenAnimation,
    enableEnter: !disableOpenAnimation,
    enableExit: !disableCloseAnimation,
    onEnter() {
      onOpen === null || onOpen === void 0 ? void 0 : onOpen();
    },
    onEntered() {
      onOpened === null || onOpened === void 0 ? void 0 : onOpened();
    },
    onExited() {
      onClosed === null || onClosed === void 0 ? void 0 : onClosed();
    }
  });
  const opened = transitionState === "appeared" || transitionState === "entered";
  const hidden = transitionState === "exited";
  const closable = !preventClose && opened;
  const { sizeX, isDesktop } = useAdaptivityWithJSMediaQueries();
  const bottomSheetEnabled = !isDesktop && !preventClose && transitionState !== "exited";
  const { opened: keyboardOpened } = useVirtualKeyboardState(bottomSheetEnabled);
  const [{ initialStyle, setSheetEl, setSheetScrollEl, setBackdropEl }, bottomSheetEventHandlers] = useBottomSheet(bottomSheetEnabled, {
    blocked: keyboardOpened,
    snapPoint,
    sheetCSSProperty: "--vkui_internal_ModalPageDocument--snapPoint",
    backdropCSSProperty: "--vkui_internal--modal-overlay--opacity",
    onSnapPointChange,
    onDismiss() {
      onClose("swipe-down");
    }
  });
  const documentStyle = keyboardOpened ? _object_spread({
    "--vkui_internal_ModalPageDocument--safeAreaInsetBottom": "0px"
  }, initialStyle) : initialStyle;
  const handleSheetRef = useExternRef(setSheetEl, ref);
  const handleSheetScrollRef = useExternRef(setSheetScrollEl, getModalContentRef);
  const [desktopMaxWidthClassName, desktopMaxWidthStyle] = isDesktop ? resolveDesktopMaxWidth(desktopMaxWidth) : [
    void 0,
    void 0
  ];
  const modalOverlay = !disableModalOverlay && (0, import_jsx_runtime101.jsx)(ModalOverlay2, {
    getRootRef: setBackdropEl,
    "data-testid": modalOverlayTestId,
    visible: open,
    disableOpenAnimation,
    disableCloseAnimation,
    onClick: closable ? function handleBackdropClick(event) {
      onClose("click-overlay", event);
    } : void 0
  });
  const handleEscKeyDown = (0, import_react20.useCallback)((event) => {
    if (closable && pressedKey(event) === Keys.ESCAPE) {
      onClose("escape-key");
    }
  }, [
    closable,
    onClose
  ]);
  useScrollLock(!hidden);
  return (0, import_jsx_runtime101.jsxs)(ModalOutlet, {
    hidden,
    isDesktop,
    onKeyDown: handleEscKeyDown,
    disableModalOverlay,
    children: [
      modalOverlay,
      (0, import_jsx_runtime101.jsx)(FocusTrap, _object_spread_props(_object_spread({}, restProps), {
        autoFocus: !noFocusToDialog,
        restoreFocus,
        role: "dialog",
        "aria-modal": "true",
        disabled: !opened || hidden || disableFocusTrap,
        className: clsx(className, "vkuiModalPage__host", isDesktop ? "vkuiModalPage__hostDesktop" : "vkuiModalPage__hostMobile", !isDesktop && (hasCustomPanelHeaderAfter ? "vkuiModalPage__hostMobileSafeAreaInsetTopWithCustomOffset" : "vkuiModalPage__hostMobileSafeAreaInsetTop"), desktopMaxWidthClassName, sizeX === "regular" && "vkuiInternalModalPage--sizeX-regular"),
        style: mergeStyle(mergeStyle(desktopMaxWidthStyle, getHeightCSSVariable(height)), style),
        children: (0, import_jsx_runtime101.jsx)(ModalPageBase, _object_spread_props(_object_spread({}, bottomSheetEventHandlers), {
          getRootRef: handleSheetRef,
          getRef: handleSheetScrollRef,
          style: documentStyle,
          className: clsx(isDesktop ? "vkuiModalPage__documentDesktop" : "vkuiModalPage__documentMobile", transitionStateClassNames2[transitionState]),
          onTransitionEnd,
          isDesktop,
          disableContentPanningGesture,
          header,
          footer,
          outsideButtons,
          modalContentTestId,
          modalDismissButtonTestId,
          modalDismissButtonLabel,
          hideCloseButton,
          closable,
          onClose,
          children
        }))
      }))
    ]
  });
};
var desktopMaxWidthClassNames = {
  s: "vkuiModalPage__hostDesktopMaxWidthS",
  m: "vkuiModalPage__hostDesktopMaxWidthM",
  l: "vkuiModalPage__hostDesktopMaxWidthL"
};
function resolveDesktopMaxWidth(desktopMaxWidth = "s") {
  if (typeof desktopMaxWidth === "number") {
    return [
      void 0,
      {
        "--vkui_internal_ModalPage--desktopMaxWidth": `${desktopMaxWidth}px`
      }
    ];
  }
  return desktopMaxWidthClassNames.hasOwnProperty(desktopMaxWidth) ? [
    desktopMaxWidthClassNames[desktopMaxWidth],
    void 0
  ] : [
    void 0,
    {
      "--vkui_internal_ModalPage--desktopMaxWidth": desktopMaxWidth
    }
  ];
}
function getHeightCSSVariable(height) {
  return height !== void 0 ? {
    "--vkui_internal_ModalPage--userHeight": typeof height === "number" ? `${height}px` : height
  } : void 0;
}

// node_modules/@vkontakte/vkui/dist/components/ModalPage/ModalPage.js
var snapPointCache = /* @__PURE__ */ new Map();
var ModalPage = (_param) => {
  var { id: idProp, nav, open = false, modalOverlayTestId, noFocusToDialog, onOpen, onOpened, onClose, onClosed, size: size5 = "s", settlingHeight = 50, dynamicContentHeight, disableModalOverlay, keepMounted = false } = _param, restProps = _object_without_properties(_param, [
    "id",
    "nav",
    "open",
    "modalOverlayTestId",
    "noFocusToDialog",
    "onOpen",
    "onOpened",
    "onClose",
    "onClosed",
    "size",
    "settlingHeight",
    "dynamicContentHeight",
    "disableModalOverlay",
    "keepMounted"
  ]);
  const _useModalManager = useModalManager({
    id: nav || idProp,
    open,
    keepMounted,
    modalOverlayTestId,
    disableModalOverlay,
    noFocusToDialog,
    onOpen,
    onOpened,
    onClose,
    onClosed
  }), { mounted, shouldPreserveSnapPoint, id } = _useModalManager, resolvedProps = _object_without_properties(_useModalManager, [
    "mounted",
    "shouldPreserveSnapPoint",
    "id"
  ]);
  const snapPoint = (0, import_react21.useMemo)(() => {
    if (dynamicContentHeight) {
      return "auto";
    }
    if (shouldPreserveSnapPoint) {
      const snapPointCached = snapPointCache.get(id);
      if (snapPointCached) {
        return snapPointCached;
      }
      const nextSnapPoint = transformSettlingHeightToSnapPoint(settlingHeight);
      snapPointCache.set(id, nextSnapPoint);
      return nextSnapPoint;
    } else {
      snapPointCache.delete(id);
    }
    return transformSettlingHeightToSnapPoint(settlingHeight);
  }, [
    id,
    shouldPreserveSnapPoint,
    dynamicContentHeight,
    settlingHeight
  ]);
  if (!mounted) {
    return null;
  }
  return (0, import_jsx_runtime102.jsx)(ModalContext.Provider, {
    value: id,
    children: (0, import_jsx_runtime102.jsx)(ModalPageInternal, _object_spread({
      id,
      size: size5,
      "aria-labelledby": `${id}-label`,
      snapPoint,
      onSnapPointChange: snapPoint !== "auto" && shouldPreserveSnapPoint ? (snapPoint2) => {
        const snapPointCached = snapPointCache.get(id);
        if (snapPointCached) {
          snapPointCached.initial = snapPoint2;
          snapPointCache.set(id, snapPointCached);
        }
      } : void 0
    }, resolvedProps, restProps))
  });
};
function transformSettlingHeightToSnapPoint(settlingHeight) {
  const currentSnapPoint = Math.min(Math.max(settlingHeight, SNAP_POINT_SAFE_RANGE.LOWER), SNAP_POINT_DETENTS.LARGE);
  return {
    initial: currentSnapPoint,
    detents: inRange(currentSnapPoint, SNAP_POINT_SAFE_RANGE.LOWER, SNAP_POINT_SAFE_RANGE.HIGHEST) ? [
      SNAP_POINT_DETENTS.MIN,
      currentSnapPoint,
      SNAP_POINT_DETENTS.LARGE
    ] : [
      SNAP_POINT_DETENTS.MIN,
      currentSnapPoint
    ]
  };
}

// node_modules/@vkontakte/vkui/dist/components/ModalPageHeader/ModalPageHeader.js
var import_jsx_runtime103 = __toESM(require_jsx_runtime(), 1);
var React110 = __toESM(require_react(), 1);
var ModalPageHeader = (_param) => {
  var { children, noSeparator = false, getRootRef, className, typographyProps } = _param, restProps = _object_without_properties(_param, [
    "children",
    "noSeparator",
    "getRootRef",
    "className",
    "typographyProps"
  ]);
  const platform3 = usePlatform();
  const { isDesktop, sizeX } = useAdaptivityWithJSMediaQueries();
  const modalContext = useModalContext();
  return (0, import_jsx_runtime103.jsxs)(import_jsx_runtime103.Fragment, {
    children: [
      (0, import_jsx_runtime103.jsx)("div", {
        className: clsx("vkuiModalPageHeader__host", platform3 !== "vkcom" && "vkuiModalPageHeader__hostWithGaps", isDesktop && "vkuiModalPageHeader__hostDesktop"),
        ref: getRootRef,
        children: (0, import_jsx_runtime103.jsx)(PanelHeader, _object_spread_props(_object_spread({
          className: clsx("vkuiInternalModalPageHeader__in", className),
          typographyProps: _object_spread({
            Component: "h2",
            id: modalContext.labelId
          }, typographyProps)
        }, restProps), {
          fixed: false,
          delimiter: "none",
          transparent: true,
          children
        }))
      }),
      !noSeparator && (0, import_jsx_runtime103.jsx)(Separator, {
        padding: sizeX !== "regular"
      })
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/ModalCard/ModalCard.js
var import_jsx_runtime106 = __toESM(require_jsx_runtime(), 1);

// node_modules/@vkontakte/vkui/dist/components/ModalCard/ModalCardInternal.js
var import_jsx_runtime105 = __toESM(require_jsx_runtime(), 1);
var import_react22 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/ModalCardBase/ModalCardBase.js
var import_jsx_runtime104 = __toESM(require_jsx_runtime(), 1);
var React111 = __toESM(require_react(), 1);
var ModalCardBase = (_param) => {
  var { icon, title, titleComponent = "span", description, descriptionComponent = "span", children, actions, onClose, dismissLabel = "Закрыть", size: sizeProp, modalDismissButtonTestId, dismissButtonMode = "outside", preventClose, outsideButtons, titleId } = _param, restProps = _object_without_properties(_param, [
    "icon",
    "title",
    "titleComponent",
    "description",
    "descriptionComponent",
    "children",
    "actions",
    "onClose",
    "dismissLabel",
    "size",
    "modalDismissButtonTestId",
    "dismissButtonMode",
    "preventClose",
    "outsideButtons",
    "titleId"
  ]);
  const platform3 = usePlatform();
  const { isDesktop } = useAdaptivityWithJSMediaQueries();
  const size5 = isDesktop ? sizeProp : void 0;
  const withSafeZone = !icon && (dismissButtonMode === "inside" || platform3 === "ios" && !isDesktop && dismissButtonMode !== "none");
  const hasTitle = hasReactNode(title);
  const hasDescription = hasReactNode(description);
  return (0, import_jsx_runtime104.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiInternalModalCardBase", platform3 === "ios" && "vkuiModalCardBase__ios", isDesktop && "vkuiModalCardBase__desktop", withSafeZone && "vkuiModalCardBase__withSafeZone"),
    baseStyle: {
      maxWidth: size5
    },
    children: (0, import_jsx_runtime104.jsxs)("div", {
      className: "vkuiModalCardBase__container",
      children: [
        hasReactNode(icon) && (0, import_jsx_runtime104.jsx)("div", {
          className: "vkuiModalCardBase__icon",
          children: icon
        }),
        hasReactNode(title) && (0, import_jsx_runtime104.jsx)(Title, {
          id: titleId,
          level: "2",
          weight: "2",
          className: "vkuiModalCardBase__title",
          Component: titleComponent,
          children: title
        }),
        hasTitle && hasDescription && (0, import_jsx_runtime104.jsx)(Spacing, {
          size: 8
        }),
        hasDescription && (0, import_jsx_runtime104.jsx)(AdaptivityContext.Provider, {
          value: {
            sizeY: "regular"
          },
          children: (0, import_jsx_runtime104.jsx)(Subhead, {
            className: "vkuiModalCardBase__description",
            Component: descriptionComponent,
            children: description
          })
        }),
        children,
        hasReactNode(actions) && (0, import_jsx_runtime104.jsx)("div", {
          className: "vkuiModalCardBase__actions",
          children: actions
        }),
        isDesktop && (dismissButtonMode === "outside" || outsideButtons) && (0, import_jsx_runtime104.jsxs)(ModalOutsideButtons, {
          children: [
            dismissButtonMode === "outside" && (0, import_jsx_runtime104.jsx)(ModalOutsideButton, {
              "aria-label": dismissLabel,
              "data-testid": modalDismissButtonTestId,
              onClick: onClose,
              children: (0, import_jsx_runtime104.jsx)(Icon20Cancel, {})
            }),
            outsideButtons
          ]
        }),
        (dismissButtonMode === "inside" || platform3 === "ios" && !isDesktop && dismissButtonMode !== "none") && (0, import_jsx_runtime104.jsxs)(Tappable, {
          className: "vkuiModalCardBase__dismiss",
          onClick: onClose,
          hoverMode: "opacity",
          activeMode: "opacity",
          "data-testid": modalDismissButtonTestId,
          children: [
            (0, import_jsx_runtime104.jsx)(VisuallyHidden, {
              children: dismissLabel
            }),
            platform3 === "ios" ? (0, import_jsx_runtime104.jsx)(Icon24Dismiss, {}) : (0, import_jsx_runtime104.jsx)(Icon20Cancel, {})
          ]
        })
      ]
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ModalCard/ModalCardInternal.js
var sizeByPlatformClassNames = {
  vkcom: "vkuiModalCard__hostMaxWidthS",
  ios: "vkuiModalCard__hostMaxWidthM",
  android: "vkuiModalCard__hostMaxWidthL"
};
var transitionStateClassNames3 = {
  appear: "vkuiModalCard__hostStateEnter",
  appearing: "vkuiModalCard__hostStateEntering",
  enter: "vkuiModalCard__hostStateEnter",
  entering: "vkuiModalCard__hostStateEntering",
  exiting: "vkuiModalCard__hostStateExiting",
  exited: "vkuiModalCard__hostStateExited"
};
var ModalCardInternal = (_param) => {
  var { icon, title, titleComponent, description, descriptionComponent, children, actions, size: size5, open, style: styleProp, className, preventClose, ModalOverlay: ModalOverlay2 = ModalOverlay, modalOverlayTestId, modalDismissButtonTestId, getRootRef, dismissButtonMode, dismissLabel, noFocusToDialog, restoreFocus, onOpen, onOpened, onClose = noop, onClosed, disableFocusTrap, disableModalOverlay, disableOpenAnimation, disableCloseAnimation } = _param, restProps = _object_without_properties(_param, [
    "icon",
    "title",
    "titleComponent",
    "description",
    "descriptionComponent",
    "children",
    "actions",
    "size",
    "open",
    "style",
    "className",
    "preventClose",
    "ModalOverlay",
    "modalOverlayTestId",
    "modalDismissButtonTestId",
    "getRootRef",
    "dismissButtonMode",
    "dismissLabel",
    "noFocusToDialog",
    "restoreFocus",
    "onOpen",
    "onOpened",
    "onClose",
    "onClosed",
    "disableFocusTrap",
    "disableModalOverlay",
    "disableOpenAnimation",
    "disableCloseAnimation"
  ]);
  const platform3 = usePlatform();
  const [transitionState, { ref, onTransitionEnd }] = useCSSTransition(open, {
    enableAppear: !disableOpenAnimation,
    enableEnter: !disableOpenAnimation,
    enableExit: !disableCloseAnimation,
    onEnter() {
      onOpen === null || onOpen === void 0 ? void 0 : onOpen();
    },
    onEntered() {
      onOpened === null || onOpened === void 0 ? void 0 : onOpened();
    },
    onExited() {
      onClosed === null || onClosed === void 0 ? void 0 : onClosed();
    }
  });
  const opened = transitionState === "appeared" || transitionState === "entered";
  const hidden = transitionState === "exited";
  const closable = !preventClose && opened;
  const { isDesktop } = useAdaptivityWithJSMediaQueries();
  const bottomSheetEnabled = !isDesktop && !preventClose && transitionState !== "exited";
  const { opened: keyboardOpened } = useVirtualKeyboardState(bottomSheetEnabled);
  const [{ setSheetEl, setBackdropEl }, bottomSheetEventHandlers] = useBottomSheet(bottomSheetEnabled, {
    blocked: keyboardOpened,
    snapPoint: "auto",
    sheetCSSProperty: "--vkui_internal_ModalCard--translateY",
    backdropCSSProperty: "--vkui_internal--modal-overlay--opacity",
    onDismiss() {
      onClose === null || onClose === void 0 ? void 0 : onClose("swipe-down");
    }
  });
  const handleRef = useExternRef(setSheetEl, ref, getRootRef);
  const style = keyboardOpened ? _object_spread_props(_object_spread({}, styleProp), {
    "--vkui_internal_ModalCard--safeAreaInsetBottom": "0px"
  }) : styleProp;
  const modalOverlay = !disableModalOverlay && (0, import_jsx_runtime105.jsx)(ModalOverlay2, {
    getRootRef: setBackdropEl,
    "data-testid": modalOverlayTestId,
    visible: open,
    disableOpenAnimation,
    disableCloseAnimation,
    onClick: closable ? function handleBackdropClick(event) {
      onClose("click-overlay", event);
    } : void 0
  });
  const handleEscKeyDown = (0, import_react22.useCallback)((event) => {
    if (closable && pressedKey(event) === Keys.ESCAPE) {
      onClose("escape-key");
    }
  }, [
    closable,
    onClose
  ]);
  useScrollLock(!hidden);
  useFocusTrap(ref, {
    autoFocus: !noFocusToDialog,
    disabled: !opened || hidden || disableFocusTrap,
    restoreFocus
  });
  return (0, import_jsx_runtime105.jsxs)(ModalOutlet, {
    hidden,
    isDesktop,
    onKeyDown: handleEscKeyDown,
    disableModalOverlay,
    children: [
      modalOverlay,
      (0, import_jsx_runtime105.jsx)(ModalCardBase, _object_spread_props(_object_spread(_object_spread_props(_object_spread({}, restProps), {
        tabIndex: -1,
        role: "dialog",
        "aria-modal": "true",
        getRootRef: handleRef,
        style,
        className: clsx("vkuiModalCard__host", isDesktop ? "vkuiModalCard__hostDesktop" : "vkuiModalCard__hostMobile", sizeByPlatformClassNames[platform3], transitionStateClassNames3[transitionState], className),
        onTransitionEnd
      }), bottomSheetEventHandlers), {
        icon,
        title,
        titleComponent,
        description,
        descriptionComponent,
        actions,
        onClose: () => onClose("click-close-button"),
        size: size5,
        modalDismissButtonTestId,
        dismissButtonMode,
        dismissLabel,
        children
      }))
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/ModalCard/ModalCard.js
var ModalCard = (_param) => {
  var { id: idProp, nav, open = false, modalOverlayTestId, noFocusToDialog, onOpen, onOpened, onClose, onClosed, keepMounted = false, disableModalOverlay } = _param, restProps = _object_without_properties(_param, [
    "id",
    "nav",
    "open",
    "modalOverlayTestId",
    "noFocusToDialog",
    "onOpen",
    "onOpened",
    "onClose",
    "onClosed",
    "keepMounted",
    "disableModalOverlay"
  ]);
  const _useModalManager = useModalManager({
    id: nav || idProp,
    open,
    keepMounted,
    modalOverlayTestId,
    noFocusToDialog,
    disableModalOverlay,
    onOpen,
    onOpened,
    onClose,
    onClosed
  }), { mounted, shouldPreserveSnapPoint: excludedProp, id } = _useModalManager, resolvedProps = _object_without_properties(_useModalManager, [
    "mounted",
    "shouldPreserveSnapPoint",
    "id"
  ]);
  if (mounted === false) {
    return null;
  }
  return (0, import_jsx_runtime106.jsx)(ModalContext.Provider, {
    value: id,
    children: (0, import_jsx_runtime106.jsx)(ModalCardInternal, _object_spread({
      id,
      "aria-labelledby": `${id}-label`,
      titleId: `${id}-label`
    }, resolvedProps, restProps))
  });
};

// node_modules/@vkontakte/vkui/dist/components/Badge/Badge.js
var import_jsx_runtime107 = __toESM(require_jsx_runtime(), 1);
var stylesMode4 = {
  new: "vkuiBadge__modeNew",
  prominent: "vkuiBadge__modeProminent"
};
var Badge = (_param) => {
  var { mode = "new", children } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "children"
  ]);
  return (0, import_jsx_runtime107.jsx)(RootComponent, _object_spread_props(_object_spread({
    Component: "span",
    baseClassName: clsx("vkuiBadge__host", "vkuiInternalBadge", stylesMode4[mode])
  }, restProps), {
    children: children && (0, import_jsx_runtime107.jsx)(VisuallyHidden, {
      children
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ContentBadge/ContentBadge.js
var import_jsx_runtime109 = __toESM(require_jsx_runtime(), 1);
var React114 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/ContentBadge/ContentBadgeContext.js
var React112 = __toESM(require_react(), 1);
var ContentBadgeContext = React112.createContext({
  isSingleChild: false,
  size: "m"
});

// node_modules/@vkontakte/vkui/dist/components/ContentBadge/ContentBadgeIconSlot.js
var import_jsx_runtime108 = __toESM(require_jsx_runtime(), 1);
var React113 = __toESM(require_react(), 1);
var iconsClassNames = {
  m: null,
  l: "vkuiContentBadge__iconSlotSizeL"
};
var singleIconClassNames = {
  m: "vkuiContentBadge__singleIconSlotSizeM",
  l: "vkuiContentBadge__singleIconSlotSizeL"
};
var ContentBadgeIconSlot = (_param) => {
  var { className, getRootRef, children } = _param, restProps = _object_without_properties(_param, [
    "className",
    "getRootRef",
    "children"
  ]);
  const { size: size5, isSingleChild } = React113.useContext(ContentBadgeContext);
  if (size5 === "s") {
    return null;
  }
  return (0, import_jsx_runtime108.jsx)("div", _object_spread_props(_object_spread({
    ref: getRootRef,
    className: clsx(className, isSingleChild ? singleIconClassNames[size5] : iconsClassNames[size5])
  }, restProps), {
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ContentBadge/ContentBadge.js
var appearanceClassNames2 = {
  "accent": {
    primary: "vkuiContentBadge__primaryAccent",
    secondary: "vkuiContentBadge__secondaryAccent",
    outline: "vkuiContentBadge__outlineAccent"
  },
  "neutral": {
    primary: "vkuiContentBadge__primaryNeutral",
    secondary: "vkuiContentBadge__secondaryNeutral",
    outline: "vkuiContentBadge__outlineNeutral"
  },
  "accent-green": {
    primary: "vkuiContentBadge__primaryAccentGreen",
    secondary: "vkuiContentBadge__secondaryAccentGreen",
    outline: "vkuiContentBadge__outlineAccentGreen"
  },
  "accent-red": {
    primary: "vkuiContentBadge__primaryAccentRed",
    secondary: "vkuiContentBadge__secondaryAccentRed",
    outline: "vkuiContentBadge__outlineAccentRed"
  },
  "overlay": {
    primary: "vkuiContentBadge__primaryOverlay",
    secondary: "vkuiContentBadge__secondaryOverlay",
    outline: "vkuiContentBadge__outlineOverlay"
  }
};
var sizeClassNames = {
  s: "vkuiContentBadge__sizeS",
  m: "vkuiContentBadge__sizeM",
  l: "vkuiContentBadge__sizeL"
};
var ContentBadge = (_param) => {
  var { appearance = "accent", mode = "primary", capsule, size: size5 = "m", weight = "2", children } = _param, restProps = _object_without_properties(_param, [
    "appearance",
    "mode",
    "capsule",
    "size",
    "weight",
    "children"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const typographyClassNames = size5 === "l" ? footnoteClassNames(sizeY) : captionClassNames(sizeY);
  return (0, import_jsx_runtime109.jsx)(Tappable, _object_spread_props(_object_spread({
    baseClassName: clsx("vkuiContentBadge__host", size5 !== "s" && capsule && "vkuiContentBadge__capsule", mode === "outline" && "vkuiContentBadge__modeOutline", appearanceClassNames2[appearance][mode], sizeClassNames[size5], typographyClassNames, weightClassNames(weight)),
    DefaultComponent: "span",
    hoverMode: "opacity",
    activeMode: "opacity"
  }, restProps), {
    children: (0, import_jsx_runtime109.jsx)(ContentBadgeContext.Provider, {
      value: {
        isSingleChild: React114.Children.count(children) === 1,
        size: size5
      },
      children
    })
  }));
};
ContentBadge.IconSlot = ContentBadgeIconSlot;
ContentBadge.SlotIcon = ContentBadgeIconSlot;
if (true) {
  defineComponentDisplayNames(ContentBadge.IconSlot, "ContentBadge.IconSlot");
  defineComponentDisplayNames(ContentBadge.SlotIcon, "ContentBadge.SlotIcon");
}

// node_modules/@vkontakte/vkui/dist/components/ButtonGroup/ButtonGroup.js
var import_jsx_runtime110 = __toESM(require_jsx_runtime(), 1);
var stylesMode5 = {
  vertical: "vkuiButtonGroup__modeVertical",
  horizontal: "vkuiButtonGroup__modeHorizontal"
};
var stylesGap = {
  space: "vkuiButtonGroup__gapSpace",
  s: "vkuiButtonGroup__gapS",
  m: "vkuiButtonGroup__gapM"
};
var stylesAlign3 = {
  left: "vkuiButtonGroup__alignLeft",
  center: "vkuiButtonGroup__alignCenter",
  right: "vkuiButtonGroup__alignRight"
};
var ButtonGroup = (_param) => {
  var {
    mode = "horizontal",
    gap = "m",
    stretched = false,
    align = "left"
    /* NOTE: Чтобы блоки по-умолчанию не растягивались на всю ширину контейнера */
  } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "gap",
    "stretched",
    "align"
  ]);
  return (0, import_jsx_runtime110.jsx)(RootComponent, _object_spread({
    baseClassName: clsx("vkuiButtonGroup__host", stylesMode5[mode], gap !== "none" && stylesGap[gap], stretched && "vkuiButtonGroup__stretched", stylesAlign3[align]),
    role: "group"
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Card/Card.js
var import_jsx_runtime111 = __toESM(require_jsx_runtime(), 1);
var Card = (_param) => {
  var { mode = "tint", Component: Component2 = "li" } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "Component"
  ]);
  const withBorder = mode === "outline" || mode === "outline-tint";
  return (0, import_jsx_runtime111.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    Component: Component2,
    baseClassName: clsx("vkuiCard__host", mode === "outline" && "vkuiCard__modeOutline", mode === "shadow" && "vkuiCard__modeShadow", mode === "plain" && "vkuiCard__modePlain", withBorder && "vkuiCard__withBorder")
  }));
};

// node_modules/@vkontakte/vkui/dist/components/CardGrid/CardGrid.js
var import_jsx_runtime112 = __toESM(require_jsx_runtime(), 1);
var sizeXClassNames5 = {
  none: "vkuiCardGrid__sizeXNone",
  compact: "vkuiCardGrid__sizeXCompact"
};
var stylesSize3 = {
  s: "vkuiInternalCardGrid--size-s",
  m: "vkuiInternalCardGrid--size-m",
  l: "vkuiInternalCardGrid--size-l"
};
var CardGrid = (_param) => {
  var { size: size5 = "s", padding = false, Component: Component2 = "ul" } = _param, restProps = _object_without_properties(_param, [
    "size",
    "padding",
    "Component"
  ]);
  const { sizeX = "none" } = useAdaptivity();
  return (0, import_jsx_runtime112.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    Component: Component2,
    baseClassName: clsx("vkuiCardGrid__host", "vkuiInternalCardGrid", padding && "vkuiCardGrid__padding", stylesSize3[size5], sizeX !== "regular" && sizeXClassNames5[sizeX])
  }));
};

// node_modules/@vkontakte/vkui/dist/components/CardScroll/CardScroll.js
var import_jsx_runtime113 = __toESM(require_jsx_runtime(), 1);
var React115 = __toESM(require_react(), 1);
var stylesSize4 = {
  s: "vkuiInternalCardScroll--size-s",
  m: "vkuiInternalCardScroll--size-m",
  l: "vkuiInternalCardScroll--size-l"
};
var CardScroll = (_param) => {
  var { children, size: size5 = "s", showArrows = true, padding = false, CardsListComponent = "ul", prevButtonTestId, nextButtonTestId } = _param, restProps = _object_without_properties(_param, [
    "children",
    "size",
    "showArrows",
    "padding",
    "CardsListComponent",
    "prevButtonTestId",
    "nextButtonTestId"
  ]);
  const refContainer = React115.useRef(null);
  const direction = useConfigDirection();
  const { window: window2 } = useDOM();
  const getPadding = (container) => {
    return parseFloat(window2.getComputedStyle(container).getPropertyValue("--vkui_internal--CardScroll_horizontal_padding"));
  };
  const slideOffsetFromStart = (slide) => {
    var _refContainer_current;
    const containerWidth = ((_refContainer_current = refContainer.current) === null || _refContainer_current === void 0 ? void 0 : _refContainer_current.offsetWidth) || 0;
    return direction === "rtl" ? containerWidth - slide.offsetLeft - slide.offsetWidth : slide.offsetLeft;
  };
  function getScrollToLeft(offset5) {
    if (!refContainer.current) {
      return offset5;
    }
    const containerWidth = refContainer.current.offsetWidth;
    const getMarginEnd = (el) => {
      const computedStyles = window2.getComputedStyle(el);
      return parseInt(computedStyles.marginInlineEnd) || (direction === "rtl" ? parseInt(computedStyles.marginLeft) : parseInt(computedStyles.marginRight)) || 0;
    };
    const slideIndex = [
      ...refContainer.current.children
    ].findIndex((el) => slideOffsetFromStart(el) + el.offsetWidth + getMarginEnd(el) - offset5 >= 0);
    if (slideIndex === -1) {
      return offset5;
    }
    const slide = refContainer.current.children[slideIndex];
    const padding2 = getPadding(refContainer.current);
    const scrollTo = slideOffsetFromStart(slide) - (containerWidth - slide.offsetWidth) + padding2;
    if (scrollTo <= 2 * padding2) {
      return 0;
    }
    return scrollTo;
  }
  function getScrollToRight(offset5) {
    if (!refContainer.current) {
      return offset5;
    }
    const containerWidth = refContainer.current.offsetWidth;
    const slide = Array.prototype.find.call(refContainer.current.children, (el) => {
      return slideOffsetFromStart(el) + el.offsetWidth - offset5 > containerWidth;
    });
    if (!slide) {
      return offset5;
    }
    const padding2 = getPadding(refContainer.current);
    return slideOffsetFromStart(slide) - padding2;
  }
  return (0, import_jsx_runtime113.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiCardScroll__host", "vkuiInternalCardScroll", size5 !== false && stylesSize4[size5], padding && "vkuiCardScroll__withPaddings"),
    children: (0, import_jsx_runtime113.jsx)(HorizontalScroll, {
      getScrollToLeft,
      getScrollToRight,
      showArrows,
      prevButtonTestId,
      nextButtonTestId,
      ContentWrapperComponent: CardsListComponent,
      contentWrapperRef: refContainer,
      contentWrapperClassName: "vkuiCardScroll__in",
      children
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ContentCard/ContentCard.js
var import_jsx_runtime114 = __toESM(require_jsx_runtime(), 1);
var React116 = __toESM(require_react(), 1);
var ContentCard = (_param) => {
  var {
    overTitle,
    title,
    titleComponent = "span",
    description,
    caption,
    // card props
    className,
    mode = "shadow",
    style,
    getRootRef,
    // img props
    getRef,
    maxHeight,
    src,
    srcSet,
    alt = "",
    width = "100%",
    height,
    crossOrigin,
    decoding,
    loading,
    referrerPolicy,
    sizes,
    useMap,
    fetchPriority,
    imageObjectFit,
    hasHover: hasHover2 = false,
    hasActive = false,
    Component: Component2 = "li"
  } = _param, restProps = _object_without_properties(_param, [
    "overTitle",
    "title",
    "titleComponent",
    "description",
    "caption",
    "className",
    "mode",
    "style",
    "getRootRef",
    "getRef",
    "maxHeight",
    "src",
    "srcSet",
    "alt",
    "width",
    "height",
    "crossOrigin",
    "decoding",
    "loading",
    "referrerPolicy",
    "sizes",
    "useMap",
    "fetchPriority",
    "imageObjectFit",
    "hasHover",
    "hasActive",
    "Component"
  ]);
  return (0, import_jsx_runtime114.jsx)(Card, {
    mode,
    getRootRef,
    Component: Component2,
    style,
    className: clsx(restProps.disabled && "vkuiContentCard__disabled", className),
    children: (0, import_jsx_runtime114.jsxs)(Tappable, _object_spread_props(_object_spread({
      hasHover: hasHover2,
      hasActive
    }, restProps), {
      baseClassName: "vkuiContentCard__tappable",
      children: [
        (src || srcSet) && (0, import_jsx_runtime114.jsx)("img", _object_spread_props(_object_spread({
          // safari и firefox нужно чтобы атрибут `loading` был до `src`
          //
          // https://mihaly4.ru/image-loading-lazy-bug
          loading,
          ref: getRef,
          className: "vkuiContentCard__img",
          src,
          srcSet,
          alt,
          crossOrigin,
          decoding,
          referrerPolicy,
          sizes,
          useMap
        }, getFetchPriorityProp(fetchPriority)), {
          height,
          width,
          style: {
            maxHeight,
            objectFit: imageObjectFit
          }
        })),
        (0, import_jsx_runtime114.jsxs)("div", {
          className: "vkuiContentCard__body",
          children: [
            hasReactNode(overTitle) && (0, import_jsx_runtime114.jsx)(Caption, {
              className: clsx("vkuiContentCard__text", "vkuiContentCard__overTitle"),
              weight: "1",
              level: "3",
              caps: true,
              children: overTitle
            }),
            hasReactNode(title) && (0, import_jsx_runtime114.jsx)(Headline, {
              className: "vkuiContentCard__text",
              weight: "2",
              level: "1",
              Component: titleComponent,
              children: title
            }),
            hasReactNode(description) && (0, import_jsx_runtime114.jsx)(Text, {
              className: "vkuiContentCard__text",
              children: description
            }),
            hasReactNode(caption) && (0, import_jsx_runtime114.jsx)(Footnote, {
              className: clsx("vkuiContentCard__text", "vkuiContentCard__caption"),
              children: caption
            })
          ]
        })
      ]
    }))
  });
};

// node_modules/@vkontakte/vkui/dist/components/Header/Header.js
var import_jsx_runtime115 = __toESM(require_jsx_runtime(), 1);
var React117 = __toESM(require_react(), 1);
var sizeClassNames2 = {
  s: "vkuiHeader__sizeS",
  m: "vkuiHeader__sizeM",
  l: "vkuiHeader__sizeL",
  xl: "vkuiHeader__sizeXl"
};
var HeaderContent = (_param) => {
  var { size: size5 } = _param, restProps = _object_without_properties(_param, [
    "size"
  ]);
  switch (size5) {
    case "xl":
      return (0, import_jsx_runtime115.jsx)(Title, _object_spread({
        level: "2",
        weight: "1"
      }, restProps));
    case "l":
      return (0, import_jsx_runtime115.jsx)(Title, _object_spread({
        level: "3",
        weight: "1"
      }, restProps));
    case "m":
      return (0, import_jsx_runtime115.jsx)(Headline, _object_spread({}, restProps));
    case "s":
      return (0, import_jsx_runtime115.jsx)(Footnote, _object_spread({
        caps: true,
        weight: "1"
      }, restProps));
  }
  return null;
};
var Subtitle = ({ subtitleComponent, children, multiline, size: size5 }) => {
  const SubtitleElement = size5 === "m" || size5 === "s" ? Caption : Subhead;
  return (0, import_jsx_runtime115.jsx)(SubtitleElement, {
    className: clsx("vkuiHeader__subtitle", multiline && "vkuiHeader__contentMultiline"),
    Component: subtitleComponent,
    children
  });
};
var Header = (_param) => {
  var { size: size5 = "m", Component: Component2 = "h2", children, subtitle, subtitleComponent = "span", indicator, after, multiline, before, beforeTitle, afterTitle, beforeSubtitle, afterSubtitle } = _param, restProps = _object_without_properties(_param, [
    "size",
    "Component",
    "children",
    "subtitle",
    "subtitleComponent",
    "indicator",
    "after",
    "multiline",
    "before",
    "beforeTitle",
    "afterTitle",
    "beforeSubtitle",
    "afterSubtitle"
  ]);
  return (0, import_jsx_runtime115.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiHeader__host", sizeClassNames2[size5], isPrimitiveReactNode(indicator) && "vkuiHeader__pi"),
    children: [
      before && (0, import_jsx_runtime115.jsx)("div", {
        className: clsx("vkuiHeader__before", subtitle && "vkuiHeader__beforeWithSubtitle"),
        children: before
      }),
      (0, import_jsx_runtime115.jsxs)("div", {
        className: "vkuiHeader__main",
        children: [
          (0, import_jsx_runtime115.jsxs)(HeaderContent, {
            className: "vkuiHeader__content",
            Component: Component2,
            size: size5,
            children: [
              beforeTitle && (0, import_jsx_runtime115.jsx)("div", {
                className: "vkuiHeader__contentBefore",
                children: beforeTitle
              }),
              (0, import_jsx_runtime115.jsx)("span", {
                className: clsx("vkuiHeader__contentIn", multiline && "vkuiHeader__contentMultiline"),
                children
              }),
              afterTitle && (0, import_jsx_runtime115.jsx)("div", {
                className: "vkuiHeader__contentAfter",
                children: afterTitle
              }),
              hasReactNode(indicator) && (0, import_jsx_runtime115.jsx)(Footnote, {
                className: "vkuiHeader__indicator",
                weight: "2",
                children: indicator
              })
            ]
          }),
          hasReactNode(subtitle) && (0, import_jsx_runtime115.jsxs)("div", {
            className: "vkuiHeader__subtitleWrapper",
            children: [
              beforeSubtitle && (0, import_jsx_runtime115.jsx)("div", {
                className: "vkuiHeader__subtitleBefore",
                children: beforeSubtitle
              }),
              (0, import_jsx_runtime115.jsx)(Subtitle, {
                multiline,
                subtitleComponent,
                size: size5,
                children: subtitle
              }),
              afterSubtitle && (0, import_jsx_runtime115.jsx)("div", {
                className: "vkuiHeader__subtitleAfter",
                children: afterSubtitle
              })
            ]
          })
        ]
      }),
      hasReactNode(after) && (0, import_jsx_runtime115.jsx)(Paragraph, {
        className: "vkuiHeader__after",
        Component: "span",
        children: after
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Group/Group.js
var import_jsx_runtime120 = __toESM(require_jsx_runtime(), 1);
var React119 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/Group/GroupContainer.js
var import_jsx_runtime116 = __toESM(require_jsx_runtime(), 1);
var React118 = __toESM(require_react(), 1);
var sizeXClassNames6 = {
  none: clsx("vkuiGroup__sizeXNone", "vkuiInternalGroup--sizeX-none"),
  regular: "vkuiGroup__sizeXRegular",
  compact: "vkuiGroup__sizeXCompact"
};
var stylesMode6 = {
  none: clsx("vkuiGroup__modeNone", "vkuiInternalGroup--mode-none"),
  plain: clsx("vkuiGroup__modePlain", "vkuiInternalGroup--mode-plain"),
  card: clsx("vkuiGroup__modeCard", "vkuiInternalGroup--mode-card")
};
var stylesPadding = {
  s: "vkuiGroup__paddingS",
  m: "vkuiGroup__paddingM"
};
function useGroupMode(forcedMode, sizeX, isInsideModal) {
  const { layout } = React118.useContext(AppRootContext);
  if (forcedMode) {
    return forcedMode;
  }
  if (isInsideModal) {
    return "plain";
  }
  if (layout) {
    return layout;
  }
  if (sizeX !== "none") {
    return sizeX === "regular" ? "card" : "plain";
  }
  return "none";
}
var warn17 = warnOnce("Group");
var GroupContainer = (_param) => {
  var { children, separator = "auto", mode: modeProps, padding = "m", tabIndex: tabIndexProp } = _param, restProps = _object_without_properties(_param, [
    "children",
    "separator",
    "mode",
    "padding",
    "tabIndex"
  ]);
  const isInsideModal = useModalContext().id !== null;
  const { sizeX = "none" } = useAdaptivity();
  const mode = useGroupMode(modeProps, sizeX, isInsideModal);
  const isTabPanel = restProps.role === "tabpanel";
  if (isTabPanel && (!restProps["aria-controls"] || !restProps["id"])) {
    warn17('При использовании роли "tabpanel" необходимо задать значение свойств "aria-controls" и "id"');
  }
  const tabIndex = isTabPanel && tabIndexProp === void 0 ? 0 : tabIndexProp;
  let siblingSeparatorElement = null;
  switch (separator) {
    case "auto":
      siblingSeparatorElement = (0, import_jsx_runtime116.jsx)("div", {
        className: "vkuiGroup__separatorSibling"
      });
      break;
    case "show":
      siblingSeparatorElement = (0, import_jsx_runtime116.jsx)("div", {
        className: clsx("vkuiGroup__separatorSibling", mode === "plain" || mode === "none" ? "vkuiGroup__separatorSiblingForced" : void 0)
      });
      break;
    case "hide":
      break;
  }
  return (0, import_jsx_runtime116.jsxs)(import_jsx_runtime116.Fragment, {
    children: [
      (0, import_jsx_runtime116.jsx)(RootComponent, _object_spread_props(_object_spread({
        Component: "section"
      }, restProps), {
        tabIndex,
        baseClassName: clsx("vkuiInternalGroup", "vkuiGroup__host", sizeXClassNames6[sizeX], mode === "plain" && isInsideModal && "vkuiGroup__modePlainInsideModal", stylesMode6[mode], stylesPadding[padding]),
        children
      })),
      siblingSeparatorElement
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/Group/GroupDescription.js
var import_jsx_runtime117 = __toESM(require_jsx_runtime(), 1);
var GroupDescription = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  return (0, import_jsx_runtime117.jsx)(Footnote, _object_spread({
    className: clsx(className, "vkuiGroup__description")
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Group/GroupExpandedContent.js
var import_jsx_runtime118 = __toESM(require_jsx_runtime(), 1);
var stylesDirection3 = {
  inline: "vkuiGroup__expandedContentInline",
  block: "vkuiGroup__expandedContentBlock"
};
var GroupExpandedContent = (_param) => {
  var { direction = "inline" } = _param, restProps = _object_without_properties(_param, [
    "direction"
  ]);
  return (0, import_jsx_runtime118.jsx)(RootComponent, _object_spread_props(_object_spread({
    Component: "div"
  }, restProps), {
    baseClassName: stylesDirection3[direction]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Group/GroupHeader.js
var import_jsx_runtime119 = __toESM(require_jsx_runtime(), 1);
var GroupHeader = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  return (0, import_jsx_runtime119.jsx)("div", _object_spread({
    className: clsx(className, "vkuiGroup__header")
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Group/Group.js
var Group = (_param) => {
  var { header, description, children } = _param, restProps = _object_without_properties(_param, [
    "header",
    "description",
    "children"
  ]);
  return (0, import_jsx_runtime120.jsxs)(GroupContainer, _object_spread_props(_object_spread({}, restProps), {
    children: [
      hasReactNode(header) && (0, import_jsx_runtime120.jsx)(GroupHeader, {
        children: header
      }),
      children,
      hasReactNode(description) && (0, import_jsx_runtime120.jsx)(GroupDescription, {
        children: description
      })
    ]
  }));
};
Group.Container = GroupContainer;
Group.Header = GroupHeader;
Group.Description = GroupDescription;
Group.ExpandedContent = GroupExpandedContent;
if (true) {
  defineComponentDisplayNames(Group.Container, "Group.Container");
  defineComponentDisplayNames(Group.Header, "Group.Header");
  defineComponentDisplayNames(Group.Description, "Group.Description");
  defineComponentDisplayNames(Group.ExpandedContent, "Group.ExpandedContent");
}

// node_modules/@vkontakte/vkui/dist/components/Gradient/Gradient.js
var import_jsx_runtime121 = __toESM(require_jsx_runtime(), 1);
var modeStyles = {
  overlay: "vkuiGradient__modeOverlay",
  tint: "vkuiGradient__modeTint"
};
var Gradient = (_param) => {
  var { mode = "default", to = "top" } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "to"
  ]);
  return (0, import_jsx_runtime121.jsx)(RootComponent, _object_spread_props(_object_spread({
    role: "presentation"
  }, restProps), {
    baseClassName: clsx("vkuiGradient__host", mode !== "default" && modeStyles[mode], to === "bottom" && "vkuiGradient__toBottom")
  }));
};

// node_modules/@vkontakte/vkui/dist/components/List/List.js
var import_jsx_runtime122 = __toESM(require_jsx_runtime(), 1);
var React121 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useDraggableWithDomApi/constants.js
var AUTO_SCROLL_START_DELAY = 300;
var ITEM_INITIAL_INDEX = -1;
var DATA_DRAGGABLE_PLACEHOLDER_KEY = "data-draggable-placeholder";
var DATA_DRAGGABLE_PLACEHOLDER_REACT_PROP = {
  [DATA_DRAGGABLE_PLACEHOLDER_KEY]: "true"
};

// node_modules/@vkontakte/vkui/dist/hooks/useDraggableWithDomApi/useDraggableWithDomApi.js
var React120 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/lib/rafSchd.js
var rafSchd = (fn) => {
  let lastArgs = [];
  let frameId = null;
  const wrapperFn = (...args) => {
    lastArgs = args;
    if (frameId) {
      return;
    }
    frameId = requestAnimationFrame(() => {
      frameId = null;
      fn(...lastArgs);
    });
  };
  wrapperFn.cancel = () => {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
  };
  return wrapperFn;
};

// node_modules/@vkontakte/vkui/dist/hooks/useDraggableWithDomApi/autoScroll.js
var SCROLL_SPEED = 10;
var EDGE_SIZE = 50;
var getAutoScrollingData = (clientY, scrollEl) => {
  const scrollTop = Math.floor(getNodeScroll(scrollEl).scrollTop);
  const { relative, edges } = getScrollRect(scrollEl);
  const viewportHeight = relative.height;
  const documentHeight = getScrollHeight(scrollEl);
  const maxScrollY = documentHeight - viewportHeight;
  const canScrollUp = scrollTop > 0;
  const canScrollDown = scrollTop < maxScrollY;
  const [edgeTop, edgeBottom] = edges.y;
  const topDistance = clientY - edgeTop;
  const bottomDistance = edgeBottom - clientY;
  const isInTopEdge = topDistance <= EDGE_SIZE;
  const isInBottomEdge = bottomDistance <= EDGE_SIZE;
  const result = {
    shouldScrolling: canScrollUp && isInTopEdge || canScrollDown && isInBottomEdge,
    y: 0
  };
  if (isInTopEdge) {
    result.y = -1 * ((EDGE_SIZE - topDistance) / EDGE_SIZE) * SCROLL_SPEED;
  } else if (isInBottomEdge) {
    result.y = (EDGE_SIZE - bottomDistance) / EDGE_SIZE * SCROLL_SPEED;
  }
  return result;
};
var createAutoScrollController = (scrollEl) => {
  let isRunning = false;
  const scheduledScroll = rafSchd(scroll);
  function scroll(fn) {
    const { shouldScrolling, y } = fn();
    if (shouldScrolling) {
      isRunning = true;
      scrollEl.scrollBy(0, y);
      scheduledScroll(fn);
    } else {
      isRunning = false;
      scheduledScroll.cancel();
    }
  }
  const tryAutoScroll = (fn) => {
    scheduledScroll(fn);
  };
  const stop = () => {
    isRunning = false;
    scheduledScroll.cancel();
  };
  return {
    tryAutoScroll,
    stop,
    get isRunning() {
      return isRunning;
    }
  };
};

// node_modules/@vkontakte/vkui/dist/hooks/useDraggableWithDomApi/utils.js
var getTargetIsOverOrUnderElData = (clientY, elRect) => {
  const elRectHalfHeight = elRect.height / 2;
  return {
    isUnderEl: clientY <= elRect.bottom - elRectHalfHeight,
    isOverEl: clientY >= elRect.top + elRectHalfHeight
  };
};
var setDraggingItemShiftStyles = (draggingEl, nextShiftY) => {
  requestAnimationFrame(() => {
    draggingEl.style.transform = `translateY(${nextShiftY}px)`;
  });
};
var setSiblingItemsShiftStyles = ([{ el, draggingElRect: { height } }, direction], additionalGap = 0) => {
  requestAnimationFrame(() => {
    if (direction === "up") {
      el.style.setProperty("transition", "transform 0.3s ease-in 0s");
      el.style.removeProperty("transform");
    } else {
      el.style.setProperty("transition", "transform 0.3s ease-out 0s");
      el.style.setProperty("transform", `translateY(${height + additionalGap}px)`);
    }
  });
};
var setInitialDraggingItemStyles = ({ el, draggingElRect }) => {
  const { top, left, width, height } = draggingElRect;
  requestAnimationFrame(() => {
    el.style.setProperty("pointer-events", "none");
    el.style.setProperty("position", "fixed");
    el.style.setProperty("top", `${top}px`);
    el.style.setProperty("left", `${left}px`);
    el.style.setProperty("width", `${width}px`);
    el.style.setProperty("height", `${height}px`);
    el.style.setProperty("z-index", "var(--vkui_internal--z_index_cell_dragging)");
    el.style.setProperty("box-sizing", "border-box");
    el.style.setProperty("transform", "translateY(0)");
  });
};
var unsetInitialDraggingItemStyles = ({ el }) => {
  requestAnimationFrame(() => {
    el.style.removeProperty("pointer-events");
    el.style.removeProperty("position");
    el.style.removeProperty("top");
    el.style.removeProperty("left");
    el.style.removeProperty("width");
    el.style.removeProperty("height");
    el.style.removeProperty("z-index");
    el.style.removeProperty("box-sizing");
    el.style.removeProperty("transform");
  });
};
var setInitialPlaceholderItemStyles = ({ el, draggingElRect }) => {
  if (el.firstElementChild) {
    return;
  }
  const { width, height } = draggingElRect;
  const node = el.cloneNode();
  node.style.setProperty("display", "block");
  node.style.setProperty("width", `${width}px`);
  node.style.setProperty("height", `${height}px`);
  node.style.setProperty("pointer-events", "none");
  el.appendChild(node);
  el.style.setProperty("display", "block");
};
var unsetInitialPlaceholderItemStyles = ({ el }) => {
  el.style.display = "";
  el.removeAttribute("style");
  if (el.firstElementChild) {
    el.firstElementChild.remove();
  }
};
var setInitialSiblingItemStyles = ({ el, shifted, draggingElRect }, additionalGap = 0) => {
  const { height } = draggingElRect;
  requestAnimationFrame(() => {
    el.style.setProperty("pointer-events", "none");
    el.style.setProperty("transition", "none 0s ease 0s");
    if (shifted) {
      el.style.setProperty("transform", `translateY(${height + additionalGap}px)`);
    }
  });
};
var unsetInitialSiblingItemStyles = ({ el }) => {
  requestAnimationFrame(() => {
    el.style.removeProperty("pointer-events");
    el.style.removeProperty("transition");
    el.style.removeProperty("transform");
  });
};

// node_modules/@vkontakte/vkui/dist/hooks/useDraggableWithDomApi/useDraggableWithDomApi.js
var useDraggableWithDomApi = ({ elRef: draggingElRef, onDragFinish }) => {
  const [dragging, setDragging] = React120.useState(false);
  const lastClientYRef = React120.useRef(0);
  const lastDragShiftYRef = React120.useRef(0);
  const scrollElRef = React120.useRef(null);
  const lastScrollTopRef = React120.useRef(0);
  const scrollControllerRef = React120.useRef(null);
  const initializeScrollRefs = (draggableEl) => {
    const node = getNearestOverflowAncestor(draggableEl);
    if (node) {
      scrollElRef.current = node;
      lastScrollTopRef.current = getNodeScroll(node).scrollTop;
      scrollControllerRef.current = createAutoScrollController(scrollElRef.current);
    }
  };
  const cleanupScrollRefs = () => {
    var _scrollControllerRef_current;
    lastScrollTopRef.current = 0;
    (_scrollControllerRef_current = scrollControllerRef.current) === null || _scrollControllerRef_current === void 0 ? void 0 : _scrollControllerRef_current.stop();
    scrollElRef.current = scrollControllerRef.current = null;
  };
  const lastDragDirectionRef = React120.useRef(void 0);
  const toggleDragDirection = (prevShiftY, nextShiftY) => {
    const shiftYDiff = prevShiftY - nextShiftY;
    if (shiftYDiff < 0) {
      return "down";
    }
    if (shiftYDiff > 0) {
      return "up";
    }
    return lastDragDirectionRef.current;
  };
  const itemStartIndexRef = React120.useRef(ITEM_INITIAL_INDEX);
  const itemEndIndexRef = React120.useRef(ITEM_INITIAL_INDEX);
  const draggingItemRef = React120.useRef(null);
  const placeholderItemRef = React120.useRef(null);
  const siblingItemsRef = React120.useRef([]);
  const itemsGapRef = React120.useRef(0);
  const initializeItems = (draggingEl) => {
    const draggingElRect = getBoundingClientRect(draggingEl, true);
    const parentElement = draggingEl.parentElement;
    itemsGapRef.current = parentElement ? parseInt(parentElement.style.gridGap) : 0;
    const { children } = parentElement || {
      children: []
    };
    Array.prototype.forEach.call(children, (el, index2) => {
      if (el === draggingEl) {
        itemStartIndexRef.current = itemEndIndexRef.current = index2;
        draggingItemRef.current = {
          index: index2,
          el,
          draggingElRect
        };
      } else if (el.getAttribute(DATA_DRAGGABLE_PLACEHOLDER_KEY) !== null) {
        placeholderItemRef.current = {
          index: index2,
          el,
          draggingElRect
        };
      } else {
        siblingItemsRef.current.push({
          index: index2,
          el,
          shifted: itemStartIndexRef.current !== ITEM_INITIAL_INDEX && itemStartIndexRef.current < index2,
          draggingElRect
        });
      }
    });
    if (placeholderItemRef.current) {
      setInitialPlaceholderItemStyles(placeholderItemRef.current);
    }
    if (draggingItemRef.current) {
      setInitialDraggingItemStyles(draggingItemRef.current);
    }
    siblingItemsRef.current.forEach((sibling) => setInitialSiblingItemStyles(sibling, itemsGapRef.current));
  };
  const cleanupItems = () => {
    if (placeholderItemRef.current) {
      unsetInitialPlaceholderItemStyles(placeholderItemRef.current);
    }
    if (draggingItemRef.current) {
      unsetInitialDraggingItemStyles(draggingItemRef.current);
    }
    siblingItemsRef.current.forEach(unsetInitialSiblingItemStyles);
    siblingItemsRef.current = [];
    placeholderItemRef.current = draggingItemRef.current = null;
    const swappedItemIndexRange = {
      from: itemStartIndexRef.current,
      to: itemEndIndexRef.current
    };
    itemStartIndexRef.current = itemEndIndexRef.current = ITEM_INITIAL_INDEX;
    return swappedItemIndexRange;
  };
  const getShiftAndUnshiftItemsPreparedData = (clientY) => {
    const shiftItemEls = [];
    const unshiftItemEls = [];
    itemEndIndexRef.current = itemStartIndexRef.current;
    siblingItemsRef.current.forEach((siblingItem) => {
      const { isOverEl, isUnderEl } = getTargetIsOverOrUnderElData(clientY, getBoundingClientRect(siblingItem.el));
      if (itemStartIndexRef.current < siblingItem.index) {
        if (isOverEl) {
          itemEndIndexRef.current = itemEndIndexRef.current + 1;
          if (lastDragDirectionRef.current === "down" && siblingItem.shifted) {
            siblingItem.shifted = false;
            shiftItemEls.push([
              siblingItem,
              "up"
            ]);
          }
        }
        if (isUnderEl) {
          if (lastDragDirectionRef.current === "up" && !siblingItem.shifted) {
            siblingItem.shifted = true;
            unshiftItemEls.push([
              siblingItem,
              "down"
            ]);
          }
        }
      } else if (itemStartIndexRef.current > siblingItem.index) {
        if (isUnderEl) {
          itemEndIndexRef.current = itemEndIndexRef.current - 1;
          if (lastDragDirectionRef.current === "up" && !siblingItem.shifted) {
            siblingItem.shifted = true;
            shiftItemEls.push([
              siblingItem,
              "down"
            ]);
          }
        }
        if (isOverEl) {
          if (lastDragDirectionRef.current === "down" && siblingItem.shifted) {
            siblingItem.shifted = false;
            unshiftItemEls.push([
              siblingItem,
              "up"
            ]);
          }
        }
      }
    });
    return [
      shiftItemEls,
      unshiftItemEls
    ];
  };
  const setShiftAndUnshiftItemStyles = (shiftItemEls, unshiftItemEls) => {
    shiftItemEls.forEach((item) => setSiblingItemsShiftStyles(item, itemsGapRef.current));
    unshiftItemEls.forEach((item) => setSiblingItemsShiftStyles(item, itemsGapRef.current));
  };
  const schedulingAutoScrollTimeoutIdRef = React120.useRef(null);
  const clearSchedulingAutoScrollTimeout = () => {
    if (schedulingAutoScrollTimeoutIdRef.current) {
      clearTimeout(schedulingAutoScrollTimeoutIdRef.current);
      schedulingAutoScrollTimeoutIdRef.current = null;
    }
  };
  const tryAutoScroll = () => {
    if (scrollControllerRef.current) {
      scrollControllerRef.current.tryAutoScroll(() => {
        return scrollElRef.current ? getAutoScrollingData(lastClientYRef.current, scrollElRef.current) : {
          shouldScrolling: false,
          y: 0
        };
      });
    }
  };
  const schedulingAutoScroll = () => {
    clearSchedulingAutoScrollTimeout();
    schedulingAutoScrollTimeoutIdRef.current = setTimeout(() => {
      schedulingAutoScrollTimeoutIdRef.current = null;
      tryAutoScroll();
    }, AUTO_SCROLL_START_DELAY);
  };
  const onDragStart = (event) => {
    event.originalEvent.stopPropagation();
    event.originalEvent.preventDefault();
  };
  const onDragMove = (event) => {
    event.originalEvent.stopPropagation();
    event.originalEvent.preventDefault();
    const draggingEl = draggingElRef.current;
    if (!draggingEl) {
      return;
    }
    if (dragging) {
      lastDragDirectionRef.current = toggleDragDirection(lastDragShiftYRef.current, event.shiftY);
      lastDragShiftYRef.current = event.shiftY;
      lastClientYRef.current = event.clientY;
      if (scrollControllerRef.current && scrollControllerRef.current.isRunning) {
        setDraggingItemShiftStyles(draggingEl, lastDragShiftYRef.current);
      } else {
        const [shiftItemEls, unshiftItemEls] = getShiftAndUnshiftItemsPreparedData(lastClientYRef.current);
        setDraggingItemShiftStyles(draggingEl, lastDragShiftYRef.current);
        setShiftAndUnshiftItemStyles(shiftItemEls, unshiftItemEls);
        schedulingAutoScroll();
      }
    } else {
      setDragging((prevDragging) => {
        if (prevDragging) {
          return prevDragging;
        }
        cleanupItems();
        initializeScrollRefs(draggingEl);
        initializeItems(draggingEl);
        return true;
      });
    }
  };
  const onDragEnd = (event) => {
    event.originalEvent.stopPropagation();
    event.originalEvent.preventDefault();
    clearSchedulingAutoScrollTimeout();
    cleanupScrollRefs();
    lastClientYRef.current = lastDragShiftYRef.current = 0;
    lastDragDirectionRef.current = void 0;
    if (dragging) {
      const swappedItemRange = cleanupItems();
      if (onDragFinish) {
        onDragFinish(swappedItemRange);
      }
      setDragging(false);
    }
  };
  const handleScroll = React120.useCallback(() => {
    if (!draggingElRef.current || !scrollElRef.current) {
      return;
    }
    const nextScrollTop = getNodeScroll(scrollElRef.current).scrollTop;
    lastDragDirectionRef.current = toggleDragDirection(lastScrollTopRef.current, nextScrollTop);
    const scrollDiff = lastScrollTopRef.current - nextScrollTop;
    const clientYWithScrollOffset = lastClientYRef.current + scrollDiff;
    lastScrollTopRef.current = nextScrollTop;
    const [shiftItemEls, unshiftItemEls] = getShiftAndUnshiftItemsPreparedData(clientYWithScrollOffset);
    setShiftAndUnshiftItemStyles(shiftItemEls, unshiftItemEls);
  }, [
    draggingElRef
  ]);
  useIsomorphicLayoutEffect(function recalculateOnScroll() {
    const scrollEl = scrollElRef.current;
    if (!dragging || !scrollEl) {
      return;
    }
    scrollEl.addEventListener("scroll", handleScroll);
    return () => {
      if (scrollEl) {
        scrollEl.removeEventListener("scroll", handleScroll);
      }
    };
  }, [
    dragging,
    handleScroll
  ]);
  useIsomorphicLayoutEffect(() => function componentWillUnmount() {
    if (placeholderItemRef.current) {
      unsetInitialPlaceholderItemStyles(placeholderItemRef.current);
    }
  }, []);
  return {
    dragging,
    onDragStart,
    onDragMove,
    onDragEnd
  };
};

// node_modules/@vkontakte/vkui/dist/components/List/List.js
var List = (_param) => {
  var { children, gap = 0 } = _param, restProps = _object_without_properties(_param, [
    "children",
    "gap"
  ]);
  return (0, import_jsx_runtime122.jsxs)(RootComponent, _object_spread_props(_object_spread({
    role: "list",
    baseClassName: "vkuiList__host",
    baseStyle: {
      gridGap: gap
    }
  }, restProps), {
    children: [
      children,
      (0, import_jsx_runtime122.jsx)("div", _object_spread_props(_object_spread({
        "aria-hidden": true
      }, DATA_DRAGGABLE_PLACEHOLDER_REACT_PROP), {
        className: "vkuiList__placeholder"
      }))
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Cell/Cell.js
var import_jsx_runtime129 = __toESM(require_jsx_runtime(), 1);
var React127 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/Removable/Removable.js
var import_jsx_runtime124 = __toESM(require_jsx_runtime(), 1);
var React123 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/Removable/RemovableIos.js
var import_jsx_runtime123 = __toESM(require_jsx_runtime(), 1);
var React122 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useGlobalEventListener.js
function useGlobalEventListener(element, event, cb, options) {
  const listener = useEventListener(event, cb, options);
  useIsomorphicLayoutEffect(() => {
    if (cb && element) {
      listener.add(element);
    } else {
      listener.remove();
    }
  }, [
    Boolean(cb),
    Boolean(element)
  ]);
}

// node_modules/@vkontakte/vkui/dist/components/Removable/RemovableIos.js
var RemovableIosWithRemove = ({ onRemove, removePlaceholder, removePlaceholderString, children: childrenProp, toggleButtonTestId, removeButtonTestId, disabled }) => {
  const direction = useConfigDirection();
  const isRtl = direction === "rtl";
  const { window: window2 } = useDOM();
  const removeButtonRef = React122.useRef(null);
  const disabledRef = React122.useRef(true);
  const [removeOffset, updateRemoveOffset] = React122.useState(0);
  useGlobalEventListener(window2, "click", () => {
    if (removeOffset > 0) {
      updateRemoveOffset(0);
    }
  }, {
    capture: true
  });
  const onRemoveTransitionEnd = () => {
    if (removeOffset > 0) {
      var _removeButtonRef_current;
      removeButtonRef === null || removeButtonRef === void 0 ? void 0 : (_removeButtonRef_current = removeButtonRef.current) === null || _removeButtonRef_current === void 0 ? void 0 : _removeButtonRef_current.focus();
    } else {
      disabledRef.current = true;
    }
  };
  const onRemoveActivateClick = (e) => {
    e.stopPropagation();
    if (!removeButtonRef.current) {
      return;
    }
    const { offsetWidth } = removeButtonRef.current;
    disabledRef.current = false;
    updateRemoveOffset(offsetWidth);
  };
  const style = {
    "--vkui_internal_Removable_remove_offset": String(removeOffset !== null && removeOffset !== void 0 ? removeOffset : 0)
  };
  return (0, import_jsx_runtime123.jsxs)("div", {
    className: clsx("vkuiRemovable__content", isRtl && "vkuiRemovable__rtl", "vkuiInternalRemovable__content"),
    style,
    onTransitionEnd: onRemoveTransitionEnd,
    children: [
      (0, import_jsx_runtime123.jsxs)(IconButton, {
        hasActive: false,
        hasHover: false,
        className: clsx("vkuiRemovable__action", "vkuiRemovable__toggle", "vkuiInternalRemovable__action"),
        onClick: onRemoveActivateClick,
        disabled: removeOffset > 0 || disabled,
        "data-testid": toggleButtonTestId,
        children: [
          (0, import_jsx_runtime123.jsx)(VisuallyHidden, {
            children: removePlaceholderString
          }),
          (0, import_jsx_runtime123.jsx)("i", {
            className: "vkuiRemovable__toggleIn",
            role: "presentation"
          })
        ]
      }),
      typeof childrenProp === "function" ? childrenProp({
        isRemoving: removeOffset > 0
      }) : childrenProp,
      (0, import_jsx_runtime123.jsx)("span", {
        className: "vkuiRemovable__offset",
        "aria-hidden": true
      }),
      (0, import_jsx_runtime123.jsx)(Tappable, {
        Component: "button",
        hasActive: false,
        hasHover: false,
        disabled: disabledRef.current,
        getRootRef: removeButtonRef,
        className: "vkuiRemovable__remove",
        onClick: onRemove,
        "data-testid": removeButtonTestId,
        children: (0, import_jsx_runtime123.jsx)("span", {
          className: "vkuiRemovable__removeIn",
          children: removePlaceholder
        })
      })
    ]
  });
};
var RemovableIosWithIndent = ({ children: childrenProp }) => {
  return (0, import_jsx_runtime123.jsxs)("div", {
    className: clsx("vkuiRemovable__content", "vkuiInternalRemovable__content"),
    children: [
      (0, import_jsx_runtime123.jsx)("div", {
        className: clsx("vkuiRemovable__action", "vkuiRemovable__indentation", "vkuiInternalRemovable__action")
      }),
      typeof childrenProp === "function" ? childrenProp({
        isRemoving: false
      }) : childrenProp,
      (0, import_jsx_runtime123.jsx)("span", {
        className: "vkuiRemovable__offset",
        "aria-hidden": true
      })
    ]
  });
};
var RemovableIos = (_param) => {
  var { indent, children } = _param, restProps = _object_without_properties(_param, [
    "indent",
    "children"
  ]);
  return indent ? (0, import_jsx_runtime123.jsx)(RemovableIosWithIndent, {
    children
  }) : (0, import_jsx_runtime123.jsx)(RemovableIosWithRemove, _object_spread_props(_object_spread({}, restProps), {
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Removable/Removable.js
var RemovableCommon = ({ noPadding, children, removePlaceholderString, onRemoveClick, removeButtonTestId, disabled, indent }) => {
  return (0, import_jsx_runtime124.jsxs)("div", {
    className: clsx("vkuiRemovable__content", !noPadding && "vkuiRemovable__withPadding", "vkuiInternalRemovable__content"),
    children: [
      typeof children === "function" ? children({
        isRemoving: false
      }) : children,
      indent ? (0, import_jsx_runtime124.jsx)("div", {
        className: clsx("vkuiRemovable__action", "vkuiRemovable__indentation")
      }) : (0, import_jsx_runtime124.jsx)(IconButton, {
        activeMode: "opacity",
        hoverMode: "opacity",
        className: clsx("vkuiRemovable__action", "vkuiInternalRemovable__action"),
        onClick: onRemoveClick,
        label: removePlaceholderString,
        "data-testid": removeButtonTestId,
        disabled,
        children: (0, import_jsx_runtime124.jsx)(Icon24Cancel, {
          role: "presentation"
        })
      }),
      (0, import_jsx_runtime124.jsx)("span", {
        className: "vkuiRemovable__offset",
        "aria-hidden": true
      })
    ]
  });
};
var Removable = (_param) => {
  var { children, onRemove, removePlaceholder = "Удалить", align = "center", indent = false, toggleButtonTestId, removeButtonTestId, disabled, noPadding } = _param, restProps = _object_without_properties(_param, [
    "children",
    "onRemove",
    "removePlaceholder",
    "align",
    "indent",
    "toggleButtonTestId",
    "removeButtonTestId",
    "disabled",
    "noPadding"
  ]);
  const platform3 = usePlatform();
  const onRemoveClick = (e) => {
    e.preventDefault();
    onRemove === null || onRemove === void 0 ? void 0 : onRemove(e);
  };
  const removePlaceholderString = getTextFromChildren(removePlaceholder);
  return (0, import_jsx_runtime124.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx(platform3 === "ios" && "vkuiRemovable__ios", align === "start" && "vkuiRemovable__alignStart", indent && "vkuiRemovable__indent"),
    children: platform3 === "ios" ? (0, import_jsx_runtime124.jsx)(RemovableIos, {
      onRemove: onRemoveClick,
      removePlaceholder,
      removePlaceholderString,
      toggleButtonTestId,
      removeButtonTestId,
      disabled,
      indent,
      children
    }) : (0, import_jsx_runtime124.jsx)(RemovableCommon, {
      onRemoveClick,
      noPadding,
      removeButtonTestId,
      removePlaceholderString,
      disabled,
      indent,
      children
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/SimpleCell/SimpleCell.js
var import_jsx_runtime126 = __toESM(require_jsx_runtime(), 1);
var React125 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/SimpleCell/Chevron/Chevron.js
var import_jsx_runtime125 = __toESM(require_jsx_runtime(), 1);
var React124 = __toESM(require_react(), 1);
var iconSize = {
  s: Icon16Chevron,
  m: Icon24ChevronCompactRight
};
var Chevron = (_param) => {
  var { size: size5 = "m" } = _param, restProps = _object_without_properties(_param, [
    "size"
  ]);
  const Icon = iconSize[size5];
  return (0, import_jsx_runtime125.jsx)(Icon, _object_spread({}, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/SimpleCell/SimpleCell.js
var sizeYClassNames16 = {
  none: "vkuiSimpleCell__sizeYNone",
  compact: "vkuiSimpleCell__sizeYCompact"
};
var SimpleCell = (_param) => {
  var { badgeBeforeTitle, badgeAfterTitle, badgeBeforeSubtitle, badgeAfterSubtitle, before, indicator, children, after, chevron, multiline, overTitle, subtitle, extraSubtitle, chevronSize = "m" } = _param, restProps = _object_without_properties(_param, [
    "badgeBeforeTitle",
    "badgeAfterTitle",
    "badgeBeforeSubtitle",
    "badgeAfterSubtitle",
    "before",
    "indicator",
    "children",
    "after",
    "chevron",
    "multiline",
    "overTitle",
    "subtitle",
    "extraSubtitle",
    "chevronSize"
  ]);
  const platform3 = usePlatform();
  const hasChevron = chevron === "always" || chevron === "auto" && platform3 === "ios";
  const hasAfter = hasReactNode(after) || hasChevron;
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime126.jsxs)(Tappable, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiSimpleCell__host", restProps.disabled && "vkuiSimpleCell__disabled", sizeY !== "regular" && sizeYClassNames16[sizeY], multiline && "vkuiSimpleCell__mult"),
    children: [
      (0, import_jsx_runtime126.jsx)("div", {
        className: clsx("vkuiSimpleCell__before", platform3 === "ios" && "vkuiSimpleCell__beforeIos"),
        children: before
      }),
      (0, import_jsx_runtime126.jsxs)("div", {
        className: "vkuiSimpleCell__middle",
        children: [
          overTitle && (0, import_jsx_runtime126.jsxs)(Subhead, {
            Component: "span",
            className: clsx("vkuiSimpleCell__text", "vkuiSimpleCell__overTitle"),
            children: [
              overTitle,
              (0, import_jsx_runtime126.jsx)(VisuallyHidden, {
                children: " "
              })
            ]
          }),
          (0, import_jsx_runtime126.jsxs)("div", {
            className: "vkuiSimpleCell__content",
            children: [
              badgeBeforeTitle && (0, import_jsx_runtime126.jsx)("span", {
                className: "vkuiSimpleCell__badge",
                children: badgeBeforeTitle
              }),
              (0, import_jsx_runtime126.jsxs)(Headline, {
                Component: "span",
                className: "vkuiSimpleCell__children",
                weight: "3",
                children: [
                  children,
                  (0, import_jsx_runtime126.jsx)(VisuallyHidden, {
                    children: " "
                  })
                ]
              }),
              hasReactNode(badgeAfterTitle) && (0, import_jsx_runtime126.jsx)("span", {
                className: "vkuiSimpleCell__badge",
                children: badgeAfterTitle
              })
            ]
          }),
          subtitle && (0, import_jsx_runtime126.jsxs)("div", {
            className: "vkuiSimpleCell__content",
            children: [
              badgeBeforeSubtitle && (0, import_jsx_runtime126.jsx)("span", {
                className: "vkuiSimpleCell__badge",
                children: badgeBeforeSubtitle
              }),
              (0, import_jsx_runtime126.jsxs)(Footnote, {
                normalize: false,
                className: clsx("vkuiSimpleCell__text", "vkuiSimpleCell__subtitle"),
                children: [
                  subtitle,
                  (0, import_jsx_runtime126.jsx)(VisuallyHidden, {
                    children: " "
                  })
                ]
              }),
              badgeAfterSubtitle && (0, import_jsx_runtime126.jsx)("span", {
                className: "vkuiSimpleCell__badge",
                children: badgeAfterSubtitle
              })
            ]
          }),
          extraSubtitle && (0, import_jsx_runtime126.jsxs)(Footnote, {
            className: clsx("vkuiSimpleCell__text", "vkuiSimpleCell__extraSubtitle"),
            children: [
              extraSubtitle,
              (0, import_jsx_runtime126.jsx)(VisuallyHidden, {
                children: " "
              })
            ]
          })
        ]
      }),
      hasReactNode(indicator) && (0, import_jsx_runtime126.jsx)(Headline, {
        Component: "span",
        weight: "3",
        className: "vkuiSimpleCell__indicator",
        children: indicator
      }),
      hasAfter && (0, import_jsx_runtime126.jsxs)("div", {
        className: clsx("vkuiSimpleCell__after", "vkuiInternalSimpleCell__after"),
        children: [
          after,
          hasChevron && (0, import_jsx_runtime126.jsx)(Chevron, {
            size: chevronSize,
            className: "vkuiSimpleCell__chevronIcon"
          })
        ]
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Cell/CellCheckbox/CellCheckbox.js
var import_jsx_runtime127 = __toESM(require_jsx_runtime(), 1);
var React126 = __toESM(require_react(), 1);
var CheckBoxOn = () => (0, import_jsx_runtime127.jsx)(AdaptiveIconRenderer, {
  IconCompact: Icon20CheckBoxOn,
  IconRegular: Icon24CheckBoxOn
});
var CheckBoxOff = () => (0, import_jsx_runtime127.jsx)(AdaptiveIconRenderer, {
  IconCompact: Icon20CheckBoxOff,
  IconRegular: Icon24CheckBoxOff
});
var CheckCircleOn = () => (0, import_jsx_runtime127.jsx)(AdaptiveIconRenderer, {
  IconCompact: Icon20CheckCircleOn,
  IconRegular: Icon24CheckCircleOn
});
var CheckCircleOff = () => (0, import_jsx_runtime127.jsx)(AdaptiveIconRenderer, {
  IconCompact: Icon20CheckCircleOff,
  IconRegular: Icon24CheckCircleOff
});
function useTypeIcon(type) {
  const platform3 = usePlatform();
  if (type !== "auto") {
    return type;
  }
  if (platform3 === "ios" || platform3 === "vkcom") {
    return "circle";
  }
  return "square";
}
var CellCheckbox = (_param) => {
  var { getRootRef, getRef, className, style, type = "auto" } = _param, restProps = _object_without_properties(_param, [
    "getRootRef",
    "getRef",
    "className",
    "style",
    "type"
  ]);
  const typeIcon = useTypeIcon(type);
  const IconOff = typeIcon === "circle" ? CheckCircleOff : CheckBoxOff;
  const IconOn = typeIcon === "circle" ? CheckCircleOn : CheckBoxOn;
  return (0, import_jsx_runtime127.jsxs)("span", {
    className: clsx("vkuiCellCheckbox__host", className),
    style,
    ref: getRootRef,
    children: [
      (0, import_jsx_runtime127.jsx)(VisuallyHidden, _object_spread_props(_object_spread({}, restProps), {
        Component: "input",
        type: "checkbox",
        className: "vkuiCellCheckbox__input",
        getRootRef: getRef
      })),
      (0, import_jsx_runtime127.jsx)("span", {
        className: clsx("vkuiCellCheckbox__icon", "vkuiCellCheckbox__iconOff"),
        "aria-hidden": true,
        children: (0, import_jsx_runtime127.jsx)(IconOff, {})
      }),
      (0, import_jsx_runtime127.jsx)("span", {
        className: clsx("vkuiCellCheckbox__icon", "vkuiCellCheckbox__iconOn"),
        "aria-hidden": true,
        children: (0, import_jsx_runtime127.jsx)(IconOn, {})
      })
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/Cell/CellDragger/CellDragger.js
var import_jsx_runtime128 = __toESM(require_jsx_runtime(), 1);
var CellDragger = (_param) => {
  var { elRef, disabled, className, onDragStateChange, onDragFinish, children } = _param, restProps = _object_without_properties(_param, [
    "elRef",
    "disabled",
    "className",
    "onDragStateChange",
    "onDragFinish",
    "children"
  ]);
  const platform3 = usePlatform();
  const Icon = platform3 === "ios" ? Icon24ReorderIos : Icon24Reorder;
  const { dragging, onDragStart, onDragMove, onDragEnd } = useDraggableWithDomApi({
    elRef,
    onDragFinish
  });
  useIsomorphicLayoutEffect(() => {
    if (onDragStateChange) {
      onDragStateChange(dragging);
    }
  }, [
    dragging,
    onDragStateChange
  ]);
  return (0, import_jsx_runtime128.jsxs)(Touch, _object_spread_props(_object_spread({
    className: clsx("vkuiCellDragger__host", className),
    onStart: disabled ? void 0 : onDragStart,
    onMoveY: disabled ? void 0 : onDragMove,
    onEnd: disabled ? void 0 : onDragEnd
  }, restProps), {
    children: [
      children && (0, import_jsx_runtime128.jsx)(VisuallyHidden, {
        children
      }),
      (0, import_jsx_runtime128.jsx)(Icon, {
        className: "vkuiCellDragger__icon"
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Cell/constants.js
var DEFAULT_DRAGGABLE_LABEL = "Перенести ячейку";

// node_modules/@vkontakte/vkui/dist/components/Cell/Cell.js
var Cell = (_param) => {
  var { mode, onRemove, removePlaceholder = "Удалить", onDragFinish, before, after, disabled, draggable, Component: ComponentProps, onChange, name, value, checked, defaultChecked, getRootRef, draggerLabel = DEFAULT_DRAGGABLE_LABEL, className, style, toggleButtonTestId, removeButtonTestId, draggerTestId, href: hrefProp } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "onRemove",
    "removePlaceholder",
    "onDragFinish",
    "before",
    "after",
    "disabled",
    "draggable",
    "Component",
    "onChange",
    "name",
    "value",
    "checked",
    "defaultChecked",
    "getRootRef",
    "draggerLabel",
    "className",
    "style",
    "toggleButtonTestId",
    "removeButtonTestId",
    "draggerTestId",
    "href"
  ]);
  const [dragging, setDragging] = React127.useState(false);
  const selectable = mode === "selectable";
  const removable = mode === "removable";
  const Component2 = selectable ? "label" : ComponentProps;
  const href = selectable ? void 0 : hrefProp;
  const platform3 = usePlatform();
  const rootElRef = useExternRef(getRootRef);
  const dragger = draggable ? (0, import_jsx_runtime129.jsx)(CellDragger, {
    elRef: rootElRef,
    className: clsx("vkuiCell__dragger", !before && !selectable && "vkuiCell__controlNoBefore"),
    onDragStateChange: setDragging,
    onDragFinish,
    "data-testid": draggerTestId,
    children: draggerLabel
  }) : null;
  let checkbox;
  if (selectable) {
    const checkboxProps = {
      name,
      value,
      defaultChecked,
      checked,
      disabled,
      onChange
    };
    checkbox = (0, import_jsx_runtime129.jsx)(CellCheckbox, _object_spread({
      className: clsx("vkuiCell__checkbox", !before && "vkuiCell__controlNoBefore")
    }, checkboxProps));
  }
  const hasActive = !disabled && !dragging;
  const cellClasses = clsx("vkuiCell__host", dragging && "vkuiCell__dragging", platform3 === "ios" && "vkuiCell__ios", removable && "vkuiCell__removable");
  const simpleCellProps = _object_spread_props(_object_spread(_object_spread_props(_object_spread({
    hasActive,
    hasHover: hasActive && !removable,
    disabled,
    href
  }, restProps), {
    className: "vkuiCell__content"
  }), Component2 && {
    Component: Component2
  }), {
    before: (0, import_jsx_runtime129.jsxs)(React127.Fragment, {
      children: [
        draggable && platform3 !== "ios" && dragger,
        selectable && checkbox,
        before
      ]
    }),
    after: (0, import_jsx_runtime129.jsxs)(React127.Fragment, {
      children: [
        draggable && platform3 === "ios" && dragger,
        after
      ]
    })
  });
  if (removable) {
    return (0, import_jsx_runtime129.jsx)(Removable, {
      className: clsx(cellClasses, className),
      style,
      getRootRef: rootElRef,
      removePlaceholder,
      onRemove: (e) => onRemove === null || onRemove === void 0 ? void 0 : onRemove(e, rootElRef.current),
      toggleButtonTestId,
      removeButtonTestId,
      disabled,
      children: platform3 === "ios" ? ({ isRemoving }) => {
        return (0, import_jsx_runtime129.jsx)(SimpleCell, _object_spread({}, simpleCellProps, isRemoving ? {
          onClick: void 0
        } : {}));
      } : (0, import_jsx_runtime129.jsx)(SimpleCell, _object_spread({}, simpleCellProps))
    });
  }
  return (0, import_jsx_runtime129.jsx)("div", {
    className: clsx(cellClasses, className),
    style,
    ref: rootElRef,
    children: (0, import_jsx_runtime129.jsx)(SimpleCell, _object_spread({}, simpleCellProps))
  });
};
Cell.Checkbox = CellCheckbox;

// node_modules/@vkontakte/vkui/dist/components/RichCell/RichCell.js
var import_jsx_runtime131 = __toESM(require_jsx_runtime(), 1);
var React128 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/RichCell/RichCellIcon/RichCellIcon.js
var import_jsx_runtime130 = __toESM(require_jsx_runtime(), 1);
var RichCellIcon = (props) => {
  return (0, import_jsx_runtime130.jsx)(RootComponent, _object_spread({
    baseClassName: "vkuiRichCellIcon__host"
  }, props));
};

// node_modules/@vkontakte/vkui/dist/components/RichCell/RichCell.js
var sizeYClassNames17 = {
  none: "vkuiRichCell__sizeYNone",
  compact: "vkuiRichCell__sizeYCompact"
};
var alignAfterClassNames = {
  start: "vkuiRichCell__alignAfterStart",
  center: "vkuiRichCell__alignAfterCenter",
  end: "vkuiRichCell__alignAfterEnd"
};
var alignBeforeClassNames = {
  start: "vkuiRichCell__alignBeforeStart",
  center: "vkuiRichCell__alignBeforeCenter",
  end: "vkuiRichCell__alignBeforeEnd"
};
var alignContentClassNames = {
  start: "vkuiRichCell__contentAlignStart",
  center: "vkuiRichCell__contentAlignCenter",
  end: "vkuiRichCell__contentAlignEnd"
};
var RichCell = (_param) => {
  var { overTitle, children, subtitle, extraSubtitle, before, after, afterCaption, bottom, actions, multiline, beforeAlign = "start", contentAlign = "start", afterAlign = "start" } = _param, restProps = _object_without_properties(_param, [
    "overTitle",
    "children",
    "subtitle",
    "extraSubtitle",
    "before",
    "after",
    "afterCaption",
    "bottom",
    "actions",
    "multiline",
    "beforeAlign",
    "contentAlign",
    "afterAlign"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const withAfter = after || afterCaption;
  const afterRender = () => {
    if (!withAfter) {
      return;
    }
    return (0, import_jsx_runtime131.jsxs)("div", {
      className: "vkuiRichCell__contentAfter",
      children: [
        after && (0, import_jsx_runtime131.jsx)("div", {
          className: "vkuiRichCell__afterChildren",
          children: after
        }),
        afterCaption && (0, import_jsx_runtime131.jsx)("div", {
          className: "vkuiRichCell__afterCaption",
          children: afterCaption
        })
      ]
    });
  };
  return (0, import_jsx_runtime131.jsxs)(Tappable, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiRichCell__host", !multiline && "vkuiRichCell__textEllipsis", sizeY !== "regular" && sizeYClassNames17[sizeY], withAfter && "vkuiRichCell__withAfter", withAfter && alignAfterClassNames[afterAlign], before && alignBeforeClassNames[beforeAlign], alignContentClassNames[contentAlign]),
    children: [
      before && (0, import_jsx_runtime131.jsx)("div", {
        className: "vkuiRichCell__before",
        children: before
      }),
      (0, import_jsx_runtime131.jsxs)("div", {
        className: "vkuiRichCell__in",
        children: [
          (0, import_jsx_runtime131.jsxs)("div", {
            className: "vkuiRichCell__content",
            children: [
              (0, import_jsx_runtime131.jsxs)("div", {
                className: "vkuiRichCell__contentBefore",
                children: [
                  overTitle && (0, import_jsx_runtime131.jsx)(Subhead, {
                    Component: "div",
                    className: "vkuiRichCell__overTitle",
                    children: overTitle
                  }),
                  (0, import_jsx_runtime131.jsx)("div", {
                    className: "vkuiRichCell__children",
                    children
                  }),
                  subtitle && (0, import_jsx_runtime131.jsx)("div", {
                    className: "vkuiRichCell__subtitle",
                    children: subtitle
                  }),
                  extraSubtitle && (0, import_jsx_runtime131.jsx)(Subhead, {
                    Component: "div",
                    className: "vkuiRichCell__extraSubtitle",
                    children: extraSubtitle
                  })
                ]
              }),
              afterAlign === "start" && afterRender()
            ]
          }),
          bottom && (0, import_jsx_runtime131.jsx)("div", {
            className: "vkuiRichCell__bottom",
            children: bottom
          }),
          actions && (0, import_jsx_runtime131.jsx)("div", {
            className: "vkuiRichCell__actions",
            children: actions
          })
        ]
      }),
      afterAlign !== "start" && afterRender()
    ]
  }));
};
RichCell.Icon = RichCellIcon;

// node_modules/@vkontakte/vkui/dist/components/CellButton/CellButton.js
var import_jsx_runtime132 = __toESM(require_jsx_runtime(), 1);
var appearanceClassNames3 = {
  accent: "vkuiCellButton__appearanceAccent",
  neutral: "vkuiCellButton__appearanceNeutral",
  negative: "vkuiCellButton__appearanceNegative"
};
var CellButton = (_param) => {
  var { centered = false, appearance = "accent", className } = _param, restProps = _object_without_properties(_param, [
    "centered",
    "appearance",
    "className"
  ]);
  return (0, import_jsx_runtime132.jsx)(SimpleCell, _object_spread_props(_object_spread({}, restProps), {
    className: clsx("vkuiCellButton__host", appearanceClassNames3[appearance], centered && "vkuiCellButton__centered", className)
  }));
};

// node_modules/@vkontakte/vkui/dist/components/CellButtonGroup/CellButtonGroup.js
var import_jsx_runtime134 = __toESM(require_jsx_runtime(), 1);
var React129 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/CellButtonGroup/CellButtonGroupSeparator/CellButtonGroupSeparator.js
var import_jsx_runtime133 = __toESM(require_jsx_runtime(), 1);
var CellButtonGroupSeparator = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  return (0, import_jsx_runtime133.jsx)(Separator, _object_spread_props(_object_spread({
    className: clsx("vkuiCellButtonGroupSeparator__root", className)
  }, restProps), {
    direction: "vertical",
    padding: true
  }));
};

// node_modules/@vkontakte/vkui/dist/components/CellButtonGroup/CellButtonGroup.js
var CellButtonGroup = (props) => {
  return (0, import_jsx_runtime134.jsx)(ButtonGroup, _object_spread({
    gap: "none",
    stretched: true
  }, props));
};
CellButtonGroup.Separator = CellButtonGroupSeparator;
if (true) {
  defineComponentDisplayNames(CellButtonGroup.Separator, "CellButtonGroup.Separator");
}

// node_modules/@vkontakte/vkui/dist/components/HorizontalCell/HorizontalCell.js
var import_jsx_runtime139 = __toESM(require_jsx_runtime(), 1);
var React133 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/Avatar/Avatar.js
var import_jsx_runtime138 = __toESM(require_jsx_runtime(), 1);

// node_modules/@vkontakte/vkui/dist/components/Avatar/AvatarBadge/AvatarBadge.js
var import_jsx_runtime135 = __toESM(require_jsx_runtime(), 1);
var React130 = __toESM(require_react(), 1);
var AvatarBadge = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  const { size: size5 } = React130.useContext(ImageBaseContext);
  return (0, import_jsx_runtime135.jsx)(ImageBase.Badge, _object_spread_props(_object_spread({}, restProps), {
    className: clsx("vkuiAvatarBadge__host", size5 < 96 && "vkuiAvatarBadge__shifted", className)
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Avatar/AvatarBadge/AvatarBadgeWithPreset.js
var import_jsx_runtime137 = __toESM(require_jsx_runtime(), 1);
var React132 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/Avatar/AvatarBadge/icons.js
var import_jsx_runtime136 = __toESM(require_jsx_runtime(), 1);
var React131 = __toESM(require_react(), 1);
var Icon12Circle2 = (_param) => {
  var { width, height } = _param, restProps = _object_without_properties(_param, [
    "width",
    "height"
  ]);
  return (0, import_jsx_runtime136.jsx)(Icon12Circle, _object_spread_props(_object_spread({}, restProps), {
    width: width >= 24 ? 15 : 12,
    height: height >= 24 ? 15 : 12
  }));
};
var Icon12OnlineMobile2 = (_param) => {
  var { width, height } = _param, restProps = _object_without_properties(_param, [
    "width",
    "height"
  ]);
  return (0, import_jsx_runtime136.jsx)(Icon12OnlineMobile, _object_spread_props(_object_spread({}, restProps), {
    width: width >= 24 ? 9 : 8,
    height: height >= 24 ? 15 : 12
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Avatar/AvatarBadge/AvatarBadgeWithPreset.js
var AvatarBadgeWithPreset = (_param) => {
  var { preset = "online", className } = _param, restProps = _object_without_properties(_param, [
    "preset",
    "className"
  ]);
  const direction = useConfigDirection();
  const isRtl = direction === "rtl";
  const { size: size5 } = React132.useContext(ImageBaseContext);
  const badgeSize = getBadgeIconSizeByImageBaseSize(size5);
  const isOnlinePreset = preset === "online";
  const presetClassName = isOnlinePreset ? "vkuiAvatarBadge__presetOnline" : "vkuiAvatarBadge__presetOnlineMobile";
  const Icon = isOnlinePreset ? Icon12Circle2 : Icon12OnlineMobile2;
  return (0, import_jsx_runtime137.jsx)(ImageBase.Badge, _object_spread_props(_object_spread({
    background: "stroke",
    className: clsx("vkuiAvatarBadge__host", isRtl && "vkuiAvatarBadge__rtl", presetClassName, className)
  }, restProps), {
    children: (0, import_jsx_runtime137.jsx)(Icon, {
      width: badgeSize,
      height: badgeSize
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Avatar/helpers.js
var MAX_FONT_SIZE = 30;
var MAX_IMAGE_BASE_SIZE = 96;
var RELATIVE_SIZE = MAX_FONT_SIZE / MAX_IMAGE_BASE_SIZE;
var getInitialsFontSize = (avatarSize) => {
  if (avatarSize <= 16) {
    return 5;
  } else if (avatarSize <= 24) {
    return 8;
  } else if (avatarSize <= 32) {
    return 10;
  } else if (avatarSize <= 36) {
    return 13;
  } else if (avatarSize <= 44) {
    return 14;
  } else if (avatarSize <= 48) {
    return 17;
  } else if (avatarSize < 56) {
    return 18;
  } else if (avatarSize <= 64) {
    return 21;
  } else if (avatarSize <= 88) {
    return 26;
  } else if (avatarSize <= MAX_IMAGE_BASE_SIZE) {
    return MAX_FONT_SIZE;
  }
  const calculatedFontSize = Math.ceil(avatarSize * RELATIVE_SIZE);
  const evenFix = calculatedFontSize % 2;
  return calculatedFontSize + evenFix;
};

// node_modules/@vkontakte/vkui/dist/components/Avatar/Avatar.js
var AVATAR_DEFAULT_SIZE = 48;
var COLORS_NUMBER_TO_TEXT_MAP = {
  1: "red",
  2: "orange",
  3: "yellow",
  4: "green",
  5: "l-blue",
  6: "violet"
};
var gradientStyles = {
  "red": "vkuiAvatar__gradientRed",
  "orange": "vkuiAvatar__gradientOrange",
  "yellow": "vkuiAvatar__gradientYellow",
  "green": "vkuiAvatar__gradientGreen",
  "blue": "vkuiAvatar__gradientBlue",
  "l-blue": "vkuiAvatar__gradientLBlue",
  "violet": "vkuiAvatar__gradientViolet"
};
var Avatar = (_param) => {
  var { size: size5 = AVATAR_DEFAULT_SIZE, className, gradientColor, initials, fallbackIcon: fallbackIconProp, children } = _param, restProps = _object_without_properties(_param, [
    "size",
    "className",
    "gradientColor",
    "initials",
    "fallbackIcon",
    "children"
  ]);
  const gradientName = typeof gradientColor === "number" ? COLORS_NUMBER_TO_TEXT_MAP[gradientColor] : gradientColor;
  const isGradientNotCustom = gradientName && gradientName !== "custom";
  const fallbackIcon = initials ? (0, import_jsx_runtime138.jsx)("div", {
    className: "vkuiAvatar__initials",
    style: {
      fontSize: getInitialsFontSize(size5)
    },
    children: initials
  }) : fallbackIconProp;
  return (0, import_jsx_runtime138.jsx)(ImageBase, _object_spread_props(_object_spread({}, restProps), {
    size: size5,
    fallbackIcon,
    className: clsx("vkuiAvatar__host", gradientName && "vkuiAvatar__hasGradient", isGradientNotCustom && gradientStyles[gradientName], className),
    children
  }));
};
Avatar.Badge = AvatarBadge;
Avatar.BadgeWithPreset = AvatarBadgeWithPreset;
Avatar.Overlay = ImageBaseOverlay;
Avatar.getInitialsFontSize = getInitialsFontSize;
if (true) {
  defineComponentDisplayNames(Avatar.Badge, "Avatar.Badge");
  defineComponentDisplayNames(Avatar.BadgeWithPreset, "Avatar.BadgeWithPreset");
  defineComponentDisplayNames(Avatar.Overlay, "Avatar.Overlay");
}

// node_modules/@vkontakte/vkui/dist/components/HorizontalCell/HorizontalCell.js
var CUSTOM_CSS_TOKEN_FOR_CELL_WIDTH = "--vkui_internal--cell_width";
var stylesSize5 = {
  s: "vkuiHorizontalCell__sizeS",
  m: "vkuiHorizontalCell__sizeM",
  l: "vkuiHorizontalCell__sizeL",
  xl: "vkuiHorizontalCell__sizeXL",
  auto: "vkuiHorizontalCell__sizeAuto"
};
var textAlignClassNames = {
  center: "vkuiHorizontalCell__textAlignCenter",
  end: "vkuiHorizontalCell__textAlignEnd"
};
var HorizontalCell = (_param) => {
  var { className, title, style, subtitle, size: size5 = "s", children = (0, import_jsx_runtime139.jsx)(Avatar, {
    size: 56
  }), getRootRef, getRef, extraSubtitle, textAlign = size5 === "s" ? "center" : "start", noPadding = false, TitleComponent = size5 === "s" ? Caption : Subhead } = _param, restProps = _object_without_properties(_param, [
    "className",
    "title",
    "style",
    "subtitle",
    "size",
    "children",
    "getRootRef",
    "getRef",
    "extraSubtitle",
    "textAlign",
    "noPadding",
    "TitleComponent"
  ]);
  const hasTypography = hasReactNode(title) || hasReactNode(subtitle) || hasReactNode(extraSubtitle);
  const customProperties = typeof size5 === "number" ? {
    [CUSTOM_CSS_TOKEN_FOR_CELL_WIDTH]: `${size5}px`
  } : void 0;
  return (0, import_jsx_runtime139.jsx)("div", {
    ref: getRootRef,
    style: mergeStyle(customProperties, style),
    className: clsx("vkuiHorizontalCell__host", typeof size5 === "string" && stylesSize5[size5], size5 !== "auto" && "vkuiHorizontalCell__sized", typeof size5 === "number" && "vkuiHorizontalCell__customSize", noPadding && "vkuiHorizontalCell__noPadding", className),
    children: (0, import_jsx_runtime139.jsxs)(Tappable, _object_spread_props(_object_spread({
      className: "vkuiHorizontalCell__body",
      getRootRef: getRef
    }, restProps), {
      children: [
        hasReactNode(children) && (0, import_jsx_runtime139.jsx)("div", {
          className: "vkuiHorizontalCell__image",
          children
        }),
        hasTypography && (0, import_jsx_runtime139.jsxs)("div", {
          className: clsx("vkuiHorizontalCell__content", textAlign !== "start" && textAlignClassNames[textAlign]),
          children: [
            hasReactNode(title) && (0, import_jsx_runtime139.jsx)(TitleComponent, {
              children: title
            }),
            hasReactNode(subtitle) && (0, import_jsx_runtime139.jsx)(Footnote, {
              className: "vkuiHorizontalCell__subtitle",
              children: subtitle
            }),
            hasReactNode(extraSubtitle) && (0, import_jsx_runtime139.jsx)(Footnote, {
              className: "vkuiHorizontalCell__subtitle",
              children: extraSubtitle
            })
          ]
        })
      ]
    }))
  });
};

// node_modules/@vkontakte/vkui/dist/components/HorizontalScroll/HorizontalCellShowMore/HorizontalCellShowMore.js
var import_jsx_runtime140 = __toESM(require_jsx_runtime(), 1);
var sizeClassNames3 = {
  s: "vkuiHorizontalCellShowMore__sizeS",
  m: "vkuiHorizontalCellShowMore__sizeM"
};
var HorizontalCellShowMore = (_param) => {
  var { className, style, getRef, getRootRef, height, size: size5 = "s", children = size5 === "s" ? "Все" : "Показать все", centered = false } = _param, restProps = _object_without_properties(_param, [
    "className",
    "style",
    "getRef",
    "getRootRef",
    "height",
    "size",
    "children",
    "centered"
  ]);
  return (0, import_jsx_runtime140.jsx)("div", {
    style,
    className: clsx("vkuiHorizontalCellShowMore__host", centered && "vkuiHorizontalCellShowMore__centered", sizeClassNames3[size5], className),
    ref: getRootRef,
    children: (0, import_jsx_runtime140.jsxs)(Tappable, _object_spread_props(_object_spread({
      style: size5 === "s" ? void 0 : {
        height
      },
      className: "vkuiHorizontalCellShowMore__body",
      getRootRef: getRef,
      activeMode: "opacity",
      hoverMode: "opacity"
    }, restProps), {
      children: [
        (0, import_jsx_runtime140.jsx)(Icon28ChevronRightCircle, {
          className: "vkuiHorizontalCellShowMore__icon"
        }),
        (0, import_jsx_runtime140.jsx)(Subhead, {
          className: "vkuiHorizontalCellShowMore__text",
          weight: "2",
          children
        })
      ]
    }))
  });
};

// node_modules/@vkontakte/vkui/dist/components/Footer/Footer.js
var import_jsx_runtime141 = __toESM(require_jsx_runtime(), 1);
var React134 = __toESM(require_react(), 1);
var Footer = (_param) => {
  var { children, className, Component: Component2 = "footer", role: roleProp } = _param, restProps = _object_without_properties(_param, [
    "children",
    "className",
    "Component",
    "role"
  ]);
  const role = roleProp !== null && roleProp !== void 0 ? roleProp : Component2 === "footer" ? "contentinfo" : void 0;
  return (0, import_jsx_runtime141.jsx)(Footnote, _object_spread_props(_object_spread({
    Component: Component2,
    role,
    align: "center"
  }, restProps), {
    className: clsx("vkuiFooter__host", className),
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/InfoRow/InfoRow.js
var import_jsx_runtime142 = __toESM(require_jsx_runtime(), 1);
var React135 = __toESM(require_react(), 1);
var InfoRow = (_param) => {
  var { header, children, className } = _param, restProps = _object_without_properties(_param, [
    "header",
    "children",
    "className"
  ]);
  return (0, import_jsx_runtime142.jsxs)(Headline, _object_spread_props(_object_spread({}, restProps), {
    Component: "span",
    className: clsx("vkuiInfoRow__host", className),
    weight: "3",
    children: [
      hasReactNode(header) && (0, import_jsx_runtime142.jsxs)(Subhead, {
        Component: "strong",
        className: "vkuiInfoRow__header",
        children: [
          header,
          (0, import_jsx_runtime142.jsx)(VisuallyHidden, {
            children: " "
          })
        ]
      }),
      children
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Gallery/Gallery.js
var import_jsx_runtime147 = __toESM(require_jsx_runtime(), 1);
var React141 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/CarouselBase/CarouselBase.js
var import_jsx_runtime146 = __toESM(require_jsx_runtime(), 1);
var React139 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/CarouselBase/Bullets.js
var import_jsx_runtime143 = __toESM(require_jsx_runtime(), 1);
var stylesBullets = {
  dark: "vkuiCarouselBase__bulletsDark",
  light: "vkuiCarouselBase__bulletsLight"
};
var Bullets = ({ bullets, slideIndex, count, bulletTestId }) => {
  return (0, import_jsx_runtime143.jsx)("div", {
    "aria-hidden": true,
    className: clsx("vkuiCarouselBase__bullets", stylesBullets[bullets]),
    children: Array.from({
      length: count
    }).map((_, index2) => (0, import_jsx_runtime143.jsx)("div", {
      className: clsx("vkuiCarouselBase__bullet", index2 === slideIndex && "vkuiCarouselBase__bulletActive"),
      "data-testid": bulletTestId === null || bulletTestId === void 0 ? void 0 : bulletTestId(index2, index2 === slideIndex)
    }, index2))
  });
};

// node_modules/@vkontakte/vkui/dist/components/CarouselBase/CarouselViewPort.js
var import_jsx_runtime144 = __toESM(require_jsx_runtime(), 1);
var React136 = __toESM(require_react(), 1);
var defaultSlideLabel = (index2, slidesCount) => `${index2 + 1} из ${slidesCount}`;
var CarouselViewPort = ({ slideTestId, slideWidth, slideLabel = defaultSlideLabel, slideRoleDescription = "Слайд", onChange, onStart, onMoveX, onEnd, getRootRef, layerRef, children, setSlideRef, slidesContainerId }) => {
  const slidesCount = React136.Children.count(children);
  const onSlideFocus = React136.useCallback((e) => onChange === null || onChange === void 0 ? void 0 : onChange(Number(e.currentTarget.dataset.index)), [
    onChange
  ]);
  return (0, import_jsx_runtime144.jsx)(Touch, {
    className: "vkuiCarouselBase__viewport",
    onStartX: onStart,
    onMoveX,
    onEnd,
    style: {
      width: slideWidth === "custom" ? "100%" : slideWidth
    },
    noSlideClick: true,
    getRootRef,
    children: (0, import_jsx_runtime144.jsx)("div", {
      className: "vkuiCarouselBase__layer",
      ref: layerRef,
      id: slidesContainerId,
      children: React136.Children.map(children, (item, i) => (0, import_jsx_runtime144.jsx)("div", {
        role: "group",
        "aria-roledescription": slideRoleDescription,
        "aria-label": typeof slideLabel === "function" ? slideLabel(i, slidesCount) : slideLabel,
        className: "vkuiCarouselBase__slide",
        "data-testid": slideTestId === null || slideTestId === void 0 ? void 0 : slideTestId(i),
        ref: (el) => setSlideRef(el, i),
        "data-index": i,
        tabIndex: 0,
        onFocus: onSlideFocus,
        children: item
      }, `slide-${i}`))
    })
  });
};

// node_modules/@vkontakte/vkui/dist/components/CarouselBase/ScrollArrows.js
var import_jsx_runtime145 = __toESM(require_jsx_runtime(), 1);
var React137 = __toESM(require_react(), 1);
var stylesArrowAreaHeight = {
  stretch: "vkuiCarouselBase__arrowAreaStretch",
  fit: "vkuiCarouselBase__arrowAreaFit"
};
var getArrowClassName = (side, arrowAreaHeight, focusVisible) => {
  return clsx("vkuiCarouselBase__arrow", side === "start" ? "vkuiCarouselBase__arrowStart" : "vkuiCarouselBase__arrowEnd", stylesArrowAreaHeight[arrowAreaHeight], focusVisible && "vkuiCarouselBase__arrowFocusVisible");
};
var ScrollArrows = ({ canSlideLeft, canSlideRight, onSlideRight, onSlideLeft, showArrows = false, arrowSize = "m", arrowAreaHeight = "stretch", arrowPrevLabel, arrowNextLabel, nextArrowTestId, prevArrowTestId, slidesContainerId }) => {
  const _useFocusVisible = useFocusVisible(), { focusVisible: prevArrowFocusVisible } = _useFocusVisible, prevArrowFocusHandlers = _object_without_properties(_useFocusVisible, [
    "focusVisible"
  ]);
  const _useFocusVisible1 = useFocusVisible(), { focusVisible: nextArrowFocusVisible } = _useFocusVisible1, nextArrowFocusHandlers = _object_without_properties(_useFocusVisible1, [
    "focusVisible"
  ]);
  return showArrows ? (0, import_jsx_runtime145.jsxs)(import_jsx_runtime145.Fragment, {
    children: [
      canSlideLeft && (0, import_jsx_runtime145.jsx)(ScrollArrow, _object_spread({
        className: getArrowClassName("start", arrowAreaHeight, prevArrowFocusVisible),
        direction: "left",
        onClick: onSlideLeft,
        size: arrowSize,
        "data-testid": prevArrowTestId,
        label: arrowPrevLabel,
        "aria-controls": slidesContainerId
      }, prevArrowFocusHandlers)),
      canSlideRight && (0, import_jsx_runtime145.jsx)(ScrollArrow, _object_spread({
        className: getArrowClassName("end", arrowAreaHeight, nextArrowFocusVisible),
        direction: "right",
        onClick: onSlideRight,
        size: arrowSize,
        "data-testid": nextArrowTestId,
        label: arrowNextLabel,
        "aria-controls": slidesContainerId
      }, nextArrowFocusHandlers))
    ]
  }) : null;
};

// node_modules/@vkontakte/vkui/dist/components/CarouselBase/constants.js
var DEFAULT_ANIMATION_DURATION = 240;
var SLIDE_THRESHOLD = 0.05;
var CONTROL_ELEMENTS_STATE = {
  canSlideLeft: true,
  canSlideRight: true,
  isDraggable: true
};
var SLIDES_MANAGER_STATE = {
  viewportOffsetWidth: 0,
  slides: [],
  isFullyVisible: true,
  loopPoints: [],
  contentSize: 0,
  snaps: [],
  containerWidth: 0,
  layerWidth: 0,
  min: 0,
  max: 0
};

// node_modules/@vkontakte/vkui/dist/helpers/getValueByKey.js
var getRequiredValueByKey = (key, map) => {
  if (!map.hasOwnProperty(key)) {
    throw new Error(`getRequiredValueByKey(${key})`);
  }
  return map[key];
};

// node_modules/@vkontakte/vkui/dist/components/CarouselBase/helpers.js
var revertRtlValue2 = (n, isRtl) => {
  return isRtl ? -n : n;
};
var isBigger = (a, b, isRtl) => isRtl ? a < b : a > b;
var isBiggerOrEqual = (a, b, isRtl) => isRtl ? a <= b : a >= b;
var isLower = (a, b, isRtl) => isRtl ? a > b : a < b;
var isLowerOrEqual = (a, b, isRtl) => isRtl ? a >= b : a <= b;
var validateIndent = (slidesManager, value, isRtl, bounded = true) => {
  var _slidesManager_max;
  const localMax = (_slidesManager_max = slidesManager.max) !== null && _slidesManager_max !== void 0 ? _slidesManager_max : 0;
  var _slidesManager_min;
  const localMin = (_slidesManager_min = slidesManager.min) !== null && _slidesManager_min !== void 0 ? _slidesManager_min : 0;
  const moreThanMax = isBigger(value, localMax, isRtl);
  if (moreThanMax) {
    if (bounded) {
      return localMax;
    } else {
      return localMax + Number((value - localMax) / 3);
    }
  }
  const lessThanMin = isLower(value, localMin, isRtl);
  if (lessThanMin) {
    if (bounded) {
      return localMin;
    } else {
      return localMin + Number((value - localMin) / 3);
    }
  }
  return value;
};
function calculateIndent2({ targetIndex, slidesManager, isCenter, looped = false, isRtl = false }) {
  if (!slidesManager.slides.length) {
    return 0;
  }
  const targetSlide = slidesManager.slides[targetIndex];
  if (targetSlide) {
    const { coordX: coordX2, width } = targetSlide;
    if (isCenter) {
      return revertRtlValue2(slidesManager.containerWidth / 2 - coordX2 - width / 2, isRtl);
    }
    const indent = revertRtlValue2(-1 * coordX2, isRtl);
    return looped ? indent : validateIndent(slidesManager, indent, isRtl);
  }
  return 0;
}
function getShiftedIndexes(direction, slides, availableWidth) {
  let gap = availableWidth;
  const shiftedSlideIndexes = [];
  const startIndex = direction === 1 ? 0 : slides.length - 1;
  const endIndex = direction === 1 ? slides.length - 1 : 0;
  for (let i = startIndex; (direction === 1 ? i <= endIndex : i >= endIndex) && gap > 0; i += direction) {
    const slideWidth = slides[i].width;
    if (gap > 0) {
      shiftedSlideIndexes.push(i);
    }
    gap -= slideWidth;
  }
  return shiftedSlideIndexes;
}
function calculateLoopPoints(indexes, edge, slidesManager, containerWidth, isRtl) {
  const { contentSize, slides, snaps } = slidesManager;
  const isStartEdge = edge === "start";
  const offset5 = isStartEdge ? -contentSize : contentSize;
  return indexes.map((index2) => {
    const initial = revertRtlValue2(isStartEdge ? 0 : -contentSize, isRtl);
    const altered = revertRtlValue2(isStartEdge ? contentSize : 0, isRtl);
    const snap = revertRtlValue2(snaps[index2], isRtl);
    const firstSnap = revertRtlValue2(snaps[0], isRtl);
    const loopPoint = revertRtlValue2(isStartEdge ? snap + containerWidth + offset5 : snap - slides[index2].width + offset5 - firstSnap, isRtl);
    return {
      index: index2,
      target: (currentLocation) => isBiggerOrEqual(currentLocation, loopPoint, isRtl) ? initial : altered
    };
  });
}
function getLoopPoints(slidesManager, containerWidth, isRtl = false) {
  const { slides, snaps } = slidesManager;
  const firstSnap = revertRtlValue2(snaps[0], isRtl);
  const startShiftedIndexes = getShiftedIndexes(-1, slides, firstSnap);
  const endShiftedIndexes = getShiftedIndexes(1, slides, containerWidth - firstSnap);
  return [
    ...calculateLoopPoints(endShiftedIndexes, "start", slidesManager, containerWidth, isRtl),
    ...calculateLoopPoints(startShiftedIndexes, "end", slidesManager, containerWidth, isRtl)
  ];
}
function getTargetIndex({ slides, slideIndex, currentShiftX, currentShiftXDelta, looped = false, max: max2 = null, isRtl = false }) {
  max2 = max2 !== null && max2 !== void 0 ? max2 : 0;
  const shift5 = revertRtlValue2(currentShiftX + currentShiftXDelta - max2, isRtl);
  const direction = isLower(currentShiftXDelta, 0, isRtl) ? 1 : -1;
  let targetIndex = slides.reduce((val, item, index2) => {
    const previousCoordX = slides[val].coordX;
    const currentCoordX = item.coordX;
    const previousValue = Math.abs(previousCoordX + shift5);
    const currentValue = Math.abs(currentCoordX + shift5);
    return previousValue < currentValue ? val : index2;
  }, slideIndex);
  if (targetIndex === slideIndex) {
    let targetSlide = slideIndex + direction;
    if (targetSlide >= 0 && targetSlide < slides.length) {
      if (Math.abs(currentShiftXDelta) > slides[targetSlide].width * SLIDE_THRESHOLD) {
        return targetSlide;
      }
      return targetIndex;
    }
    if (!looped) {
      return direction < 0 ? Math.max(targetIndex, 0) : Math.min(targetIndex, slides.length - 1);
    }
    return direction < 0 ? (targetSlide + slides.length) % slides.length : targetSlide % slides.length;
  }
  return targetIndex;
}
var calcMin = ({ containerWidth = 0, layerWidth = 0, slides = [], viewportOffsetWidth = 0, isFullyVisible, align, isRtl = false }) => {
  if (align !== "center" && isFullyVisible) {
    return 0;
  }
  const result = getRequiredValueByKey(align, {
    left: () => containerWidth - layerWidth,
    right: () => viewportOffsetWidth - layerWidth,
    center: () => {
      const { coordX: coordX2, width } = slides[slides.length - 1];
      return containerWidth / 2 - coordX2 - width / 2;
    }
  })();
  return revertRtlValue2(result, isRtl);
};
var calcMax = ({ slides = [], containerWidth = 0, isCenterAlign, isRtl = false }) => {
  if (isCenterAlign && slides.length) {
    const { width, coordX: coordX2 } = slides[0];
    const result = containerWidth / 2 - coordX2 - width / 2;
    return revertRtlValue2(result, isRtl);
  }
  return 0;
};

// node_modules/@vkontakte/vkui/dist/components/CarouselBase/hooks.js
var React138 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/lib/animate.js
function animate2({ duration, timing, draw, animationQueue = [] }) {
  if (!canUseDOM) {
    return;
  }
  let start;
  requestAnimationFrame(function animate3(time) {
    if (!start) {
      start = time;
    }
    let timeFraction = Math.min((time - start) / duration, 1);
    const progress = timing(timeFraction);
    draw(progress);
    if (timeFraction < 1) {
      requestAnimationFrame(animate3);
      return;
    }
    animationQueue.shift();
    if (animationQueue.length > 0) {
      animationQueue[0]();
    }
  });
}

// node_modules/@vkontakte/vkui/dist/components/CarouselBase/hooks.js
var PRESET_ANIMATION_EASING = {
  "linear": [
    0,
    0,
    1,
    1
  ],
  "ease": [
    0.25,
    0.1,
    0.25,
    1
  ],
  "ease-in": [
    0.42,
    0,
    1,
    1
  ],
  "ease-out": [
    0,
    0,
    0.58,
    1
  ],
  "ease-in-out": [
    0.42,
    0,
    0.58,
    1
  ]
};
function useSlideAnimation(animationDuration, animationEasing) {
  const animationQueue = React138.useRef([]);
  function getAnimateFunction(drawFunction) {
    return () => {
      animate2({
        duration: animationDuration,
        timing: getAnimationTiming(animationEasing),
        animationQueue: animationQueue.current,
        draw: drawFunction
      });
    };
  }
  function addToAnimationQueue(func) {
    animationQueue.current.push(func);
  }
  function startAnimation() {
    if (animationQueue.current.length === 1) {
      animationQueue.current[0]();
    }
  }
  function animationInQueue() {
    return !!animationQueue.current.length;
  }
  function getAnimationEasing() {
    return `cubic-bezier(${(typeof animationEasing === "string" ? PRESET_ANIMATION_EASING[animationEasing] : animationEasing).join(", ")})`;
  }
  return {
    animationInQueue,
    getAnimateFunction,
    addToAnimationQueue,
    startAnimation,
    getAnimationEasing
  };
}
function getAnimationTiming(animationEasing) {
  if (typeof animationEasing === "string") {
    return cubicBezier(...PRESET_ANIMATION_EASING[animationEasing]);
  }
  return cubicBezier(...animationEasing);
}

// node_modules/@vkontakte/vkui/dist/components/CarouselBase/CarouselBase.js
var warn18 = warnOnce("Gallery");
var CarouselBase = (_param) => {
  var {
    bullets = false,
    getRootRef,
    children,
    slideWidth = "100%",
    slideIndex = 0,
    dragDisabled = false,
    resizeSource = "window",
    onDragStart,
    onDragEnd,
    onChange,
    onPrevClick,
    onNextClick,
    onPointerEnter,
    onPointerLeave,
    align = "left",
    showArrows,
    getRef,
    arrowSize,
    arrowAreaHeight,
    slideTestId,
    bulletTestId,
    nextArrowTestId,
    prevArrowTestId,
    looped = false,
    animationDuration = DEFAULT_ANIMATION_DURATION,
    animationEasing = "ease",
    // a11y
    "aria-roledescription": ariaRoleDescription = "Карусель",
    arrowNextLabel = "Следующий слайд",
    arrowPrevLabel = "Предыдущий слайд",
    slideLabel,
    slideRoleDescription
  } = _param, restProps = _object_without_properties(_param, [
    "bullets",
    "getRootRef",
    "children",
    "slideWidth",
    "slideIndex",
    "dragDisabled",
    "resizeSource",
    "onDragStart",
    "onDragEnd",
    "onChange",
    "onPrevClick",
    "onNextClick",
    "onPointerEnter",
    "onPointerLeave",
    "align",
    "showArrows",
    "getRef",
    "arrowSize",
    "arrowAreaHeight",
    "slideTestId",
    "bulletTestId",
    "nextArrowTestId",
    "prevArrowTestId",
    "looped",
    "animationDuration",
    "animationEasing",
    "aria-roledescription",
    "arrowNextLabel",
    "arrowPrevLabel",
    "slideLabel",
    "slideRoleDescription"
  ]);
  const slidesStore = React139.useRef({});
  const slidesManager = React139.useRef(SLIDES_MANAGER_STATE);
  const textDirection = useConfigDirection();
  const isRtl = textDirection === "rtl";
  const rootRef = useExternRef(getRootRef);
  const viewportRef = useExternRef(getRef);
  const layerRef = React139.useRef(null);
  const animationFrameRef = React139.useRef(null);
  const shiftXCurrentRef = React139.useRef(0);
  const shiftXDeltaRef = React139.useRef(0);
  const initialized = React139.useRef(false);
  const { animationInQueue, addToAnimationQueue, getAnimateFunction, startAnimation, getAnimationEasing } = useSlideAnimation(animationDuration, animationEasing);
  const isDragging = React139.useRef(false);
  const [controlElementsState, setControlElementsState] = React139.useState(CONTROL_ELEMENTS_STATE);
  const slidesContainerId = React139.useId();
  const isCenterAlign = align === "center";
  const calculateCanSlideLeft = () => {
    if (looped) {
      return !slidesManager.current.isFullyVisible;
    }
    const isStartShiftX = isBiggerOrEqual(shiftXCurrentRef.current, 0, isRtl);
    return !slidesManager.current.isFullyVisible && !isStartShiftX;
  };
  const calculateCanSlideRight = () => {
    if (looped) {
      return !slidesManager.current.isFullyVisible;
    }
    var _slidesManager_current_layerWidth;
    return !slidesManager.current.isFullyVisible && // we can't move right when gallery layer fully scrolled right, if gallery aligned by left side
    (align === "left" && slidesManager.current.containerWidth - revertRtlValue2(shiftXCurrentRef.current, isRtl) < ((_slidesManager_current_layerWidth = slidesManager.current.layerWidth) !== null && _slidesManager_current_layerWidth !== void 0 ? _slidesManager_current_layerWidth : 0) || // otherwise we need to check current slide index (align = right or align = center)
    align !== "left" && slideIndex < slidesManager.current.slides.length - 1);
  };
  const transformCssStyles = (shiftX, animation = false) => {
    shiftX = Math.round(shiftX);
    if (looped) {
      slidesManager.current.loopPoints.forEach((loopPoint) => {
        const { target, index: index2 } = loopPoint;
        const slide = slidesStore.current[index2];
        if (slide) {
          slide.style.transform = `translate3d(${target(shiftX)}px, 0, 0)`;
        }
      });
    } else {
      Object.values(slidesStore.current).forEach((slide) => {
        if (slide) {
          slide.style.transform = "";
        }
      });
    }
    if (layerRef.current) {
      const indent = isDragging.current && !looped ? validateIndent(slidesManager.current, shiftXCurrentRef.current + shiftXDeltaRef.current, isRtl, false) : shiftX;
      layerRef.current.style.transform = `translate3d(${indent}px, 0, 0)`;
      layerRef.current.style.transition = animation ? `transform ${animationDuration}ms ${getAnimationEasing()}` : "";
    }
  };
  const checkShiftOutOfBoundsFromStart = (shiftX, snaps) => isBigger(shiftX, snaps[0], isRtl);
  const checkShiftOutOfBoundsFromEnd = (shiftX, slides) => {
    const firstSlideShift = align === "center" ? (slidesManager.current.containerWidth - slidesManager.current.slides[0].width) / 2 : 0;
    const lastPoint = slides[slides.length - 1].width + slides[slides.length - 1].coordX - firstSlideShift;
    return isRtl ? shiftX >= lastPoint : shiftX <= -lastPoint;
  };
  const requestTransform = (shiftX, animation = false) => {
    const { snaps, contentSize, slides } = slidesManager.current;
    if (animationFrameRef.current !== null) {
      cancelAnimationFrame(animationFrameRef.current);
    }
    animationFrameRef.current = requestAnimationFrame(() => {
      if (looped && checkShiftOutOfBoundsFromStart(shiftX, snaps)) {
        const firstSnap = revertRtlValue2(snaps[0], isRtl);
        shiftXCurrentRef.current = revertRtlValue2(-contentSize + firstSnap, isRtl);
        shiftX = shiftXCurrentRef.current + shiftXDeltaRef.current;
      }
      if (looped && checkShiftOutOfBoundsFromEnd(shiftX, slides)) {
        shiftXCurrentRef.current = Math.abs(shiftXDeltaRef.current) + snaps[0];
      }
      transformCssStyles(shiftX, animation);
      animationFrameRef.current = null;
    });
  };
  const initializeSlides = () => {
    var _localSlides_slideIndex;
    if (!rootRef.current || !viewportRef.current || !layerRef.current) {
      return;
    }
    const layerOffsetWidth = layerRef.current.offsetWidth;
    const calcRtlCoord = (element) => {
      const offsetLeft = element.offsetLeft;
      const offsetWidth = element.offsetWidth;
      return layerOffsetWidth - offsetLeft - offsetWidth;
    };
    let localSlides = React139.Children.map(children, (_item, i) => {
      const elem = slidesStore.current[i];
      if (!elem) {
        return {
          coordX: 0,
          width: 0
        };
      }
      const coordX2 = isRtl ? calcRtlCoord(elem) : elem.offsetLeft;
      return {
        coordX: coordX2,
        width: elem.offsetWidth
      };
    }) || [];
    if (localSlides.length === 0) {
      initialized.current = false;
      return;
    }
    const containerWidth = rootRef.current.offsetWidth;
    const viewportOffsetWidth = viewportRef.current.offsetWidth;
    const layerWidth = localSlides.reduce((val, slide) => slide.width + val, 0);
    if (looped) {
      let remainingWidth = containerWidth;
      let slideIndex2 = 0;
      while (remainingWidth > 0 && slideIndex2 < localSlides.length) {
        remainingWidth -= localSlides[slideIndex2].width;
        slideIndex2++;
      }
      if (remainingWidth <= 0 && slideIndex2 === localSlides.length) {
        warn18('Ширины слайдов недостаточно для корректной работы свойства "looped". Пожалуйста, сделайте её больше.');
      }
    }
    var _localSlides_slideIndex_width;
    const currentSlideOffsetOnCenterAlignment = (containerWidth - ((_localSlides_slideIndex_width = (_localSlides_slideIndex = localSlides[slideIndex]) === null || _localSlides_slideIndex === void 0 ? void 0 : _localSlides_slideIndex.width) !== null && _localSlides_slideIndex_width !== void 0 ? _localSlides_slideIndex_width : 0)) / 2;
    const isFullyVisible = align === "center" ? layerWidth + currentSlideOffsetOnCenterAlignment <= containerWidth : layerWidth <= containerWidth;
    const onlyOneSlide = localSlides.length === 1;
    slidesManager.current = _object_spread_props(_object_spread({}, slidesManager.current), {
      layerWidth,
      containerWidth,
      viewportOffsetWidth,
      slides: localSlides,
      isFullyVisible,
      max: looped || onlyOneSlide ? null : calcMax({
        slides: localSlides,
        containerWidth,
        isCenterAlign,
        isRtl
      }),
      min: looped || onlyOneSlide ? null : calcMin({
        containerWidth,
        layerWidth,
        slides: localSlides,
        viewportOffsetWidth,
        isFullyVisible,
        align,
        isRtl
      })
    });
    const snaps = localSlides.map((_, index2) => calculateIndent2({
      targetIndex: index2,
      slidesManager: slidesManager.current,
      isCenter: isCenterAlign,
      looped,
      isRtl
    }));
    let contentSize = Math.abs(snaps[snaps.length - 1]) + localSlides[localSlides.length - 1].width;
    if (align === "center") {
      contentSize += revertRtlValue2(snaps[0], isRtl);
    }
    slidesManager.current.snaps = snaps;
    slidesManager.current.contentSize = contentSize;
    if (looped && !onlyOneSlide && !isFullyVisible) {
      slidesManager.current.loopPoints = getLoopPoints(slidesManager.current, containerWidth, isRtl);
    }
    const isAnimationInProgress = animationInQueue() || animationFrameRef.current !== null;
    if (isAnimationInProgress) {
      return;
    }
    shiftXCurrentRef.current = snaps[slideIndex];
    initialized.current = true;
    setControlElementsState({
      canSlideLeft: calculateCanSlideLeft(),
      canSlideRight: calculateCanSlideRight(),
      isDraggable: !(dragDisabled || slidesManager.current.isFullyVisible)
    });
    requestTransform(shiftXCurrentRef.current);
  };
  const onResize = () => {
    if (initialized.current) {
      initializeSlides();
    }
  };
  const { window: window2 } = useDOM();
  useResizeObserver(resizeSource === "element" ? rootRef : window2, onResize);
  const loopedSlideChangePerform = () => {
    const { snaps, slides } = slidesManager.current;
    const indent = snaps[slideIndex];
    let startPoint = shiftXCurrentRef.current;
    const fromLastToFirst = isLowerOrEqual(shiftXCurrentRef.current, snaps[snaps.length - 1], isRtl);
    if (indent === snaps[0] && fromLastToFirst) {
      const endEdge = revertRtlValue2(Math.abs(snaps[snaps.length - 1]) + slides[slides.length - 1].width, isRtl);
      const distance = endEdge + startPoint;
      addToAnimationQueue(getAnimateFunction((progress) => {
        const shiftX = startPoint + progress * distance * -1;
        transformCssStyles(shiftX);
        if (shiftX <= snaps[snaps.length - 1] - slides[slides.length - 1].width) {
          requestAnimationFrame(() => {
            shiftXCurrentRef.current = indent;
            transformCssStyles(snaps[0]);
          });
        }
      }));
    } else if (indent === snaps[snaps.length - 1] && shiftXCurrentRef.current === snaps[0]) {
      startPoint = indent - revertRtlValue2(slides[slides.length - 1].width, isRtl);
      addToAnimationQueue(() => {
        requestAnimationFrame(() => {
          const shiftX = indent - revertRtlValue2(slides[slides.length - 1].width, isRtl);
          transformCssStyles(shiftX);
          getAnimateFunction((progress) => {
            const diff = revertRtlValue2(progress * slides[slides.length - 1].width, isRtl);
            transformCssStyles(startPoint + diff);
          })();
        });
      });
    } else {
      addToAnimationQueue(() => {
        const distance = Math.abs(indent - startPoint);
        let direction = startPoint <= indent ? 1 : -1;
        getAnimateFunction((progress) => {
          const shiftX = startPoint + progress * distance * direction;
          transformCssStyles(shiftX);
        })();
      });
    }
  };
  const simpleSlideChangePerform = () => {
    const { snaps } = slidesManager.current;
    requestTransform(snaps[slideIndex], true);
  };
  useIsomorphicLayoutEffect(function performSlideChange() {
    if (!initialized.current) {
      return;
    }
    const { snaps } = slidesManager.current;
    const indent = snaps[slideIndex];
    if (looped) {
      loopedSlideChangePerform();
    } else {
      simpleSlideChangePerform();
    }
    startAnimation();
    shiftXCurrentRef.current = indent;
    setControlElementsState((v) => _object_spread_props(_object_spread({}, v), {
      canSlideLeft: calculateCanSlideLeft(),
      canSlideRight: calculateCanSlideRight()
    }));
  }, [
    slideIndex
  ]);
  useIsomorphicLayoutEffect(function updateIsDraggable() {
    setControlElementsState((v) => _object_spread_props(_object_spread({}, v), {
      isDraggable: !(dragDisabled || slidesManager.current.isFullyVisible)
    }));
  }, [
    dragDisabled
  ]);
  useMutationObserver(layerRef, initializeSlides);
  useIsomorphicLayoutEffect(initializeSlides, [
    align,
    slideWidth,
    looped,
    isRtl
  ]);
  const calculateMinDeltaXToSlide = () => {
    return slidesManager.current.slides[slideIndex].width * SLIDE_THRESHOLD;
  };
  const slideLeft = (event) => {
    if (slideIndex > 0) {
      shiftXCurrentRef.current += revertRtlValue2(calculateMinDeltaXToSlide(), isRtl);
    }
    onChange === null || onChange === void 0 ? void 0 : onChange((slideIndex - 1 + slidesManager.current.slides.length) % slidesManager.current.slides.length);
    onPrevClick === null || onPrevClick === void 0 ? void 0 : onPrevClick(event);
  };
  const slideRight = (event) => {
    if (slideIndex < slidesManager.current.slides.length - 1) {
      shiftXCurrentRef.current -= revertRtlValue2(calculateMinDeltaXToSlide(), isRtl);
    }
    onChange === null || onChange === void 0 ? void 0 : onChange((slideIndex + 1) % slidesManager.current.slides.length);
    onNextClick === null || onNextClick === void 0 ? void 0 : onNextClick(event);
  };
  const onStart = (e) => {
    e.originalEvent.stopPropagation();
    if (controlElementsState.isDraggable) {
      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(e);
      shiftXCurrentRef.current = slidesManager.current.snaps[slideIndex];
      shiftXDeltaRef.current = 0;
    }
  };
  const onMoveX = (e) => {
    if (controlElementsState.isDraggable) {
      e.originalEvent.preventDefault();
      if (e.isSlideX) {
        isDragging.current = true;
        if (shiftXDeltaRef.current !== e.shiftX) {
          shiftXDeltaRef.current = e.shiftX;
          requestTransform(shiftXCurrentRef.current + shiftXDeltaRef.current);
        }
      }
    }
  };
  const onEnd = (e) => {
    if (controlElementsState.isDraggable) {
      isDragging.current = false;
      let targetIndex = slideIndex;
      if (e.isSlide) {
        targetIndex = getTargetIndex({
          slides: slidesManager.current.slides,
          slideIndex,
          currentShiftX: shiftXCurrentRef.current,
          currentShiftXDelta: shiftXDeltaRef.current,
          max: slidesManager.current.max,
          looped,
          isRtl
        });
      }
      onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(e, targetIndex);
      if (targetIndex !== slideIndex) {
        shiftXCurrentRef.current = shiftXCurrentRef.current + shiftXDeltaRef.current;
        onChange === null || onChange === void 0 ? void 0 : onChange(targetIndex);
      } else {
        const initialShiftX = slidesManager.current.snaps[targetIndex];
        requestTransform(initialShiftX, true);
      }
    }
  };
  const setSlideRef = (slideRef, slideIndex2) => {
    slidesStore.current[slideIndex2] = slideRef;
  };
  const { isDraggable, canSlideRight, canSlideLeft } = controlElementsState;
  const handleScrollForFixVoiceOverBehavior = (event) => {
    var _restProps_onScroll;
    (_restProps_onScroll = restProps.onScroll) === null || _restProps_onScroll === void 0 ? void 0 : _restProps_onScroll.call(restProps, event);
    if (rootRef.current) {
      event.currentTarget.scrollLeft = 0;
    }
  };
  const _useHover = useHover(), { isHovered } = _useHover, hoverHandlers = _object_without_properties(_useHover, [
    "isHovered"
  ]);
  const handlers = mergeCalls(hoverHandlers, {
    onPointerEnter,
    onPointerLeave
  });
  return (0, import_jsx_runtime146.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps, handlers), {
    role: "region",
    onScroll: handleScrollForFixVoiceOverBehavior,
    "aria-roledescription": ariaRoleDescription,
    baseClassName: clsx("vkuiCarouselBase__host", slideWidth === "custom" && "vkuiCarouselBase__customWidth", isHovered && "vkuiCarouselBase__hover", isDraggable && "vkuiCarouselBase__draggable"),
    getRootRef: rootRef,
    children: [
      (0, import_jsx_runtime146.jsx)(ScrollArrows, {
        canSlideLeft,
        canSlideRight,
        onSlideRight: slideRight,
        onSlideLeft: slideLeft,
        showArrows,
        arrowSize,
        arrowAreaHeight,
        arrowPrevLabel,
        arrowNextLabel,
        prevArrowTestId,
        nextArrowTestId,
        slidesContainerId
      }),
      (0, import_jsx_runtime146.jsx)(CarouselViewPort, {
        slideWidth,
        slideTestId,
        onStart,
        onMoveX,
        onEnd,
        getRootRef: viewportRef,
        layerRef,
        setSlideRef,
        slidesContainerId,
        slideLabel,
        slideRoleDescription,
        onChange,
        children
      }),
      bullets && (0, import_jsx_runtime146.jsx)(Bullets, {
        bullets,
        slideIndex,
        count: React139.Children.count(children),
        bulletTestId
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Gallery/hooks.js
var React140 = __toESM(require_react(), 1);
function useAutoPlay({ timeout, slideIndex, onNext }) {
  const { document: document2 } = useDOM();
  const [paused, setPaused] = React140.useState(false);
  const timeoutRef = React140.useRef(null);
  const callbackFn = useStableCallback(onNext);
  const pause = React140.useCallback(() => setPaused(true), []);
  const resume = React140.useCallback(() => setPaused(false), []);
  const clearAutoPlayTimeout = React140.useCallback(() => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
  }, []);
  const startAutoPlayTimeout = React140.useCallback(() => {
    if (!document2 || !timeout || paused) {
      return;
    }
    if (document2.visibilityState === "visible") {
      clearAutoPlayTimeout();
      timeoutRef.current = setTimeout(callbackFn, timeout);
    } else {
      clearAutoPlayTimeout();
    }
  }, [
    document2,
    timeout,
    paused,
    clearAutoPlayTimeout,
    callbackFn
  ]);
  React140.useEffect(function initializeAutoPlay() {
    if (!document2 || !timeout || paused) {
      return;
    }
    startAutoPlayTimeout();
    document2.addEventListener("visibilitychange", startAutoPlayTimeout);
    return () => {
      clearAutoPlayTimeout();
      document2.removeEventListener("visibilitychange", startAutoPlayTimeout);
    };
  }, [
    document2,
    timeout,
    slideIndex,
    startAutoPlayTimeout,
    clearAutoPlayTimeout,
    paused
  ]);
  return {
    resume,
    pause
  };
}

// node_modules/@vkontakte/vkui/dist/components/Gallery/Gallery.js
var Gallery = (_param) => {
  var { initialSlideIndex = 0, children, timeout = 0, onChange, bullets, onDragStart, onDragEnd, getRootRef, onMouseOver, onMouseOut } = _param, props = _object_without_properties(_param, [
    "initialSlideIndex",
    "children",
    "timeout",
    "onChange",
    "bullets",
    "onDragStart",
    "onDragEnd",
    "getRootRef",
    "onMouseOver",
    "onMouseOut"
  ]);
  const rootRef = useExternRef(getRootRef);
  const [localSlideIndex, setSlideIndex] = React141.useState(initialSlideIndex);
  const isControlled = typeof props.slideIndex === "number";
  var _props_slideIndex;
  const slideIndex = isControlled ? (_props_slideIndex = props.slideIndex) !== null && _props_slideIndex !== void 0 ? _props_slideIndex : 0 : localSlideIndex;
  const slides = React141.useMemo(() => React141.Children.toArray(children).filter((item) => Boolean(item)), [
    children
  ]);
  const childCount = slides.length;
  const isClient2 = useIsClient();
  const focusWithin = useFocusWithin(rootRef);
  const handleChange = React141.useCallback((current) => {
    if (current === slideIndex) {
      return;
    }
    !isControlled && setSlideIndex(current);
    onChange && onChange(current);
  }, [
    isControlled,
    onChange,
    slideIndex
  ]);
  const autoPlayControls = useAutoPlay({
    timeout,
    slideIndex,
    onNext: () => handleChange((slideIndex + 1) % childCount)
  });
  const safeSlideIndex = childCount > 0 ? clamp2(slideIndex, 0, childCount - 1) : slideIndex;
  React141.useEffect(() => {
    if (onChange && safeSlideIndex !== slideIndex) {
      onChange(safeSlideIndex);
    }
    setSlideIndex(safeSlideIndex);
  }, [
    onChange,
    safeSlideIndex,
    slideIndex
  ]);
  useIsomorphicLayoutEffect(() => focusWithin ? autoPlayControls.pause() : autoPlayControls.resume(), [
    focusWithin,
    autoPlayControls.pause,
    autoPlayControls.resume
  ]);
  if (!isClient2) {
    return null;
  }
  return (0, import_jsx_runtime147.jsx)(CarouselBase, _object_spread_props(_object_spread({
    dragDisabled: isControlled && !onChange,
    getRootRef: rootRef
  }, props), {
    onDragStart: callMultiple(onDragStart, autoPlayControls.pause),
    onDragEnd: callMultiple(onDragEnd, autoPlayControls.resume),
    onMouseEnter: callMultiple(onMouseOver, autoPlayControls.pause),
    onMouseLeave: callMultiple(onMouseOut, autoPlayControls.resume),
    bullets: childCount > 0 && bullets,
    slideIndex: safeSlideIndex,
    onChange: handleChange,
    children: slides
  }));
};

// node_modules/@vkontakte/vkui/dist/components/GridAvatar/GridAvatar.js
var import_jsx_runtime149 = __toESM(require_jsx_runtime(), 1);

// node_modules/@vkontakte/vkui/dist/components/GridAvatar/GridAvatarBadge/GridAvatarBadge.js
var import_jsx_runtime148 = __toESM(require_jsx_runtime(), 1);
var React142 = __toESM(require_react(), 1);
var GridAvatarBadge = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  const { size: size5 } = React142.useContext(ImageBaseContext);
  return (0, import_jsx_runtime148.jsx)(ImageBase.Badge, _object_spread_props(_object_spread({}, restProps), {
    className: clsx("vkuiGridAvatarBadge__host", size5 < 96 && "vkuiGridAvatarBadge__shifted", className)
  }));
};

// node_modules/@vkontakte/vkui/dist/components/GridAvatar/GridAvatar.js
var GRID_AVATAR_DEFAULT_SIZE = 48;
var MAX_GRID_LENGTH = 4;
var warn19 = warnOnce("GridAvatar");
var GridAvatar = (_param) => {
  var { src = [], size: size5 = GRID_AVATAR_DEFAULT_SIZE, className, children } = _param, restProps = _object_without_properties(_param, [
    "src",
    "size",
    "className",
    "children"
  ]);
  if (true) {
    if (src.length > MAX_GRID_LENGTH) {
      warn19(`Длина массива src (${src.length}) больше максимальной (${MAX_GRID_LENGTH})`, "error");
    }
  }
  return (0, import_jsx_runtime149.jsxs)(ImageBase, _object_spread_props(_object_spread({}, restProps), {
    size: size5,
    className: clsx("vkuiGridAvatar__host", className),
    children: [
      (0, import_jsx_runtime149.jsx)("div", {
        className: "vkuiGridAvatar__in",
        "aria-hidden": true,
        children: src.map((url, index2) => index2 < MAX_GRID_LENGTH ? (0, import_jsx_runtime149.jsx)("div", {
          className: "vkuiGridAvatar__item",
          style: {
            backgroundImage: `url(${url})`
          }
        }, index2) : null)
      }),
      children
    ]
  }));
};
GridAvatar.Badge = GridAvatarBadge;

// node_modules/@vkontakte/vkui/dist/components/Image/Image.js
var import_jsx_runtime151 = __toESM(require_jsx_runtime(), 1);
var React144 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/Image/ImageBadge/ImageBadge.js
var import_jsx_runtime150 = __toESM(require_jsx_runtime(), 1);
var React143 = __toESM(require_react(), 1);
var ImageBadge = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  const { size: size5 } = React143.useContext(ImageBaseContext);
  return (0, import_jsx_runtime150.jsx)(ImageBase.Badge, _object_spread_props(_object_spread({}, restProps), {
    className: clsx("vkuiImageBadge__host", size5 < 96 && "vkuiImageBadge__shifted", className)
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Image/Image.js
var IMAGE_DEFAULT_SIZE = 48;
var getBorderRadiusBySize = (size5, borderRadius) => {
  switch (borderRadius) {
    case "s": {
      if (size5 <= 32) {
        return 2;
      }
      if (size5 <= 56) {
        return 3;
      }
      return 4;
    }
    case "m": {
      if (size5 <= 32) {
        return 3;
      }
      if (size5 <= 48) {
        return 4;
      }
      if (size5 <= 72) {
        return 6;
      }
      if (size5 <= 80) {
        return 8;
      }
      return 10;
    }
    case "l": {
      if (size5 <= 16) {
        return 4;
      }
      if (size5 <= 20) {
        return 5;
      }
      if (size5 <= 32) {
        return 6;
      }
      if (size5 <= 40) {
        return 8;
      }
      if (size5 <= 48) {
        return 10;
      }
      if (size5 <= 56) {
        return 12;
      }
      if (size5 <= 64) {
        return 14;
      }
      return 16;
    }
  }
};
var getBorderRadiusBySizeInPx = (size5, borderRadius) => {
  if (!borderRadius) {
    return void 0;
  }
  return `${getBorderRadiusBySize(size5, borderRadius)}px`;
};
var Image = (_param) => {
  var { size: size5 = IMAGE_DEFAULT_SIZE, borderRadius = "m", borderStartStartRadius, borderStartEndRadius, borderEndStartRadius, borderEndEndRadius, style, className, objectFit = "cover" } = _param, restProps = _object_without_properties(_param, [
    "size",
    "borderRadius",
    "borderStartStartRadius",
    "borderStartEndRadius",
    "borderEndStartRadius",
    "borderEndEndRadius",
    "style",
    "className",
    "objectFit"
  ]);
  const borderStyles = React144.useMemo(() => ({
    "--vkui_internal--Image_border_radius": getBorderRadiusBySizeInPx(size5, borderRadius),
    "--vkui_internal--Image_border_start_start_radius": getBorderRadiusBySizeInPx(size5, borderStartStartRadius),
    "--vkui_internal--Image_border_start_end_radius": getBorderRadiusBySizeInPx(size5, borderStartEndRadius),
    "--vkui_internal--Image_border_end_start_radius": getBorderRadiusBySizeInPx(size5, borderEndStartRadius),
    "--vkui_internal--Image_border_end_end_radius": getBorderRadiusBySizeInPx(size5, borderEndEndRadius)
  }), [
    borderRadius,
    borderStartStartRadius,
    borderStartEndRadius,
    borderEndStartRadius,
    borderEndEndRadius,
    size5
  ]);
  return (0, import_jsx_runtime151.jsx)(ImageBase, _object_spread_props(_object_spread({}, restProps), {
    objectFit,
    size: size5,
    style: mergeStyle(borderStyles, style),
    className: clsx(className, "vkuiImage__host", borderStartStartRadius && "vkuiImage__borderStartStartRadius", borderStartEndRadius && "vkuiImage__borderStartEndRadius", borderEndStartRadius && "vkuiImage__borderEndStartRadius", borderEndEndRadius && "vkuiImage__borderEndEndRadius")
  }));
};
Image.Badge = ImageBadge;
Image.Overlay = ImageBase.Overlay;
Image.FloatElement = ImageBase.FloatElement;
if (true) {
  defineComponentDisplayNames(Image.Badge, "Image.Badge");
  defineComponentDisplayNames(Image.Overlay, "Image.Overlay");
  defineComponentDisplayNames(Image.FloatElement, "Image.FloatElement");
}

// node_modules/@vkontakte/vkui/dist/components/Progress/Progress.js
var import_jsx_runtime152 = __toESM(require_jsx_runtime(), 1);
var React145 = __toESM(require_react(), 1);
var stylesAppearance4 = {
  accent: "vkuiProgress__appearanceAccent",
  positive: "vkuiProgress__appearancePositive",
  negative: "vkuiProgress__appearanceNegative"
};
function progressCustomHeightStyle(height) {
  return height ? {
    height,
    borderRadius: height / 2
  } : void 0;
}
var PROGRESS_MIN_VALUE = 0;
var PROGRESS_MAX_VALUE = 100;
var resolveAppearance = (appearance) => {
  switch (appearance) {
    case "accent":
    case "positive":
    case "negative":
      return [
        void 0,
        stylesAppearance4[appearance]
      ];
    default: {
      return [
        {
          "--vkui_internal_Progress_background_color": appearance
        },
        void 0
      ];
    }
  }
};
var Progress = (_param) => {
  var { value = 0, height, trackDisable = false, appearance = "accent" } = _param, restProps = _object_without_properties(_param, [
    "value",
    "height",
    "trackDisable",
    "appearance"
  ]);
  const progress = clamp2(value, PROGRESS_MIN_VALUE, PROGRESS_MAX_VALUE);
  const title = `${progress} / ${PROGRESS_MAX_VALUE}`;
  const styleHeight = progressCustomHeightStyle(height);
  const [appearanceStyles2, appearanceClassName] = resolveAppearance(appearance);
  const style = _object_spread_props(_object_spread({}, styleHeight, appearanceStyles2), {
    "--vkui_internal_Progress_progress": progress
  });
  return (0, import_jsx_runtime152.jsx)(RootComponent, _object_spread_props(_object_spread({
    "aria-valuenow": value,
    title
  }, restProps), {
    role: "progressbar",
    "aria-valuemin": PROGRESS_MIN_VALUE,
    "aria-valuemax": PROGRESS_MAX_VALUE,
    baseClassName: clsx("vkuiProgress__host", trackDisable && "vkuiProgress__trackDisable", appearanceClassName),
    baseStyle: style
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Search/Search.js
var import_jsx_runtime153 = __toESM(require_jsx_runtime(), 1);
var React147 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useBooleanState.js
var React146 = __toESM(require_react(), 1);
var useBooleanState = (defaultValue = false) => {
  const [value, setValue] = React146.useState(defaultValue);
  const setTrue = React146.useCallback(() => {
    setValue(true);
  }, []);
  const setFalse = React146.useCallback(() => {
    setValue(false);
  }, []);
  const toggle = React146.useCallback(() => {
    setValue((value2) => !value2);
  }, []);
  return {
    value,
    setTrue,
    setFalse,
    toggle
  };
};

// node_modules/@vkontakte/vkui/dist/hooks/useNativeFormResetListener.js
var useNativeFormResetListener = (ref, handler) => {
  useIsomorphicLayoutEffect(() => {
    if (!ref.current) {
      return;
    }
    const formEl = ref.current.closest("form");
    if (!formEl) {
      return;
    }
    formEl.addEventListener("reset", handler);
    return () => {
      formEl.removeEventListener("reset", handler);
    };
  }, [
    ref,
    handler
  ]);
};

// node_modules/@vkontakte/vkui/dist/components/Search/Search.js
var warn20 = warnOnce("Search");
var Search = (_param) => {
  var { className, getRootRef, style, placeholder: placeholderProp = "Поиск", before = (0, import_jsx_runtime153.jsx)(Icon16SearchOutline, {}), after = "Отмена", getRef, icon: iconProp, onIconClick, autoComplete: autoCompleteProp = "off", iconLabel, clearLabel = "Очистить", clearButtonTestId, noPadding, findButtonText = "Найти", findButtonTestId, onFindButtonClick, hideClearButton, slotProps } = _param, inputProps = _object_without_properties(_param, [
    "className",
    "getRootRef",
    "style",
    "placeholder",
    "before",
    "after",
    "getRef",
    "icon",
    "onIconClick",
    "autoComplete",
    "iconLabel",
    "clearLabel",
    "clearButtonTestId",
    "noPadding",
    "findButtonText",
    "findButtonTestId",
    "onFindButtonClick",
    "hideClearButton",
    "slotProps"
  ]);
  if (getRef) {
    warn20("Свойство `getRef` устаревшее, используйте `slotProps={ input: { getRootRef: ... } }`");
  }
  const direction = useConfigDirection();
  const isRtl = direction === "rtl";
  const rootRest = useMergeProps({
    className,
    style,
    getRootRef
  }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.root);
  const _useMergeProps = useMergeProps(_object_spread({
    getRootRef: getRef,
    placeholder: placeholderProp,
    autoComplete: autoCompleteProp,
    className: "vkuiSearch__nativeInput"
  }, inputProps), slotProps === null || slotProps === void 0 ? void 0 : slotProps.input), { id, placeholder, onChange, autoComplete, getRootRef: getInputRef, onFocus: onInputFocus, onBlur: onInputBlur } = _useMergeProps, inputRest = _object_without_properties(_useMergeProps, [
    "id",
    "placeholder",
    "onChange",
    "autoComplete",
    "getRootRef",
    "onFocus",
    "onBlur"
  ]);
  const inputRef = useExternRef(getInputRef);
  const { value: isFocused, setTrue: setFocusedTrue, setFalse: setFocusedFalse } = useBooleanState(false);
  const generatedId = React147.useId();
  const inputId = id ? id : `search-${generatedId}`;
  const [hasValue, setHasValue] = React147.useState(() => Boolean(inputRest.value || inputRest.defaultValue));
  const checkHasValue = (e) => setHasValue(Boolean(e.currentTarget.value));
  const { sizeY = "none" } = useAdaptivity();
  const { sizeY: adaptiveSizeY } = useAdaptivityConditionalRender();
  const platform3 = usePlatform();
  const hasAfter = platform3 === "ios" && hasReactNode(after);
  const onFocus = (e) => {
    setFocusedTrue();
    onInputFocus && onInputFocus(e);
  };
  const onBlur = (e) => {
    setFocusedFalse();
    onInputBlur && onInputBlur(e);
  };
  const onCancel = React147.useCallback(() => {
    var _Object_getOwnPropertyDescriptor, _inputRef_current;
    const nativeInputValueSetter = (_Object_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, "value")) === null || _Object_getOwnPropertyDescriptor === void 0 ? void 0 : _Object_getOwnPropertyDescriptor.set;
    nativeInputValueSetter === null || nativeInputValueSetter === void 0 ? void 0 : nativeInputValueSetter.call(inputRef.current, "");
    const ev2 = new Event("input", {
      bubbles: true
    });
    (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.dispatchEvent(ev2);
  }, [
    inputRef
  ]);
  const onIconClickStart = React147.useCallback((e) => onIconClick === null || onIconClick === void 0 ? void 0 : onIconClick(e), [
    onIconClick
  ]);
  const onIconCancelClickStart = React147.useCallback((e) => {
    var _inputRef_current;
    e.preventDefault();
    (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.focus();
    if (touchEnabled()) {
      onCancel();
    }
  }, [
    inputRef,
    onCancel
  ]);
  useIsomorphicLayoutEffect(() => {
    if (inputRest.value !== void 0) {
      setHasValue(Boolean(inputRest.value));
    }
  }, [
    inputRest.value
  ]);
  useNativeFormResetListener(inputRef, () => {
    setHasValue(Boolean(inputRest.defaultValue));
  });
  const renderIconButton = (icon, props = {}) => (0, import_jsx_runtime153.jsxs)(IconButton, _object_spread_props(_object_spread({
    hoverMode: "opacity",
    onPointerDown: onIconClickStart,
    className: "vkuiSearch__icon",
    onFocus: setFocusedTrue,
    onBlur: setFocusedFalse,
    onClick: noop
  }, props), {
    children: [
      (0, import_jsx_runtime153.jsx)(VisuallyHidden, {
        children: iconLabel
      }),
      icon
    ]
  }));
  const showControls = Boolean(iconProp || !hideClearButton || adaptiveSizeY.compact && onFindButtonClick);
  return (0, import_jsx_runtime153.jsxs)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: clsx("vkuiInternalSearch", "vkuiSearch__host", sizeY === "none" && "vkuiSearch__sizeYNone", sizeY === "compact" && "vkuiSearch__sizeYCompact", isFocused && "vkuiSearch__focused", hasValue && "vkuiSearch__hasValue", hasAfter && "vkuiSearch__hasAfter", iconProp && "vkuiSearch__hasIcon", inputRest.disabled && "vkuiSearch__disabled", !noPadding && "vkuiSearch__withPadding", isRtl && "vkuiSearch__rtl")
  }, rootRest), {
    children: [
      (0, import_jsx_runtime153.jsxs)("div", {
        className: "vkuiSearch__field",
        children: [
          (0, import_jsx_runtime153.jsx)("label", {
            htmlFor: inputId,
            className: "vkuiSearch__label",
            children: placeholder
          }),
          (0, import_jsx_runtime153.jsxs)("div", {
            className: "vkuiSearch__input",
            children: [
              before,
              (0, import_jsx_runtime153.jsx)(Headline, _object_spread({
                Component: "input",
                type: "search",
                level: "1",
                weight: "3",
                id: inputId,
                placeholder,
                autoComplete,
                getRootRef: inputRef,
                onChange: callMultiple(onChange, checkHasValue),
                onFocus,
                onBlur
              }, inputRest))
            ]
          }),
          showControls && (0, import_jsx_runtime153.jsxs)("div", {
            className: "vkuiSearch__controls",
            children: [
              iconProp && (typeof iconProp === "function" ? iconProp(renderIconButton) : renderIconButton(iconProp)),
              !hideClearButton && (0, import_jsx_runtime153.jsxs)(IconButton, {
                hoverMode: "opacity",
                onPointerDown: onIconCancelClickStart,
                onClick: onCancel,
                className: "vkuiSearch__icon",
                tabIndex: hasValue ? void 0 : -1,
                disabled: inputProps.disabled,
                "data-testid": clearButtonTestId,
                children: [
                  (0, import_jsx_runtime153.jsx)(VisuallyHidden, {
                    children: clearLabel
                  }),
                  platform3 === "ios" ? (0, import_jsx_runtime153.jsx)(Icon16Clear, {}) : (0, import_jsx_runtime153.jsx)(Icon24Cancel, {})
                ]
              }),
              adaptiveSizeY.compact && onFindButtonClick && (0, import_jsx_runtime153.jsx)(Button, {
                mode: "primary",
                size: "m",
                className: clsx("vkuiSearch__findButton", adaptiveSizeY.compact.className),
                focusVisibleMode: "inside",
                onClick: onFindButtonClick,
                tabIndex: hasValue ? void 0 : -1,
                "data-testid": findButtonTestId,
                children: findButtonText
              })
            ]
          })
        ]
      }),
      hasAfter && (0, import_jsx_runtime153.jsx)("div", {
        className: "vkuiSearch__after",
        children: (0, import_jsx_runtime153.jsx)(Button, {
          mode: "tertiary",
          size: "m",
          focusVisibleMode: "inside",
          hoverMode: "opacity",
          activeMode: "opacity",
          onClick: onCancel,
          onFocus: setFocusedTrue,
          onBlur: setFocusedFalse,
          children: (0, import_jsx_runtime153.jsx)("span", {
            className: "vkuiSearch__afterTextClip",
            children: after
          })
        })
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Tabs/Tabs.js
var import_jsx_runtime154 = __toESM(require_jsx_runtime(), 1);
var React151 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useTabsNavigation.js
var React148 = __toESM(require_react(), 1);
function useTabsNavigation(enabled = true, isRtl = false) {
  const { document: document2 } = useDOM();
  const tabsRef = React148.useRef(null);
  const getTabEls = () => {
    if (!tabsRef.current) {
      return [];
    }
    return Array.from(
      // eslint-disable-next-line no-restricted-properties
      tabsRef.current.querySelectorAll(`[role=tab]:not([disabled]):not([aria-disabled='true'])`)
    );
  };
  const handleDocumentKeydown = (event) => {
    if (!document2 || !tabsRef.current || !enabled) {
      return;
    }
    const key = pressedKey(event);
    switch (key) {
      case "ArrowLeft":
      case "ArrowRight":
      case "End":
      case "Home": {
        const tabEls = getTabEls();
        const currentFocusedElIndex = tabEls.findIndex((el) => document2.activeElement === el);
        if (currentFocusedElIndex === -1) {
          return;
        }
        let nextIndex = 0;
        if (key === "Home") {
          nextIndex = 0;
        } else if (key === "End") {
          nextIndex = tabEls.length - 1;
        } else {
          const offset5 = (key === "ArrowRight" ? 1 : -1) * (isRtl ? -1 : 1);
          nextIndex = currentFocusedElIndex + offset5;
        }
        const nextTabEl = tabEls[nextIndex];
        if (nextTabEl) {
          event.preventDefault();
          nextTabEl.focus();
        }
        break;
      }
      /*
       В JAWS и NVDA стрелка вниз активирует контент.
       Это не прописано в стандартах, но по ссылке ниже это рекомендуется делать.
       https://inclusive-components.design/tabbed-interfaces/
      */
      case "ArrowDown": {
        const tabEls = getTabEls();
        const currentFocusedEl = tabEls.find((el) => document2.activeElement === el);
        if (!currentFocusedEl || currentFocusedEl.getAttribute("aria-selected") !== "true") {
          return;
        }
        const relatedContentElId = currentFocusedEl.getAttribute("aria-controls");
        if (!relatedContentElId) {
          return;
        }
        const relatedContentEl = document2.getElementById(relatedContentElId);
        if (!relatedContentEl) {
          return;
        }
        event.preventDefault();
        relatedContentEl.focus();
        break;
      }
      case "Space":
      case "Enter": {
        const tabEls = getTabEls();
        const currentFocusedEl = tabEls.find((el) => document2.activeElement === el);
        if (currentFocusedEl) {
          currentFocusedEl.click();
        }
      }
    }
  };
  useGlobalEventListener(document2, "keydown", handleDocumentKeydown, {
    capture: true
  });
  return {
    tabsRef
  };
}

// node_modules/@vkontakte/vkui/dist/components/Tabs/TabsController.js
var useTabsController = ({ selectedId, defaultSelectedId, onSelectedIdChange: onSelectedIdChangeProp }) => {
  const onSelectedIdChange = useStableCallback((id) => id && (onSelectedIdChangeProp === null || onSelectedIdChangeProp === void 0 ? void 0 : onSelectedIdChangeProp(id)));
  const [value, onChange] = useCustomEnsuredControl({
    onChange: onSelectedIdChange,
    value: selectedId,
    defaultValue: defaultSelectedId
  });
  if (!selectedId && !defaultSelectedId || !value) {
    return null;
  }
  return {
    onChange,
    selectedTab: value
  };
};

// node_modules/@vkontakte/vkui/dist/components/Tabs/TabsControllerContext.js
var React149 = __toESM(require_react(), 1);
var TabsControllerContext = React149.createContext(null);

// node_modules/@vkontakte/vkui/dist/components/Tabs/TabsModeContext.js
var React150 = __toESM(require_react(), 1);
var TabsModeContext = React150.createContext({
  mode: "default",
  withGaps: false,
  layoutFillMode: "auto",
  withScrollToSelectedTab: false,
  scrollBehaviorToSelectedTab: "nearest"
});

// node_modules/@vkontakte/vkui/dist/components/Tabs/Tabs.js
var Tabs = (_param) => {
  var { children, mode = "default", role = "tablist", withScrollToSelectedTab, scrollBehaviorToSelectedTab = "nearest", layoutFillMode = "auto", selectedId, defaultSelectedId, onSelectedIdChange } = _param, restProps = _object_without_properties(_param, [
    "children",
    "mode",
    "role",
    "withScrollToSelectedTab",
    "scrollBehaviorToSelectedTab",
    "layoutFillMode",
    "selectedId",
    "defaultSelectedId",
    "onSelectedIdChange"
  ]);
  const controller = useTabsController({
    selectedId,
    defaultSelectedId,
    onSelectedIdChange
  });
  const platform3 = usePlatform();
  const direction = useConfigDirection();
  const isTabFlow = role === "tablist";
  const withGaps = mode === "accent" || mode === "secondary";
  const { tabsRef } = useTabsNavigation(isTabFlow, direction === "rtl");
  const tabsModeContext = React151.useMemo(() => ({
    mode,
    withGaps,
    layoutFillMode,
    withScrollToSelectedTab,
    scrollBehaviorToSelectedTab
  }), [
    mode,
    withGaps,
    layoutFillMode,
    withScrollToSelectedTab,
    scrollBehaviorToSelectedTab
  ]);
  return (0, import_jsx_runtime154.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiTabs__host", "vkuiInternalTabs", platform3 === "vkcom" && "vkuiInternalTabs--vkcom", withGaps && clsx("vkuiTabs__withGaps", "vkuiInternalTabs--withGaps"), mode === "default" && "vkuiTabs__modeDefault"),
    role,
    children: (0, import_jsx_runtime154.jsx)("div", {
      className: "vkuiTabs__in",
      ref: tabsRef,
      children: (0, import_jsx_runtime154.jsx)(TabsModeContext.Provider, {
        value: tabsModeContext,
        children: (0, import_jsx_runtime154.jsx)(TabsControllerContext.Provider, {
          value: controller,
          children
        })
      })
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/TabsItem/TabsItem.js
var import_jsx_runtime155 = __toESM(require_jsx_runtime(), 1);
var React152 = __toESM(require_react(), 1);
var sizeYClassNames18 = {
  none: "vkuiTabsItem__sizeYNone",
  compact: "vkuiTabsItem__sizeYCompact"
};
var stylesMode7 = {
  default: "vkuiTabsItem__modeDefault",
  accent: "vkuiTabsItem__modeAccent",
  secondary: "vkuiTabsItem__modeSecondary"
};
var fillModeClassNames = {
  stretched: "vkuiTabsItem__stretched",
  shrinked: "vkuiTabsItem__shrinked"
};
var warn21 = warnOnce("TabsItem");
var TabsItem = (_param) => {
  var { before, children, status, after, selected: selectedProp = false, role = "tab", tabIndex: tabIndexProp, getRootRef, hoverMode = "vkuiTabsItem__hover", activeMode = "", hasActive = false, focusVisibleMode = "inside", id, onClick } = _param, restProps = _object_without_properties(_param, [
    "before",
    "children",
    "status",
    "after",
    "selected",
    "role",
    "tabIndex",
    "getRootRef",
    "hoverMode",
    "activeMode",
    "hasActive",
    "focusVisibleMode",
    "id",
    "onClick"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const { mode, withGaps, layoutFillMode, scrollBehaviorToSelectedTab, withScrollToSelectedTab } = React152.useContext(TabsModeContext);
  const controller = React152.useContext(TabsControllerContext);
  let statusComponent = null;
  const isTabFlow = role === "tab";
  const selected = selectedProp || !!id && (controller === null || controller === void 0 ? void 0 : controller.selectedTab) === id;
  if (hasReactNode(status)) {
    statusComponent = typeof status === "number" ? (0, import_jsx_runtime155.jsxs)(Subhead, {
      Component: "span",
      className: clsx("vkuiTabsItem__status", "vkuiTabsItem__statusCount"),
      weight: "2",
      children: [
        (0, import_jsx_runtime155.jsx)(VisuallyHidden, {
          children: " "
        }),
        status
      ]
    }) : (0, import_jsx_runtime155.jsxs)("span", {
      className: "vkuiTabsItem__status",
      children: [
        (0, import_jsx_runtime155.jsx)(VisuallyHidden, {
          children: " "
        }),
        status
      ]
    });
  }
  if (isTabFlow) {
    if (!restProps["aria-controls"]) {
      warn21(`Передайте в "aria-controls" id контролируемого блока`, "warn");
    } else if (!id) {
      warn21(`Передайте "id" компоненту для использования в "aria-labelledby" контролируемого блока`, "warn");
    }
  }
  let tabIndex = tabIndexProp;
  if (isTabFlow && tabIndex === void 0) {
    tabIndex = selected ? 0 : -1;
  }
  const rootRef = useExternRef(getRootRef);
  const prevSelected = usePrevious(selected);
  const isInitialRender = prevSelected === void 0;
  const shouldScrollToSelected = withScrollToSelectedTab && !isInitialRender && prevSelected !== selected && selected;
  const { document: document2 } = useDOM();
  React152.useEffect(function scrollToSelectedItem() {
    if (!shouldScrollToSelected || !rootRef.current || !document2) {
      return;
    }
    const tabDOMRect = rootRef.current.getBoundingClientRect();
    const isTabVerticallyOutsideOfViewport = tabDOMRect.top < 0 || tabDOMRect.bottom > document2.documentElement.clientHeight;
    if (isTabVerticallyOutsideOfViewport) {
      return;
    }
    try {
      rootRef.current.scrollIntoView({
        inline: scrollBehaviorToSelectedTab,
        block: "nearest",
        behavior: "smooth"
      });
    } catch (e) {
    }
  }, [
    rootRef,
    document2,
    shouldScrollToSelected,
    scrollBehaviorToSelectedTab
  ]);
  const _onClick = React152.useCallback((e) => {
    onClick === null || onClick === void 0 ? void 0 : onClick(e);
    if (id) {
      controller === null || controller === void 0 ? void 0 : controller.onChange(id);
    }
  }, [
    id,
    onClick,
    controller
  ]);
  return (0, import_jsx_runtime155.jsxs)(Tappable, _object_spread_props(_object_spread({
    getRootRef: rootRef,
    hoverMode,
    activeMode,
    hasActive,
    focusVisibleMode,
    role,
    "aria-selected": selected,
    tabIndex,
    baseClassName: clsx("vkuiTabsItem__host", mode && stylesMode7[mode], selected && "vkuiTabsItem__selected", sizeY !== "regular" && sizeYClassNames18[sizeY], withGaps && "vkuiTabsItem__withGaps", layoutFillMode !== "auto" && fillModeClassNames[layoutFillMode]),
    onClick: controller ? _onClick : onClick,
    id
  }, restProps), {
    children: [
      before && (0, import_jsx_runtime155.jsx)("div", {
        className: "vkuiTabsItem__before",
        children: before
      }),
      (0, import_jsx_runtime155.jsx)(Headline, {
        Component: "span",
        className: "vkuiTabsItem__label",
        level: mode === "default" ? "1" : "2",
        weight: "2",
        children
      }),
      statusComponent,
      after && (0, import_jsx_runtime155.jsx)("div", {
        className: "vkuiTabsItem__after",
        children: after
      }),
      mode === "default" && (0, import_jsx_runtime155.jsx)("div", {
        className: "vkuiTabsItem__underline",
        "aria-hidden": true,
        "data-selected": selected
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PullToRefresh/PullToRefresh.js
var import_jsx_runtime157 = __toESM(require_jsx_runtime(), 1);
var React155 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useStateWithPrev.js
var React153 = __toESM(require_react(), 1);
function basicStateInitializer(initialArg) {
  return initialArg instanceof Function ? initialArg() : initialArg;
}
function initializer(initialArg) {
  const initialState = basicStateInitializer(initialArg);
  return [
    initialState,
    void 0
  ];
}
function basicStateReducer(state, action) {
  return action instanceof Function ? action(state) : action;
}
function reducer([prevState], action) {
  const newState = basicStateReducer(prevState, action);
  return [
    newState,
    prevState
  ];
}
function useStateWithPrev(initialState) {
  return React153.useReducer(reducer, void 0, () => initializer(initialState));
}

// node_modules/@vkontakte/vkui/dist/components/Touch/TouchContext.js
var React154 = __toESM(require_react(), 1);
var TouchRootContext = React154.createContext(false);
var TouchContext_default = TouchRootContext;

// node_modules/@vkontakte/vkui/dist/components/PullToRefresh/PullToRefreshSpinner.js
var import_jsx_runtime156 = __toESM(require_jsx_runtime(), 1);
function calcStrokeDashOffset(value, radius) {
  const progress = value / 100;
  return 2 * Math.PI * radius * (1 - progress);
}
var PullToRefreshSpinner = (_param) => {
  var { on = true, size: size5 = 24, strokeWidth = 2.5, progress = 0, children = "Пожалуйста, подождите..." } = _param, restProps = _object_without_properties(_param, [
    "on",
    "size",
    "strokeWidth",
    "progress",
    "children"
  ]);
  const radius = 0.5 * size5 - 0.5 * strokeWidth;
  const dasharray = 2 * Math.PI * radius;
  const circleCenter = 0.5 * size5;
  const dashoffset = calcStrokeDashOffset(on ? 80 : progress, radius);
  return (0, import_jsx_runtime156.jsxs)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: clsx("vkuiPullToRefresh__spinner", on && "vkuiPullToRefresh__spinnerOn")
  }, restProps), {
    children: [
      on && (0, import_jsx_runtime156.jsx)(VisuallyHidden, {
        children
      }),
      (0, import_jsx_runtime156.jsx)("svg", {
        role: "presentation",
        className: "vkuiPullToRefresh__spinnerSelf",
        style: {
          width: size5,
          height: size5
        },
        viewBox: `0 0 ${size5} ${size5}`,
        xmlns: "http://www.w3.org/2000/svg",
        children: (0, import_jsx_runtime156.jsx)("g", {
          style: {
            width: size5,
            height: size5,
            transformOrigin: `${circleCenter}px ${circleCenter}px`
          },
          children: (0, import_jsx_runtime156.jsx)("circle", {
            className: "vkuiPullToRefresh__spinnerPath",
            fill: "none",
            strokeDasharray: dasharray,
            strokeDashoffset: dashoffset,
            strokeWidth,
            strokeLinecap: "round",
            cx: circleCenter,
            cy: circleCenter,
            r: radius
          })
        })
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PullToRefresh/PullToRefresh.js
var WAIT_FETCHING_TIMEOUT_MS = 1e3;
function cancelEvent(event) {
  if (!event) {
    return false;
  }
  if ("preventDefault" in event.originalEvent && event.originalEvent.cancelable) {
    event.originalEvent.preventDefault();
  }
  if ("stopPropagation" in event.originalEvent) {
    event.originalEvent.stopPropagation();
  }
  return false;
}
var PullToRefresh = (_param) => {
  var { children, isFetching, onRefresh, className } = _param, restProps = _object_without_properties(_param, [
    "children",
    "isFetching",
    "onRefresh",
    "className"
  ]);
  const platform3 = usePlatform();
  const scroll = useScroll();
  const { window: window2 } = useDOM();
  const prevIsFetchingRef = React155.useRef(void 0);
  React155.useEffect(() => {
    prevIsFetchingRef.current = isFetching;
  });
  const initParams = React155.useMemo(() => ({
    start: platform3 === "ios" ? -10 : -45,
    max: platform3 === "ios" ? 50 : 80,
    maxY: platform3 === "ios" ? 400 : 80,
    refreshing: platform3 === "ios" ? 36 : 50,
    positionMultiplier: platform3 === "ios" ? 0.21 : 1
  }), [
    platform3
  ]);
  const [spinnerY, setSpinnerY] = React155.useState(initParams.start);
  const [watching, setWatching] = React155.useState(false);
  const [refreshing, setRefreshing] = React155.useState(false);
  const [canRefresh, setCanRefresh] = React155.useState(false);
  const [[touchDown, prevTouchDown], setTouchDown] = useStateWithPrev(false);
  const touchY = React155.useRef(0);
  const [contentShift, setContentShift] = React155.useState(0);
  const [spinnerProgress, setSpinnerProgress] = React155.useState(0);
  const resetRefreshingState = React155.useCallback(() => {
    setWatching(false);
    setCanRefresh(false);
    setRefreshing(false);
    setSpinnerY(initParams.start);
    setSpinnerProgress(0);
    setContentShift(0);
  }, [
    initParams
  ]);
  const onRefreshingFinish = React155.useCallback(() => {
    if (!touchDown) {
      resetRefreshingState();
    }
  }, [
    touchDown,
    resetRefreshingState
  ]);
  const waitFetchingTimeoutId = React155.useRef(void 0);
  useIsomorphicLayoutEffect(() => {
    const prevIsFetching = prevIsFetchingRef.current;
    if (prevIsFetching !== void 0 && prevIsFetching && !isFetching) {
      onRefreshingFinish();
    }
  }, [
    isFetching,
    onRefreshingFinish
  ]);
  useIsomorphicLayoutEffect(() => {
    const prevIsFetching = prevIsFetchingRef.current;
    if (prevIsFetching !== void 0 && !prevIsFetching && isFetching) {
      clearTimeout(waitFetchingTimeoutId.current);
    }
  }, [
    isFetching
  ]);
  const runRefreshing = React155.useCallback(() => {
    if (!refreshing && onRefresh) {
      clearTimeout(waitFetchingTimeoutId.current);
      waitFetchingTimeoutId.current = setTimeout(onRefreshingFinish, WAIT_FETCHING_TIMEOUT_MS);
      setRefreshing(true);
      setSpinnerY((prevSpinnerY) => platform3 === "ios" ? prevSpinnerY : initParams.refreshing);
      onRefresh();
    }
  }, [
    refreshing,
    onRefresh,
    onRefreshingFinish,
    platform3,
    initParams.refreshing
  ]);
  useIsomorphicLayoutEffect(() => {
    if (prevTouchDown !== void 0 && prevTouchDown && !touchDown) {
      if (!refreshing && canRefresh) {
        runRefreshing();
      } else if (refreshing && !isFetching) {
        resetRefreshingState();
      } else {
        setSpinnerY(refreshing ? initParams.refreshing : initParams.start);
        setSpinnerProgress(0);
        setContentShift(0);
      }
    }
  }, [
    initParams,
    isFetching,
    onRefreshingFinish,
    prevTouchDown,
    touchDown,
    refreshing,
    canRefresh,
    runRefreshing
  ]);
  useIsomorphicLayoutEffect(function toggleDocumentOverscrollBehavior() {
    return window2 && (watching || refreshing) ? initializeBrowserGesturePreventionEffect(window2) : void 0;
  }, [
    window2,
    watching,
    refreshing
  ]);
  const startYRef = React155.useRef(0);
  const onTouchStart = (event) => {
    if (refreshing) {
      cancelEvent(event);
      return;
    }
    setTouchDown(true);
    startYRef.current = event.startY;
  };
  const iosRefreshStartedRef = React155.useRef(false);
  const onTouchMove = (event) => {
    const { isY, shiftY } = event;
    const { start, max: max2 } = initParams;
    const pageYOffset = scroll === null || scroll === void 0 ? void 0 : scroll.getScroll().y;
    if (watching && touchDown) {
      cancelEvent(event);
      const { positionMultiplier, maxY } = initParams;
      const shift5 = Math.max(0, shiftY - touchY.current);
      const currentY = clamp2(start + shift5 * positionMultiplier, start, maxY);
      const progress = currentY > -10 ? Math.abs((currentY + 10) / max2) * 80 : 0;
      setSpinnerY(currentY);
      setSpinnerProgress(clamp2(progress, 0, 80));
      setCanRefresh(progress > 80);
      setContentShift((currentY + 10) * 2.3);
      const iosCanStartRefreshDuringGesture = platform3 === "ios" && progress > 85 && !refreshing && !iosRefreshStartedRef.current;
      if (iosCanStartRefreshDuringGesture) {
        iosRefreshStartedRef.current = true;
        runRefreshing();
      }
    } else if (isY && pageYOffset === 0 && shiftY > 0 && !refreshing && touchDown) {
      cancelEvent(event);
      touchY.current = shiftY;
      setWatching(true);
      setSpinnerY(start);
      setSpinnerProgress(0);
    }
  };
  const onTouchEnd = () => {
    setWatching(false);
    setTouchDown(false);
    iosRefreshStartedRef.current = false;
  };
  const spinnerTransform = `translate3d(0, ${spinnerY}px, 0)`;
  let contentTransform = "";
  if (platform3 === "ios" && refreshing && !touchDown) {
    contentTransform = "translate3d(0, 100px, 0)";
  } else if (platform3 === "ios" && (contentShift || refreshing)) {
    contentTransform = `translate3d(0, ${contentShift}px, 0)`;
  }
  return (0, import_jsx_runtime157.jsx)(TouchContext_default.Provider, {
    value: true,
    children: (0, import_jsx_runtime157.jsxs)(Touch, _object_spread_props(_object_spread({
      "aria-live": "polite",
      "aria-busy": !!isFetching
    }, restProps), {
      onStart: onTouchStart,
      onMove: onTouchMove,
      onEnd: onTouchEnd,
      className: clsx("vkuiPullToRefresh__host", platform3 === "ios" && "vkuiPullToRefresh__ios", watching && "vkuiPullToRefresh__watching", refreshing && "vkuiPullToRefresh__refreshing", className),
      children: [
        (0, import_jsx_runtime157.jsx)(FixedLayout, {
          className: "vkuiPullToRefresh__controls",
          useParentWidth: true,
          children: (0, import_jsx_runtime157.jsx)(PullToRefreshSpinner, {
            style: {
              transform: spinnerTransform,
              opacity: watching || refreshing || canRefresh ? 1 : 0
            },
            on: refreshing,
            progress: refreshing ? void 0 : spinnerProgress
          })
        }),
        (0, import_jsx_runtime157.jsx)("div", {
          className: "vkuiPullToRefresh__content",
          style: {
            transform: contentTransform
          },
          children
        })
      ]
    }))
  });
};

// node_modules/@vkontakte/vkui/dist/components/Link/Link.js
var import_jsx_runtime158 = __toESM(require_jsx_runtime(), 1);
var Link = (_param) => {
  var { before: beforeProp, after: afterProp, noUnderline, hasVisited, children } = _param, restProps = _object_without_properties(_param, [
    "before",
    "after",
    "noUnderline",
    "hasVisited",
    "children"
  ]);
  const before = beforeProp ? (0, import_jsx_runtime158.jsx)("span", {
    className: "vkuiLink__before",
    children: beforeProp
  }) : null;
  const after = afterProp ? (0, import_jsx_runtime158.jsx)("span", {
    className: "vkuiLink__after",
    children: afterProp
  }) : null;
  return (0, import_jsx_runtime158.jsxs)(Tappable, _object_spread_props(_object_spread({
    activeMode: "opacity",
    hoverMode: "vkuiLink__hover",
    focusVisibleMode: "outside",
    DefaultComponent: "span"
  }, restProps), {
    baseClassName: clsx("vkuiLink__host", hasVisited && "vkuiLink__hasVisited", !noUnderline && "vkuiLink__withUnderline"),
    children: [
      before,
      children,
      after
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Mark/Mark.js
var import_jsx_runtime159 = __toESM(require_jsx_runtime(), 1);
var React156 = __toESM(require_react(), 1);
var Mark = (props) => (0, import_jsx_runtime159.jsx)(RootComponent, _object_spread({
  baseClassName: "vkuiMark__host",
  Component: "mark"
}, props));

// node_modules/@vkontakte/vkui/dist/components/OnboardingTooltip/OnboardingTooltip.js
var import_jsx_runtime160 = __toESM(require_jsx_runtime(), 1);
var React157 = __toESM(require_react(), 1);
var warn22 = warnOnce("OnboardingTooltip");
var OnboardingTooltip = (_param) => {
  var { "id": idProp, children, "shown": shownProp = true, arrowPadding = DEFAULT_ARROW_PADDING, arrowHeight = DEFAULT_ARROW_HEIGHT, offsetByMainAxis = 0, offsetByCrossAxis = 0, arrowOffset = 0, isStaticArrowOffset = false, onClose, "placement": placementProp = "bottom-start", maxWidth = TOOLTIP_MAX_WIDTH, "style": styleProp, getRootRef, disableArrow = false, onPlacementChange, disableFlipMiddleware = false, disableShiftMiddleware = false, overlayLabel = "Закрыть", title, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, restoreFocus, disableFocusTrap, overflowPadding } = _param, restProps = _object_without_properties(_param, [
    "id",
    "children",
    "shown",
    "arrowPadding",
    "arrowHeight",
    "offsetByMainAxis",
    "offsetByCrossAxis",
    "arrowOffset",
    "isStaticArrowOffset",
    "onClose",
    "placement",
    "maxWidth",
    "style",
    "getRootRef",
    "disableArrow",
    "onPlacementChange",
    "disableFlipMiddleware",
    "disableShiftMiddleware",
    "overlayLabel",
    "title",
    "aria-label",
    "aria-labelledby",
    "restoreFocus",
    "disableFocusTrap",
    "overflowPadding"
  ]);
  const generatedId = React157.useId();
  const tooltipId = idProp || generatedId;
  const { entering } = useNavTransition();
  const [arrowRef, setArrowRef] = React157.useState(null);
  const [tooltipContainer, setTooltipContainer] = React157.useState(null);
  const [positionStrategy, setPositionStrategy] = React157.useState("absolute");
  const shown = shownProp && tooltipContainer && !entering;
  const { middlewares, strictPlacement } = useFloatingMiddlewaresBootstrap({
    placement: placementProp,
    offsetByMainAxis,
    offsetByCrossAxis,
    arrowRef,
    arrow: !disableArrow,
    arrowHeight,
    arrowPadding,
    disableFlipMiddleware,
    disableShiftMiddleware,
    overflowPadding
  });
  const { x: floatingDataX, y: floatingDataY, refs, placement: resolvedPlacement, middlewareData: { arrow: arrowCoords } } = useFloating({
    strategy: positionStrategy,
    placement: strictPlacement,
    middleware: middlewares,
    whileElementsMounted: autoUpdateFloatingElement
  });
  const tooltipRef = useExternRef(getRootRef, refs.setFloating);
  const [childRef, child] = usePatchChildren(children, {
    "aria-describedby": shown ? tooltipId : void 0
  });
  usePlacementChangeCallback(placementProp, resolvedPlacement, onPlacementChange);
  const titleId = React157.useId();
  if (!title && !ariaLabel && !ariaLabelledBy) {
    warn22('Если "title" не используется, то необходимо задать либо "aria-label", либо "aria-labelledby" (см. правило axe aria-dialog-name)');
  }
  let tooltip = null;
  if (shown) {
    const floatingStyle = convertFloatingDataToReactCSSProperties({
      strategy: positionStrategy,
      x: floatingDataX,
      y: floatingDataY
    });
    tooltip = createPortal2((0, import_jsx_runtime160.jsxs)(FocusTrap, {
      role: "dialog",
      "aria-modal": "true",
      "aria-label": ariaLabel,
      "aria-labelledby": title ? titleId : ariaLabel ? void 0 : ariaLabelledBy,
      onClose,
      disabled: disableFocusTrap,
      restoreFocus,
      children: [
        (0, import_jsx_runtime160.jsx)("button", {
          "aria-label": overlayLabel,
          className: "vkuiOnboardingTooltip__overlay",
          onClickCapture: onClose
        }),
        (0, import_jsx_runtime160.jsx)(TooltipBase, _object_spread_props(_object_spread({}, restProps), {
          id: tooltipId,
          title,
          titleId: title ? titleId : void 0,
          getRootRef: tooltipRef,
          style: mergeStyle(floatingStyle, styleProp),
          maxWidth,
          arrowProps: disableArrow ? void 0 : {
            offset: arrowOffset,
            isStaticOffset: isStaticArrowOffset,
            coords: arrowCoords,
            placement: resolvedPlacement,
            getRootRef: setArrowRef
          }
        }))
      ]
    }), tooltipContainer);
  }
  useIsomorphicLayoutEffect(function initialize() {
    const referenceEl = childRef.current;
    if (referenceEl) {
      setTooltipContainer(referenceEl.closest(`[${onboardingTooltipContainerAttr}]`));
      setPositionStrategy(referenceEl.style.position === "fixed" ? "fixed" : "absolute");
      refs.setReference(referenceEl);
    }
  }, [
    childRef
  ]);
  if (true) {
    const multiChildren = React157.Children.count(children) > 1;
    const primitiveChild = hasReactNode(children) && typeof children !== "object";
    (multiChildren || primitiveChild) && warn22([
      "children должен быть одним React элементом, получено",
      multiChildren && "несколько",
      primitiveChild && JSON.stringify(children)
    ].filter(Boolean).join(" "), "error");
    if (refs.reference.current && !tooltipContainer) {
      throw new Error("Use TooltipContainer for Tooltip outside Panel (see docs)");
    }
  }
  return (0, import_jsx_runtime160.jsxs)(React157.Fragment, {
    children: [
      child,
      tooltip
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/Counter/Counter.js
var import_jsx_runtime161 = __toESM(require_jsx_runtime(), 1);
var React158 = __toESM(require_react(), 1);
var modeClassNames2 = {
  primary: "vkuiCounter__modePrimary",
  contrast: "vkuiCounter__modeContrast",
  tertiary: "vkuiCounter__modeTertiary",
  inherit: "vkuiCounter__modeInherit"
};
var appearanceClassNames4 = {
  "custom": "vkuiCounter__appearanceCustom",
  "accent": "vkuiCounter__appearanceAccent",
  "neutral": "vkuiCounter__appearanceNeutral",
  "accent-green": "vkuiCounter__appearanceAccentGreen",
  "accent-red": "vkuiCounter__appearanceAccentRed"
};
var sizeClassNames4 = {
  s: "vkuiCounter__sizeS",
  m: "vkuiCounter__sizeM"
};
var Counter = (_param) => {
  var { mode = "inherit", appearance: appearanceProp, color, size: size5 = "m", children, className, style: styleProp } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "appearance",
    "color",
    "size",
    "children",
    "className",
    "style"
  ]);
  const appearance = React158.useMemo(() => {
    if (mode === "inherit") {
      return void 0;
    }
    if (appearanceProp) {
      return appearanceProp;
    }
    return "accent";
  }, [
    appearanceProp,
    mode
  ]);
  const style = React158.useMemo(() => {
    if (mode === "inherit" || appearance !== "custom" || !color) {
      return void 0;
    }
    switch (mode) {
      case "primary":
        return {
          "--vkui_internal--counter_background": color
        };
      case "contrast":
      case "tertiary":
        return {
          "--vkui_internal--counter_foreground": color
        };
    }
  }, [
    appearance,
    color,
    mode
  ]);
  if (React158.Children.count(children) === 0) {
    return null;
  }
  const CounterTypography = size5 === "s" ? Caption : Headline;
  const counterLevel = size5 === "s" ? "1" : "2";
  return (0, import_jsx_runtime161.jsx)(CounterTypography, _object_spread_props(_object_spread({}, restProps), {
    style: mergeStyle(style, styleProp),
    Component: "span",
    className: clsx("vkuiInternalCounter", "vkuiCounter__host", modeClassNames2[mode], !!appearance && appearanceClassNames4[appearance], sizeClassNames4[size5], className),
    level: counterLevel,
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/UsersStack/UsersStack.js
var import_jsx_runtime162 = __toESM(require_jsx_runtime(), 1);
var React159 = __toESM(require_react(), 1);
var stylesSize6 = {
  s: "vkuiUsersStack__sizeS",
  m: "vkuiUsersStack__sizeM",
  l: "vkuiUsersStack__sizeL"
};
var avatarsPositionStyles = {
  "inline-start": "vkuiUsersStack__avatarsPositionInlineStart",
  "inline-end": "vkuiUsersStack__avatarsPositionInlineEnd",
  "block-start": "vkuiUsersStack__avatarsPositionBlockStart"
};
function PathElement(_param) {
  var { photoSize, direction } = _param, props = _object_without_properties(_param, [
    "photoSize",
    "direction"
  ]);
  switch (direction) {
    case "circle":
      const radius = photoSize / 2;
      return (0, import_jsx_runtime162.jsx)("circle", _object_spread({
        cx: radius,
        cy: radius,
        r: radius
      }, props));
    case "right":
      switch (photoSize) {
        case 16:
          return (0, import_jsx_runtime162.jsx)("path", _object_spread({
            d: "M14,13.285A8 8 0 0 1 8 16A8 8 0 0 1 8 0A8 8 0 0 1 14 2.715A8 8 0 0 0 14,13.285"
          }, props));
        case 24:
          return (0, import_jsx_runtime162.jsx)("path", _object_spread({
            d: "M22,18.625A12 12 0 0 1 12 24A12 12 0 0 1 12 0A12 12 0 0 1 22 5.375A12 12 0 0 0 22,18.625"
          }, props));
        default:
          return (0, import_jsx_runtime162.jsx)("path", _object_spread({
            d: "M30,23.75A16 16 0 0 1 16 32A16 16 0 0 1 16 0A16 16 0 0 1 30 8.25A16 16 0 0 0 30,23.75"
          }, props));
      }
    default:
      switch (photoSize) {
        case 16:
          return (0, import_jsx_runtime162.jsx)("path", _object_spread({
            d: "M2,13.285A8 8 0 0 0 8 16A8 8 0 0 0 8 0A8 8 0 0 0 2 2.715A8 8 0 0 1 2,13.285"
          }, props));
        case 24:
          return (0, import_jsx_runtime162.jsx)("path", _object_spread({
            d: "M2,18.625A12 12 0 0 0 12 24A12 12 0 0 0 12 0A12 12 0 0 0 2 5.375A12 12 0 0 1 2,18.625"
          }, props));
        default:
          return (0, import_jsx_runtime162.jsx)("path", _object_spread({
            d: "M2,23.75A16 16 0 0 0 16 32A16 16 0 0 0 16 0A16 16 0 0 0 2 8.25A16 16 0 0 1 2,23.75"
          }, props));
      }
  }
}
var photoSizes = {
  s: 16,
  m: 24,
  l: 32
};
var UsersStack = (_param) => {
  var { photos = [], visibleCount = 3, count = Math.max(0, photos.length - visibleCount), size: size5 = "m", children, avatarsPosition = "inline-start" } = _param, restProps = _object_without_properties(_param, [
    "photos",
    "visibleCount",
    "count",
    "size",
    "children",
    "avatarsPosition"
  ]);
  const cmpId = React159.useId();
  const direction = useConfigDirection();
  const canShowOthers = count > 0 && count < 100 && size5 !== "s";
  const CounterTypography = size5 === "l" ? Footnote : Caption;
  const photoSize = photoSizes[size5];
  const directionClip = direction === "ltr" ? canShowOthers ? "right" : "left" : canShowOthers ? "left" : "right";
  const photosElements = photos.slice(0, visibleCount).map((photo, i) => {
    const direction2 = i === 0 && !canShowOthers ? "circle" : directionClip;
    const id = `UsersStackDefs${cmpId}${i}`;
    const hrefID = `#${id}`;
    const maskID = `UsersStackMask${cmpId}${i}`;
    const isPhotoType = typeof photo === "object";
    const photoSrc = isPhotoType ? photo.src : photo;
    let photoElement = (0, import_jsx_runtime162.jsxs)("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      className: clsx("vkuiUsersStack__photo", "vkuiUsersStack__item"),
      "aria-hidden": true,
      display: "block",
      children: [
        (0, import_jsx_runtime162.jsx)("defs", {
          children: (0, import_jsx_runtime162.jsx)(PathElement, {
            id,
            direction: direction2,
            photoSize
          })
        }),
        (0, import_jsx_runtime162.jsx)("clipPath", {
          id: maskID,
          children: (0, import_jsx_runtime162.jsx)("use", {
            href: hrefID
          })
        }),
        (0, import_jsx_runtime162.jsxs)("g", {
          clipPath: `url(#${maskID})`,
          children: [
            (0, import_jsx_runtime162.jsx)("use", {
              href: hrefID,
              className: "vkuiUsersStack__fill"
            }),
            (0, import_jsx_runtime162.jsx)("image", {
              href: photoSrc,
              width: photoSize,
              height: photoSize
            }),
            (0, import_jsx_runtime162.jsx)("use", {
              href: hrefID,
              fill: "none",
              stroke: "rgba(0, 0, 0, 0.08)"
            })
          ]
        })
      ]
    });
    if (isPhotoType && photo.renderWrapper) {
      photoElement = photo.renderWrapper({
        "children": photoElement,
        "data-src": photoSrc
      });
    }
    return (0, import_jsx_runtime162.jsx)("div", {
      className: "vkuiUsersStack__photoWrapper",
      children: photoElement
    }, i);
  });
  const othersElement = canShowOthers ? (0, import_jsx_runtime162.jsx)("div", {
    className: "vkuiUsersStack__photoWrapper",
    children: (0, import_jsx_runtime162.jsxs)(CounterTypography, {
      caps: true,
      weight: "1",
      className: clsx("vkuiUsersStack__item", "vkuiUsersStack__counter"),
      children: [
        "+",
        count
      ]
    })
  }) : null;
  return (0, import_jsx_runtime162.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiUsersStack__host", stylesSize6[size5], avatarsPositionStyles[avatarsPosition]),
    children: [
      (photosElements.length > 0 || othersElement) && (0, import_jsx_runtime162.jsxs)("div", {
        className: "vkuiUsersStack__photos",
        "aria-hidden": true,
        children: [
          photosElements,
          othersElement
        ]
      }),
      hasReactNode(children) && (0, import_jsx_runtime162.jsx)(Footnote, {
        className: "vkuiUsersStack__text",
        children
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Box/Box.js
var import_jsx_runtime163 = __toESM(require_jsx_runtime(), 1);
var displayClassNames3 = {
  "none": "vkuiBox__displayNone",
  "inline": "vkuiBox__displayInline",
  "inline-block": "vkuiBox__displayInlineBlock",
  "block": "vkuiBox__displayBlock",
  "contents": "vkuiBox__displayContents"
};
var Box = (_param) => {
  var { className, style, display } = _param, restProps = _object_without_properties(_param, [
    "className",
    "style",
    "display"
  ]);
  const resolvedProps = resolveLayoutProps(restProps);
  return (0, import_jsx_runtime163.jsx)(RootComponent, _object_spread_props(_object_spread({}, resolvedProps), {
    baseClassName: resolvedProps.className,
    baseStyle: resolvedProps.style,
    className: clsx(className, display && displayClassNames3[display]),
    style
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Placeholder/Placeholder.js
var import_jsx_runtime164 = __toESM(require_jsx_runtime(), 1);
var React160 = __toESM(require_react(), 1);
var PlaceholderContainer = (_param) => {
  var { stretched, noPadding = false } = _param, restProps = _object_without_properties(_param, [
    "stretched",
    "noPadding"
  ]);
  return (0, import_jsx_runtime164.jsx)(RootComponent, _object_spread({
    baseClassName: clsx("vkuiPlaceholder__host", stretched && "vkuiPlaceholder__stretched", !noPadding && "vkuiPlaceholder__withPadding")
  }, restProps));
};
var PlaceholderIcon = (props) => (0, import_jsx_runtime164.jsx)(RootComponent, _object_spread({
  baseClassName: "vkuiPlaceholder__icon"
}, props));
var PlaceholderTitle = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  return (0, import_jsx_runtime164.jsx)(Title, _object_spread({
    level: "2",
    weight: "2",
    className: clsx(className, "vkuiPlaceholder__title")
  }, restProps));
};
var PlaceholderDescription = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  return (0, import_jsx_runtime164.jsx)(Headline, _object_spread({
    weight: "3",
    className: clsx(className, "vkuiPlaceholder__description")
  }, restProps));
};
var PlaceholderActions = (props) => (0, import_jsx_runtime164.jsx)(RootComponent, _object_spread({
  baseClassName: "vkuiPlaceholder__action"
}, props));
var Placeholder = (_param) => {
  var { icon, title, children, action, noPadding = false } = _param, restProps = _object_without_properties(_param, [
    "icon",
    "title",
    "children",
    "action",
    "noPadding"
  ]);
  return (0, import_jsx_runtime164.jsxs)(PlaceholderContainer, _object_spread_props(_object_spread({
    noPadding
  }, restProps), {
    children: [
      hasReactNode(icon) && (0, import_jsx_runtime164.jsx)(PlaceholderIcon, {
        children: icon
      }),
      hasReactNode(title) && (0, import_jsx_runtime164.jsx)(PlaceholderTitle, {
        children: title
      }),
      hasReactNode(children) && (0, import_jsx_runtime164.jsx)(PlaceholderDescription, {
        children
      }),
      hasReactNode(action) && (0, import_jsx_runtime164.jsx)(PlaceholderActions, {
        children: action
      })
    ]
  }));
};
Placeholder.Container = PlaceholderContainer;
Placeholder.Icon = PlaceholderIcon;
Placeholder.Title = PlaceholderTitle;
Placeholder.Description = PlaceholderDescription;
Placeholder.Actions = PlaceholderActions;

// node_modules/@vkontakte/vkui/dist/components/Banner/Banner.js
var import_jsx_runtime165 = __toESM(require_jsx_runtime(), 1);
var React161 = __toESM(require_react(), 1);
var Banner = (_param) => {
  var { mode = "tint", imageTheme = "dark", size: size5 = "s", before, after: afterProp, title, subtitle, extraSubtitle, children, background, actions, onDismiss, dismissLabel = "Скрыть", Component: Component2 } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "imageTheme",
    "size",
    "before",
    "after",
    "title",
    "subtitle",
    "extraSubtitle",
    "children",
    "background",
    "actions",
    "onDismiss",
    "dismissLabel",
    "Component"
  ]);
  const platform3 = usePlatform();
  const HeaderTypography = size5 === "m" ? Title : Headline;
  const SubheadTypography = size5 === "m" ? Text : Subhead;
  const IconDismissIOS = mode === "image" ? Icon24DismissDark : Icon24Dismiss;
  const content = (0, import_jsx_runtime165.jsxs)(import_jsx_runtime165.Fragment, {
    children: [
      mode === "image" && background && (0, import_jsx_runtime165.jsx)("div", {
        "aria-hidden": true,
        className: "vkuiBanner__bg",
        children: background
      }),
      before && (0, import_jsx_runtime165.jsx)("div", {
        className: "vkuiBanner__before",
        children: before
      }),
      (0, import_jsx_runtime165.jsxs)("div", {
        className: "vkuiBanner__content",
        children: [
          hasReactNode(title) && (0, import_jsx_runtime165.jsx)(HeaderTypography, {
            Component: "div",
            weight: "2",
            level: size5 === "m" ? "2" : "1",
            children: title
          }),
          hasReactNode(subtitle) && (0, import_jsx_runtime165.jsx)(SubheadTypography, {
            Component: "div",
            className: "vkuiBanner__subtitle",
            children: subtitle
          }),
          hasReactNode(extraSubtitle) && (0, import_jsx_runtime165.jsx)(Text, {
            Component: "div",
            className: "vkuiBanner__extraSubtitle",
            children: extraSubtitle
          }),
          hasReactNode(actions) && React161.Children.count(actions) > 0 && (0, import_jsx_runtime165.jsx)("div", {
            className: "vkuiBanner__actions",
            children: actions
          })
        ]
      })
    ]
  });
  const afterMap = {
    chevron: (0, import_jsx_runtime165.jsx)(Icon24Chevron, {
      className: "vkuiBanner__chevron"
    }),
    dismiss: (0, import_jsx_runtime165.jsx)(IconButton, {
      label: dismissLabel,
      className: "vkuiBanner__dismiss",
      onClick: onDismiss,
      hoverMode: "opacity",
      hasActive: false,
      children: platform3 === "ios" ? (0, import_jsx_runtime165.jsx)(IconDismissIOS, {}) : (0, import_jsx_runtime165.jsx)(Icon24Cancel, {})
    })
  };
  const after = afterProp && (0, import_jsx_runtime165.jsx)("div", {
    className: "vkuiBanner__after",
    children: typeof afterProp === "string" ? afterMap[afterProp] : afterProp
  });
  const isClickable = restProps.onClick || restProps.onClickCapture || restProps.href;
  return (0, import_jsx_runtime165.jsxs)(Tappable, _object_spread_props(_object_spread({
    Component: Component2 || (!isClickable ? "section" : void 0),
    activeMode: platform3 === "ios" ? "opacity" : "background",
    baseClassName: clsx("vkuiBanner__host", platform3 === "ios" && "vkuiBanner__ios", mode === "image" && "vkuiBanner__modeImage", size5 === "m" && "vkuiBanner__sizeM", mode === "image" && imageTheme === "dark" && "vkuiBanner__inverted")
  }, restProps), {
    children: [
      content,
      after
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/MiniInfoCell/MiniInfoCell.js
var import_jsx_runtime166 = __toESM(require_jsx_runtime(), 1);
var React162 = __toESM(require_react(), 1);
var stylesMode8 = {
  add: "vkuiMiniInfoCell__modeAdd",
  accent: "vkuiMiniInfoCell__modeAccent",
  more: "vkuiMiniInfoCell__modeMore"
};
var stylesTextWrap = {
  nowrap: "vkuiMiniInfoCell__textWrapNowrap",
  full: "vkuiMiniInfoCell__textWrapFull",
  short: "vkuiMiniInfoCell__textWrapShort"
};
var MiniInfoCell = (_param) => {
  var { before, after, children, mode = "base", textWrap = "nowrap", chevron = false } = _param, restProps = _object_without_properties(_param, [
    "before",
    "after",
    "children",
    "mode",
    "textWrap",
    "chevron"
  ]);
  const cellClasses = clsx("vkuiMiniInfoCell__host", stylesTextWrap[textWrap], mode !== "base" && stylesMode8[mode]);
  const cellContent = (0, import_jsx_runtime166.jsxs)(React162.Fragment, {
    children: [
      hasReactNode(before) && (0, import_jsx_runtime166.jsx)("span", {
        className: "vkuiMiniInfoCell__before",
        children: before
      }),
      (0, import_jsx_runtime166.jsxs)("div", {
        className: "vkuiMiniInfoCell__middle",
        children: [
          (0, import_jsx_runtime166.jsx)(Paragraph, {
            className: "vkuiMiniInfoCell__content",
            weight: mode === "more" ? "2" : void 0,
            children
          }),
          chevron && (0, import_jsx_runtime166.jsx)(Icon16Chevron, {})
        ]
      }),
      hasReactNode(after) && (0, import_jsx_runtime166.jsx)("span", {
        className: "vkuiMiniInfoCell__after",
        children: after
      })
    ]
  });
  return (0, import_jsx_runtime166.jsx)(Tappable, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: cellClasses,
    children: cellContent
  }));
};

// node_modules/@vkontakte/vkui/dist/components/WriteBar/WriteBar.js
var import_jsx_runtime167 = __toESM(require_jsx_runtime(), 1);
var React164 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/Textarea/useResizeTextarea.js
var React163 = __toESM(require_react(), 1);
function useResizeTextarea(onResize, grow) {
  const elementRef = React163.useRef(null);
  const currentScrollHeight = React163.useRef(void 0);
  const resizeElement = React163.useCallback((el) => {
    if (grow && el.offsetParent) {
      el.style.height = "";
      el.style.height = `${el.scrollHeight}px`;
      if (el.scrollHeight !== currentScrollHeight.current && onResize) {
        onResize(el);
        currentScrollHeight.current = el.scrollHeight;
      }
    }
  }, [
    grow,
    onResize
  ]);
  const resize = React163.useCallback(() => {
    const el = elementRef.current;
    if (!el) {
      return;
    }
    resizeElement(el);
  }, [
    elementRef,
    resizeElement
  ]);
  return [
    elementRef,
    resize
  ];
}

// node_modules/@vkontakte/vkui/dist/components/WriteBar/WriteBar.js
var warn23 = warnOnce("WriteBar");
var WriteBarTypography = (props) => {
  const platform3 = usePlatform();
  if (platform3 === "ios") {
    return (0, import_jsx_runtime167.jsx)(Title, _object_spread_props(_object_spread({}, props), {
      level: "3",
      weight: "3"
    }));
  }
  return (0, import_jsx_runtime167.jsx)(Headline, _object_spread({
    weight: "3"
  }, props));
};
var WriteBar = (_param) => {
  var { className, style, before, inlineAfter, after, getRootRef, getRef, onHeightChange, shadow = false, slotProps } = _param, restProps = _object_without_properties(_param, [
    "className",
    "style",
    "before",
    "inlineAfter",
    "after",
    "getRootRef",
    "getRef",
    "onHeightChange",
    "shadow",
    "slotProps"
  ]);
  if (getRef) {
    warn23("Свойство `getRef` устаревшее, используйте `slotProps={ textArea: { getRootRef: ... } }`");
  }
  const platform3 = usePlatform();
  const rootProps = useMergeProps({
    className,
    getRootRef,
    style
  }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.root);
  const _useMergeProps = useMergeProps(_object_spread({
    className: "vkuiWriteBar__textarea",
    getRootRef: getRef
  }, restProps), slotProps === null || slotProps === void 0 ? void 0 : slotProps.textArea), { onChange, getRootRef: getTextAreaRef } = _useMergeProps, textAreaRest = _object_without_properties(_useMergeProps, [
    "onChange",
    "getRootRef"
  ]);
  const [refResizeTextarea, resize] = useResizeTextarea(onHeightChange, true);
  const textareaRef = useExternRef(getTextAreaRef, refResizeTextarea);
  React164.useEffect(resize, [
    resize,
    platform3
  ]);
  return (0, import_jsx_runtime167.jsx)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: clsx("vkuiWriteBar__host", platform3 === "ios" && "vkuiWriteBar__ios", shadow && "vkuiWriteBar__shadow")
  }, rootProps), {
    children: (0, import_jsx_runtime167.jsxs)("div", {
      className: "vkuiWriteBar__form",
      children: [
        hasReactNode(before) && (0, import_jsx_runtime167.jsx)("div", {
          className: "vkuiWriteBar__before",
          children: before
        }),
        (0, import_jsx_runtime167.jsxs)("div", {
          className: "vkuiWriteBar__formIn",
          children: [
            (0, import_jsx_runtime167.jsx)(WriteBarTypography, _object_spread({
              Component: "textarea",
              onChange: callMultiple(onChange, resize),
              getRootRef: textareaRef
            }, textAreaRest)),
            hasReactNode(inlineAfter) && (0, import_jsx_runtime167.jsx)("div", {
              className: "vkuiWriteBar__inlineAfter",
              children: inlineAfter
            })
          ]
        }),
        hasReactNode(after) && (0, import_jsx_runtime167.jsx)("div", {
          className: "vkuiWriteBar__after",
          children: after
        })
      ]
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/WriteBarIcon/WriteBarIcon.js
var import_jsx_runtime168 = __toESM(require_jsx_runtime(), 1);
var React165 = __toESM(require_react(), 1);
var predefinedLabel = {
  attach: "Прикрепить файл",
  send: "Отправить",
  done: "Готово"
};
var warn24 = warnOnce("WriteBarIcon");
var WriteBarIcon = (_param) => {
  var { mode, children, count, label: labelProp } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "children",
    "count",
    "label"
  ]);
  const platform3 = usePlatform();
  let predefinedIcons;
  switch (mode) {
    case "attach":
      predefinedIcons = {
        IconCompact: platform3 === "ios" ? Icon28AddCircleOutline : Icon24Attach,
        IconRegular: platform3 === "ios" ? Icon28AddCircleOutline : Icon28AttachOutline
      };
      break;
    case "send":
      predefinedIcons = {
        IconCompact: platform3 === "ios" ? Icon48WritebarSend : Icon24Send,
        IconRegular: platform3 === "ios" ? Icon48WritebarSend : Icon28Send
      };
      break;
    case "done":
      predefinedIcons = {
        IconCompact: platform3 === "ios" ? Icon48WritebarDone : Icon24CheckCircleOutline,
        IconRegular: platform3 === "ios" ? Icon48WritebarDone : Icon28CheckCircleOutline
      };
      break;
    default:
      break;
  }
  const label = labelProp !== null && labelProp !== void 0 ? labelProp : mode && predefinedLabel[mode];
  if (true) {
    const isAccessible = hasAccessibleName(_object_spread({
      children: [
        children,
        label
      ]
    }, restProps));
    if (!isAccessible) {
      warn24(COMMON_WARNINGS.a11y["button-name"], "error");
    }
  }
  return (0, import_jsx_runtime168.jsxs)(Tappable, _object_spread_props(_object_spread({
    Component: "button",
    hasHover: false,
    activeMode: "vkuiWriteBarIcon__active"
  }, restProps), {
    baseClassName: clsx("vkuiWriteBarIcon__host", platform3 === "ios" && "vkuiWriteBarIcon__ios", mode === "send" && "vkuiWriteBarIcon__modeSend", mode === "done" && "vkuiWriteBarIcon__modeDone"),
    children: [
      (0, import_jsx_runtime168.jsxs)("span", {
        className: "vkuiWriteBarIcon__in",
        children: [
          label && (0, import_jsx_runtime168.jsx)(VisuallyHidden, {
            children: label
          }),
          predefinedIcons ? (0, import_jsx_runtime168.jsx)(AdaptiveIconRenderer, _object_spread({}, predefinedIcons)) : children
        ]
      }),
      hasReactNode(count) && (0, import_jsx_runtime168.jsx)(Counter, {
        className: "vkuiWriteBarIcon__counter",
        size: "s",
        children: count
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/SubnavigationBar/SubnavigationBar.js
var import_jsx_runtime169 = __toESM(require_jsx_runtime(), 1);
var React166 = __toESM(require_react(), 1);
var defaultScrollToLeft = (x) => x - 240;
var defaultScrollToRight = (x) => x + 240;
var SubnavigationBar = (_param) => {
  var { fixed = false, children, showArrows = true, noPadding = false, arrowSize = "s", getScrollToLeft = defaultScrollToLeft, getScrollToRight = defaultScrollToRight, scrollAnimationDuration } = _param, restProps = _object_without_properties(_param, [
    "fixed",
    "children",
    "showArrows",
    "noPadding",
    "arrowSize",
    "getScrollToLeft",
    "getScrollToRight",
    "scrollAnimationDuration"
  ]);
  let ScrollWrapper;
  let scrollWrapperProps = {};
  if (fixed) {
    ScrollWrapper = "div";
  } else {
    ScrollWrapper = HorizontalScroll;
    scrollWrapperProps = {
      showArrows,
      arrowSize,
      getScrollToLeft,
      getScrollToRight,
      scrollAnimationDuration
    };
  }
  return (0, import_jsx_runtime169.jsx)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: fixed && "vkuiSubnavigationBar__modeFixed"
  }, restProps), {
    children: (0, import_jsx_runtime169.jsx)(ScrollWrapper, _object_spread_props(_object_spread({
      className: "vkuiSubnavigationBar__in"
    }, scrollWrapperProps), {
      children: (0, import_jsx_runtime169.jsx)("ul", {
        className: clsx("vkuiSubnavigationBar__scrollIn", noPadding && "vkuiSubnavigationBar__noPadding"),
        children: React166.Children.map(children, (child, idx) => hasReactNode(child) ? (0, import_jsx_runtime169.jsx)("li", {
          className: "vkuiSubnavigationBar__item",
          children: child
        }, idx) : null)
      })
    }))
  }));
};

// node_modules/@vkontakte/vkui/dist/components/SubnavigationButton/SubnavigationButton.js
var import_jsx_runtime170 = __toESM(require_jsx_runtime(), 1);
var React167 = __toESM(require_react(), 1);
var appearanceStyles = {
  accent: "vkuiSubnavigationButton__appearanceAccent",
  neutral: "vkuiSubnavigationButton__appearanceNeutral"
};
var modeStyles2 = {
  primary: "vkuiSubnavigationButton__modePrimary",
  outline: "vkuiSubnavigationButton__modeOutline",
  tertiary: "vkuiSubnavigationButton__modeTertiary"
};
var sizeStyles = {
  s: "vkuiSubnavigationButton__sizeS",
  m: "vkuiSubnavigationButton__sizeM",
  l: "vkuiSubnavigationButton__sizeL"
};
var sizeYClassNames19 = {
  none: "vkuiSubnavigationButton__sizeYNone",
  compact: "vkuiSubnavigationButton__sizeYCompact"
};
var SubnavigationButtonTypography = (_param) => {
  var { textLevel } = _param, restProps = _object_without_properties(_param, [
    "textLevel"
  ]);
  if (textLevel === "1") {
    return (0, import_jsx_runtime170.jsx)(Subhead, _object_spread({}, restProps));
  }
  return (0, import_jsx_runtime170.jsx)(Caption, _object_spread({
    level: textLevel === "2" ? "1" : "2"
  }, restProps));
};
var SubnavigationButton = (_param) => {
  var { mode = "primary", appearance = "accent", size: size5 = "m", selected, textLevel = "1", before, after, chevron, children } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "appearance",
    "size",
    "selected",
    "textLevel",
    "before",
    "after",
    "chevron",
    "children"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime170.jsx)(Tappable, _object_spread_props(_object_spread({
    hasActive: false,
    focusVisibleMode: "outside"
  }, restProps), {
    baseClassName: clsx("vkuiSubnavigationButton__host", sizeStyles[size5], modeStyles2[mode], appearanceStyles[appearance], selected && "vkuiSubnavigationButton__selected", sizeY !== "regular" && sizeYClassNames19[sizeY], restProps.disabled && "vkuiSubnavigationButton__disabled"),
    children: (0, import_jsx_runtime170.jsxs)("span", {
      className: "vkuiSubnavigationButton__in",
      children: [
        before && (0, import_jsx_runtime170.jsx)("span", {
          className: "vkuiSubnavigationButton__before",
          children: before
        }),
        (0, import_jsx_runtime170.jsx)(SubnavigationButtonTypography, {
          textLevel,
          className: "vkuiSubnavigationButton__label",
          Component: "span",
          children
        }),
        after && (0, import_jsx_runtime170.jsx)("span", {
          className: "vkuiSubnavigationButton__after",
          children: after
        }),
        chevron && (0, import_jsx_runtime170.jsx)(Icon16Dropdown, {
          className: "vkuiSubnavigationButton__chevronIcon"
        })
      ]
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Pagination/Pagination.js
var import_jsx_runtime174 = __toESM(require_jsx_runtime(), 1);
var React172 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/usePagination.js
var React168 = __toESM(require_react(), 1);
var usePagination = ({ currentPage = 1, siblingCount = 1, boundaryCount = 1, totalPages: endPage = 1 } = {}) => React168.useMemo(() => {
  const startPages = rangeIncrement(1, Math.min(boundaryCount, endPage));
  const endPages = rangeIncrement(Math.max(endPage - boundaryCount + 1, boundaryCount + 1), endPage);
  const lowerBoundaryWhenCurrentPageHigh = endPage - boundaryCount - 1 - 2 * siblingCount;
  const siblingsStart = clamp2(currentPage - siblingCount, boundaryCount + 2, lowerBoundaryWhenCurrentPageHigh);
  const upperBoundaryWhenCurrentPageLow = boundaryCount + 2 + 2 * siblingCount;
  const siblingsEnd = Math.min(Math.max(currentPage + siblingCount, upperBoundaryWhenCurrentPageLow), endPages.length > 0 ? endPages[0] - 2 : endPage - 1);
  const pages = startPages;
  if (siblingsStart > boundaryCount + 2) {
    pages.push("start-ellipsis");
  } else if (boundaryCount + 1 < endPage - boundaryCount) {
    pages.push(boundaryCount + 1);
  }
  pages.push(...rangeIncrement(siblingsStart, siblingsEnd));
  if (siblingsEnd < endPage - boundaryCount - 1) {
    pages.push("end-ellipsis");
  } else if (endPage - boundaryCount > boundaryCount) {
    pages.push(endPage - boundaryCount);
  }
  pages.push(...endPages);
  return pages;
}, [
  currentPage,
  endPage,
  siblingCount,
  boundaryCount
]);

// node_modules/@vkontakte/vkui/dist/components/Pagination/PaginationNavigationButton/PaginationNavigationButton.js
var import_jsx_runtime171 = __toESM(require_jsx_runtime(), 1);
var React169 = __toESM(require_react(), 1);
var getButtonPropsFromPaginationNavigationButton = (opts) => {
  const icon = opts.style !== "caption" ? (0, import_jsx_runtime171.jsxs)(import_jsx_runtime171.Fragment, {
    children: [
      (0, import_jsx_runtime171.jsx)(VisuallyHidden, {
        children: opts.a11yLabel
      }),
      (0, import_jsx_runtime171.jsx)(opts.Icon, {})
    ]
  }) : null;
  const caption = opts.style === "caption" ? (0, import_jsx_runtime171.jsxs)(import_jsx_runtime171.Fragment, {
    children: [
      (0, import_jsx_runtime171.jsx)(VisuallyHidden, {
        children: opts.a11yLabel
      }),
      (0, import_jsx_runtime171.jsx)("span", {
        "aria-hidden": "true",
        children: opts.caption
      })
    ]
  }) : opts.style !== "icon" ? (0, import_jsx_runtime171.jsx)("span", {
    "aria-hidden": "true",
    children: opts.caption
  }) : null;
  return {
    "size": "l",
    "before": opts.type === "prev" ? icon : null,
    "after": opts.type === "next" ? icon : null,
    "appearance": opts.style === "caption" ? "neutral" : "accent",
    "mode": "tertiary",
    "disabled": opts.disabled,
    "onClick": opts.onClick,
    "children": caption,
    "data-page": opts["data-page"],
    "data-testid": opts["data-testid"]
  };
};
var PaginationNavigationButton = (_param) => {
  var { renderNavigationButton } = _param, restProps = _object_without_properties(_param, [
    "renderNavigationButton"
  ]);
  const buttonProps = getButtonPropsFromPaginationNavigationButton(restProps);
  if (typeof renderNavigationButton === "function") {
    return renderNavigationButton(buttonProps);
  }
  return (0, import_jsx_runtime171.jsx)(Button, _object_spread({}, buttonProps));
};

// node_modules/@vkontakte/vkui/dist/components/Pagination/PaginationPage/PaginationPageButton.js
var import_jsx_runtime172 = __toESM(require_jsx_runtime(), 1);
var React170 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/Pagination/PaginationPage/usePaginationPageClasses.js
var getPaginationPageClassNames = (opts) => {
  return clsx("vkuiPaginationPage__host", opts.sizeY == null && "vkuiPaginationPage__sizeYNone", opts.sizeY === "compact" && "vkuiPaginationPage__sizeYCompact", opts.isCurrent && "vkuiPaginationPage__current", opts.disabled && "vkuiPaginationPage__disabled");
};
function usePaginationPageClassNames({ isCurrent, disabled }) {
  const { sizeY } = useAdaptivity();
  return getPaginationPageClassNames({
    isCurrent,
    disabled,
    sizeY
  });
}

// node_modules/@vkontakte/vkui/dist/components/Pagination/PaginationPage/PaginationPageButton.js
var getTappablePropsFromPaginationPage = (opts) => {
  const { isCurrent = false, getPageLabel, children, className, disabled, sizeY } = opts, restProps = _object_without_properties(opts, [
    "isCurrent",
    "getPageLabel",
    "children",
    "className",
    "disabled",
    "sizeY"
  ]);
  const pageClassNames = getPaginationPageClassNames({
    isCurrent,
    disabled,
    sizeY
  });
  const pageLabel = getPageLabel === null || getPageLabel === void 0 ? void 0 : getPageLabel(isCurrent);
  return _object_spread({
    "className": clsx(pageClassNames, className),
    "activeMode": "vkuiPaginationPage__stateActive",
    "hoverMode": "vkuiPaginationPage__stateHover",
    "focusVisibleMode": "outside",
    "aria-current": isCurrent ? true : void 0,
    "disabled": disabled,
    "children": (0, import_jsx_runtime172.jsxs)(Text, {
      normalize: false,
      children: [
        pageLabel && (0, import_jsx_runtime172.jsxs)(VisuallyHidden, {
          children: [
            pageLabel,
            " "
          ]
        }),
        children
      ]
    }),
    "data-page": children
  }, restProps);
};
var PaginationPageButton = (_param) => {
  var { renderPageButton } = _param, restProps = _object_without_properties(_param, [
    "renderPageButton"
  ]);
  const tappableProps = getTappablePropsFromPaginationPage(restProps);
  if (typeof renderPageButton === "function") {
    return renderPageButton(tappableProps);
  }
  return (0, import_jsx_runtime172.jsx)(Tappable, _object_spread({}, tappableProps));
};

// node_modules/@vkontakte/vkui/dist/components/Pagination/PaginationPage/PaginationPageEllipsis.js
var import_jsx_runtime173 = __toESM(require_jsx_runtime(), 1);
var React171 = __toESM(require_react(), 1);
var PaginationPageEllipsis = (_param) => {
  var { className, disabled } = _param, restProps = _object_without_properties(_param, [
    "className",
    "disabled"
  ]);
  const paginationClassNames = usePaginationPageClassNames({
    isCurrent: false,
    disabled
  });
  return (0, import_jsx_runtime173.jsx)(Text, _object_spread_props(_object_spread({
    className: clsx(paginationClassNames, "vkuiPaginationPage__typeEllipsis", className)
  }, restProps), {
    children: "…"
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Pagination/Pagination.js
var Pagination = (_param) => {
  var { currentPage = 1, siblingCount = 1, boundaryCount = 1, totalPages = 1, disabled, prevButtonCaption = "Назад", nextButtonCaption = "Вперёд", navigationButtonsStyle = "icon", getPageLabel, navigationLabel = "Страницы", navigationLabelComponent = "h2", prevButtonLabel = "Перейти на предыдущую страницу", nextButtonLabel = "Перейти на следующую страницу", onChange, renderPageButton, pageButtonTestId, prevButtonTestId, nextButtonTestId, renderNavigationButton } = _param, resetProps2 = _object_without_properties(_param, [
    "currentPage",
    "siblingCount",
    "boundaryCount",
    "totalPages",
    "disabled",
    "prevButtonCaption",
    "nextButtonCaption",
    "navigationButtonsStyle",
    "getPageLabel",
    "navigationLabel",
    "navigationLabelComponent",
    "prevButtonLabel",
    "nextButtonLabel",
    "onChange",
    "renderPageButton",
    "pageButtonTestId",
    "prevButtonTestId",
    "nextButtonTestId",
    "renderNavigationButton"
  ]);
  const direction = useConfigDirection();
  const isRtl = direction === "rtl";
  const pages = usePagination({
    currentPage,
    totalPages,
    siblingCount,
    boundaryCount
  });
  const isFirstPage = currentPage === 1;
  const isLastPage = currentPage === totalPages;
  const prevPage = isFirstPage ? void 0 : currentPage - 1;
  const nextPage = isLastPage ? void 0 : currentPage + 1;
  const handlePrevClick = React172.useCallback((event) => {
    if (onChange && prevPage !== void 0) {
      onChange(prevPage, event);
    }
  }, [
    prevPage,
    onChange
  ]);
  const handleClick = React172.useCallback((event) => {
    const page = event.currentTarget.dataset.page || "1";
    onChange === null || onChange === void 0 ? void 0 : onChange(Number(page), event);
  }, [
    onChange
  ]);
  const handleNextClick = React172.useCallback((event) => {
    if (onChange && nextPage !== void 0) {
      onChange(nextPage, event);
    }
  }, [
    nextPage,
    onChange
  ]);
  const { sizeY } = useAdaptivity();
  const renderPages = React172.useCallback((page) => {
    const isCurrent = page === currentPage;
    const dataTestId = pageButtonTestId === null || pageButtonTestId === void 0 ? void 0 : pageButtonTestId(page, isCurrent);
    switch (page) {
      case "start-ellipsis":
      case "end-ellipsis":
        return (0, import_jsx_runtime174.jsx)("li", {
          children: (0, import_jsx_runtime174.jsx)(PaginationPageEllipsis, {
            disabled,
            "data-testid": dataTestId
          })
        }, page);
      default: {
        return (0, import_jsx_runtime174.jsx)("li", {
          children: (0, import_jsx_runtime174.jsx)(PaginationPageButton, {
            getPageLabel,
            isCurrent,
            onClick: handleClick,
            disabled,
            sizeY,
            renderPageButton,
            "data-testid": dataTestId,
            children: page
          })
        }, page);
      }
    }
  }, [
    currentPage,
    disabled,
    getPageLabel,
    handleClick,
    renderPageButton,
    sizeY,
    pageButtonTestId
  ]);
  const navigationLabelId = React172.useId();
  return (0, import_jsx_runtime174.jsxs)(RootComponent, _object_spread_props(_object_spread({
    Component: "nav",
    role: "navigation",
    "aria-labelledby": navigationLabelId
  }, resetProps2), {
    children: [
      (0, import_jsx_runtime174.jsx)(VisuallyHidden, {
        id: navigationLabelId,
        Component: navigationLabelComponent,
        children: navigationLabel
      }),
      (0, import_jsx_runtime174.jsxs)("ul", {
        className: "vkuiPagination__list",
        children: [
          (0, import_jsx_runtime174.jsx)("li", {
            className: "vkuiPagination__prevButtonContainer",
            children: (0, import_jsx_runtime174.jsx)(PaginationNavigationButton, {
              type: "prev",
              style: navigationButtonsStyle,
              caption: prevButtonCaption,
              Icon: isRtl ? Icon24ChevronCompactRight : Icon24ChevronCompactLeft,
              a11yLabel: prevButtonLabel,
              disabled: isFirstPage || disabled,
              onClick: handlePrevClick,
              "data-page": prevPage,
              "data-testid": prevButtonTestId,
              renderNavigationButton
            })
          }),
          pages.map(renderPages),
          (0, import_jsx_runtime174.jsx)("li", {
            className: "vkuiPagination__nextButtonContainer",
            children: (0, import_jsx_runtime174.jsx)(PaginationNavigationButton, {
              type: "next",
              style: navigationButtonsStyle,
              caption: nextButtonCaption,
              Icon: isRtl ? Icon24ChevronCompactLeft : Icon24ChevronCompactRight,
              a11yLabel: nextButtonLabel,
              disabled: isLastPage || disabled,
              onClick: handleNextClick,
              "data-page": nextPage,
              "data-testid": nextButtonTestId,
              renderNavigationButton
            })
          })
        ]
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Accordion/Accordion.js
var import_jsx_runtime177 = __toESM(require_jsx_runtime(), 1);
var React176 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/Accordion/AccordionContent.js
var import_jsx_runtime175 = __toESM(require_jsx_runtime(), 1);
var React174 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/Accordion/AccordionContext.js
var import_react23 = __toESM(require_react(), 1);
var React173 = __toESM(require_react(), 1);
var AccordionContext = React173.createContext({
  labelId: "",
  contentId: "",
  expanded: false,
  unmountOnCollapsed: false,
  onChange: noop
});
var useAccordionContext = () => {
  const { expanded, onChange } = (0, import_react23.useContext)(AccordionContext);
  return React173.useMemo(() => ({
    expanded,
    onChange
  }), [
    onChange,
    expanded
  ]);
};

// node_modules/@vkontakte/vkui/dist/components/Accordion/AccordionContent.js
var CUSTOM_PROPERTY_ACCORDION_CONTENT_HEIGHT = "--vkui_internal--AccordionContent_height";
var stateClassNames2 = {
  enter: "vkuiAccordion__inEnter",
  entering: "vkuiAccordion__inEnter",
  entered: "vkuiAccordion__inEntered",
  exit: "vkuiAccordion__inExit",
  exiting: "vkuiAccordion__inExit",
  exited: "vkuiAccordion__inExited"
};
var AccordionContent = (_param) => {
  var { getRootRef, getRef, className, children } = _param, restProps = _object_without_properties(_param, [
    "getRootRef",
    "getRef",
    "className",
    "children"
  ]);
  const { expanded, labelId, contentId, unmountOnCollapsed } = React174.useContext(AccordionContext);
  const inRef = useExternRef(getRef);
  const [animationState, animationHandlers] = useCSSKeyframesAnimationController(expanded ? "enter" : "exit", void 0, true);
  useIsomorphicLayoutEffect(() => {
    const inEl = inRef.current;
    if (!inEl) {
      return;
    }
    switch (animationState) {
      case "enter":
      case "exit":
        inEl.style.setProperty(CUSTOM_PROPERTY_ACCORDION_CONTENT_HEIGHT, `${inEl.scrollHeight}px`);
        break;
      case "entered":
      case "exited":
        inEl.style.removeProperty(CUSTOM_PROPERTY_ACCORDION_CONTENT_HEIGHT);
        break;
    }
  }, [
    animationState,
    inRef
  ]);
  if (unmountOnCollapsed && animationState === "exited") {
    return null;
  }
  return (0, import_jsx_runtime175.jsx)("div", _object_spread_props(_object_spread({
    ref: getRootRef,
    id: contentId,
    role: "region",
    "aria-labelledby": labelId,
    "aria-hidden": !expanded,
    className: clsx("vkuiAccordion__host", className)
  }, restProps), {
    children: (0, import_jsx_runtime175.jsx)("div", _object_spread_props(_object_spread({
      ref: inRef,
      className: clsx("vkuiAccordion__in", stateClassNames2[animationState])
    }, animationHandlers), {
      children
    }))
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Accordion/AccordionSummary.js
var import_jsx_runtime176 = __toESM(require_jsx_runtime(), 1);
var React175 = __toESM(require_react(), 1);
var AccordionSummary = (_param) => {
  var { after, before, ExpandIcon = Icon24ChevronDown, CollapseIcon = Icon24ChevronUp, iconPosition = "after", onClick, children } = _param, restProps = _object_without_properties(_param, [
    "after",
    "before",
    "ExpandIcon",
    "CollapseIcon",
    "iconPosition",
    "onClick",
    "children"
  ]);
  const { expanded, labelId, contentId, onChange } = React175.useContext(AccordionContext);
  const Icon = expanded ? CollapseIcon : ExpandIcon;
  const icon = (
    // Обертка нужна для правильной работы с отступами в SimpleCell
    (0, import_jsx_runtime176.jsx)("span", {
      className: "vkuiIcon",
      children: (0, import_jsx_runtime176.jsx)(Icon, {
        className: "vkuiAccordion__icon"
      })
    })
  );
  const toggle = () => onChange(!expanded);
  return (0, import_jsx_runtime176.jsx)(SimpleCell, _object_spread_props(_object_spread({
    id: labelId,
    "aria-expanded": expanded,
    "aria-controls": contentId,
    onClick: callMultiple(toggle, onClick),
    before: (0, import_jsx_runtime176.jsxs)(import_jsx_runtime176.Fragment, {
      children: [
        iconPosition === "before" && icon,
        before
      ]
    }),
    after: (0, import_jsx_runtime176.jsxs)(import_jsx_runtime176.Fragment, {
      children: [
        after,
        iconPosition === "after" && icon
      ]
    })
  }, restProps), {
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Accordion/Accordion.js
function useAccordionId(id) {
  const generatedId = React176.useId();
  const labelId = id !== null && id !== void 0 ? id : `Accordion${generatedId}`;
  const contentId = `AccordionContent${id !== null && id !== void 0 ? id : generatedId}`;
  return {
    labelId,
    contentId
  };
}
var Accordion = (_param) => {
  var { id, expanded: expandedProp, defaultExpanded = false, onChange: onChangeProp, children, unmountOnCollapsed = false } = _param, restProps = _object_without_properties(_param, [
    "id",
    "expanded",
    "defaultExpanded",
    "onChange",
    "children",
    "unmountOnCollapsed"
  ]);
  const { labelId, contentId } = useAccordionId(id);
  const [expanded, onChange] = useCustomEnsuredControl({
    value: expandedProp,
    defaultValue: defaultExpanded,
    onChange: onChangeProp,
    disabled: restProps.disabled
  });
  const context = React176.useMemo(() => ({
    labelId,
    contentId,
    expanded: expanded || false,
    unmountOnCollapsed,
    onChange
  }), [
    contentId,
    expanded,
    labelId,
    onChange,
    unmountOnCollapsed
  ]);
  return (0, import_jsx_runtime177.jsx)(AccordionContext.Provider, {
    value: context,
    children
  });
};
Accordion.Summary = AccordionSummary;
Accordion.Content = AccordionContent;
if (true) {
  defineComponentDisplayNames(Accordion.Summary, "Accordion.Summary");
  defineComponentDisplayNames(Accordion.Content, "Accordion.Content");
}

// node_modules/@vkontakte/vkui/dist/components/FormItem/FormItem.js
var import_jsx_runtime181 = __toESM(require_jsx_runtime(), 1);
var React180 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/FormItem/FormItemTop/FormItemTop.js
var import_jsx_runtime178 = __toESM(require_jsx_runtime(), 1);
var FormItemTop = (props) => (0, import_jsx_runtime178.jsx)(RootComponent, _object_spread_props(_object_spread({}, props), {
  baseClassName: "vkuiFormItem__top"
}));

// node_modules/@vkontakte/vkui/dist/components/FormItem/FormItemTop/FormItemTopAside.js
var import_jsx_runtime179 = __toESM(require_jsx_runtime(), 1);
var React177 = __toESM(require_react(), 1);
var FormItemTopAside = (_param) => {
  var { children } = _param, restProps = _object_without_properties(_param, [
    "children"
  ]);
  return (0, import_jsx_runtime179.jsx)(Subhead, _object_spread_props(_object_spread({
    className: "vkuiFormItem__aside"
  }, restProps), {
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/FormItem/FormItemTop/FormItemTopLabel.js
var import_jsx_runtime180 = __toESM(require_jsx_runtime(), 1);
var React179 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/FormItem/context.js
var React178 = __toESM(require_react(), 1);
var FormItemContext = React178.createContext({
  required: false,
  topMultiline: false
});

// node_modules/@vkontakte/vkui/dist/components/FormItem/FormItemTop/FormItemTopLabel.js
var FormItemTopLabel = (_param) => {
  var { children, Component: componentProp, htmlFor } = _param, restProps = _object_without_properties(_param, [
    "children",
    "Component",
    "htmlFor"
  ]);
  const component2 = componentProp || htmlFor && "label" || "span";
  const { required, topMultiline } = React179.useContext(FormItemContext);
  return (0, import_jsx_runtime180.jsxs)(Subhead, _object_spread_props(_object_spread({
    className: clsx("vkuiFormItem__label", topMultiline && "vkuiFormItem__labelMultiline"),
    Component: component2,
    htmlFor
  }, restProps), {
    children: [
      children,
      required && (0, import_jsx_runtime180.jsx)("span", {
        className: "vkuiFormItem__labelRequired",
        "aria-hidden": true,
        children: "*"
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/FormItem/FormItem.js
var sizeYClassNames20 = {
  none: clsx("vkuiFormItem__sizeYNone", "vkuiInternalFormItem--sizeY-none"),
  compact: clsx("vkuiFormItem__sizeYCompact", "vkuiInternalFormItem--sizeY-compact")
};
var stylesStatus = {
  error: clsx("vkuiFormItem__statusError", "vkuiInternalFormItem--status-error"),
  valid: clsx("vkuiFormItem__statusValid", "vkuiInternalFormItem--status-valid")
};
var FormItem = (_param) => {
  var { children, top, topId, topMultiline = false, topComponent: topComponentProp, bottom, status = "default", removable, onRemove, removePlaceholder = "Удалить", getRootRef, htmlFor, bottomId, noPadding, required = false, disabled } = _param, restProps = _object_without_properties(_param, [
    "children",
    "top",
    "topId",
    "topMultiline",
    "topComponent",
    "bottom",
    "status",
    "removable",
    "onRemove",
    "removePlaceholder",
    "getRootRef",
    "htmlFor",
    "bottomId",
    "noPadding",
    "required",
    "disabled"
  ]);
  const rootEl = useExternRef(getRootRef);
  const { sizeY = "none" } = useAdaptivity();
  const wrappedChildren = (0, import_jsx_runtime181.jsxs)(React180.Fragment, {
    children: [
      isPrimitiveReactNode(top) ? (0, import_jsx_runtime181.jsx)(FormItemTop, {
        children: (0, import_jsx_runtime181.jsx)(FormItemTopLabel, {
          htmlFor,
          Component: topComponentProp,
          id: topId,
          children: top
        })
      }) : hasReactNode(top) ? top : null,
      children,
      hasReactNode(bottom) && (0, import_jsx_runtime181.jsx)(Footnote, {
        className: "vkuiFormItem__bottom",
        id: bottomId,
        role: status === "error" ? "alert" : void 0,
        children: bottom
      })
    ]
  });
  const context = React180.useMemo(() => ({
    required,
    topMultiline
  }), [
    required,
    topMultiline
  ]);
  return (0, import_jsx_runtime181.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    getRootRef: rootEl,
    baseClassName: clsx("vkuiFormItem__host", !noPadding && "vkuiFormItem__withPadding", "vkuiInternalFormItem", status !== "default" && stylesStatus[status], sizeY !== "regular" && sizeYClassNames20[sizeY], hasReactNode(top) && clsx("vkuiFormItem__withTop", "vkuiInternalFormItem--withTop"), removable && clsx("vkuiFormItem__withRemovable", "vkuiInternalFormItem--removable")),
    children: (0, import_jsx_runtime181.jsx)(FormItemContext.Provider, {
      value: context,
      children: removable ? (0, import_jsx_runtime181.jsx)(Removable, {
        align: "start",
        onRemove: (e) => {
          if (rootEl === null || rootEl === void 0 ? void 0 : rootEl.current) {
            onRemove === null || onRemove === void 0 ? void 0 : onRemove(e, rootEl.current);
          }
        },
        removePlaceholder,
        indent: removable === "indent",
        noPadding,
        disabled,
        children: (0, import_jsx_runtime181.jsx)("div", {
          className: clsx("vkuiFormItem__removable", "vkuiInternalFormItem__removable"),
          children: wrappedChildren
        })
      }) : wrappedChildren
    })
  }));
};
FormItem.Top = FormItemTop;
FormItem.TopLabel = FormItemTopLabel;
FormItem.TopAside = FormItemTopAside;
if (true) {
  defineComponentDisplayNames(FormItem.Top, "FormItem.Top");
  defineComponentDisplayNames(FormItem.TopLabel, "FormItem.TopLabel");
  defineComponentDisplayNames(FormItem.TopAside, "FormItem.TopAside");
}

// node_modules/@vkontakte/vkui/dist/components/FormField/FormField.js
var import_jsx_runtime182 = __toESM(require_jsx_runtime(), 1);
var React181 = __toESM(require_react(), 1);
var sizeYClassNames21 = {
  none: "vkuiFormField__sizeYNone",
  compact: "vkuiFormField__sizeYCompact"
};
var stylesStatus2 = {
  error: "vkuiFormField__statusError",
  valid: "vkuiFormField__statusValid"
};
var iconAlignClassNames = {
  center: void 0,
  start: "vkuiFormField__iconAlignStart",
  end: "vkuiFormField__iconAlignEnd"
};
var renderIcon = (icon, align, className) => {
  return (0, import_jsx_runtime182.jsx)("div", {
    className: "vkuiFormField__iconWrapper",
    children: (0, import_jsx_runtime182.jsx)("span", {
      className: clsx(iconAlignClassNames[align], className),
      children: icon
    })
  });
};
var FormField = (_param) => {
  var { Component: Component2 = "span", status = "default", children, getRootRef, before, after, beforeAlign = "center", afterAlign = "center", disabled, mode = "default", className, maxHeight, style } = _param, restProps = _object_without_properties(_param, [
    "Component",
    "status",
    "children",
    "getRootRef",
    "before",
    "after",
    "beforeAlign",
    "afterAlign",
    "disabled",
    "mode",
    "className",
    "maxHeight",
    "style"
  ]);
  const elRef = useExternRef(getRootRef);
  const { sizeY = "none" } = useAdaptivity();
  const [hover, setHover] = React181.useState(false);
  const focusWithin = useFocusWithin(elRef);
  const focusVisibleClassNames = useFocusVisibleClassName({
    focusVisible: focusWithin,
    mode: "vkuiFormField__focusVisible"
  });
  const handleMouseEnter = (e) => {
    e.stopPropagation();
    setHover(true);
  };
  const handleMouseLeave = (e) => {
    e.stopPropagation();
    setHover(false);
  };
  return (0, import_jsx_runtime182.jsxs)(Component2, _object_spread_props(_object_spread({}, restProps), {
    ref: elRef,
    style: _object_spread({
      maxHeight
    }, style),
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    className: clsx("vkuiFormField__host", mode === "default" && "vkuiFormField__modeDefault", status !== "default" && stylesStatus2[status], sizeY !== "regular" && sizeYClassNames21[sizeY], disabled && "vkuiFormField__disabled", !disabled && hover && "vkuiFormField__hover", focusVisibleClassNames, className),
    children: [
      (0, import_jsx_runtime182.jsxs)("div", {
        className: "vkuiFormField__scrollContainer",
        children: [
          before && renderIcon(before, beforeAlign, "vkuiFormField__before"),
          (0, import_jsx_runtime182.jsx)("div", {
            className: "vkuiFormField__content",
            children
          }),
          after && renderIcon(after, afterAlign, clsx("vkuiFormField__after", "vkuiInternalFormField__after"))
        ]
      }),
      (0, import_jsx_runtime182.jsx)("span", {
        "aria-hidden": true,
        className: "vkuiFormField__border"
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/FormLayoutGroup/FormLayoutGroup.js
var import_jsx_runtime183 = __toESM(require_jsx_runtime(), 1);
var React182 = __toESM(require_react(), 1);
var sizeYClassNames22 = {
  none: clsx("vkuiFormLayoutGroup__sizeYNone", "vkuiInternalFormLayoutGroup--sizeY-none"),
  compact: clsx("vkuiFormLayoutGroup__sizeYCompact", "vkuiInternalFormLayoutGroup--sizeY-compact")
};
var FormLayoutGroup = (_param) => {
  var { children, mode = "vertical", removable, segmented, removePlaceholder = "Удалить", onRemove, getRootRef, disabled } = _param, restProps = _object_without_properties(_param, [
    "children",
    "mode",
    "removable",
    "segmented",
    "removePlaceholder",
    "onRemove",
    "getRootRef",
    "disabled"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const isRemovable = removable && mode === "horizontal";
  const rootEl = useExternRef(getRootRef);
  return (0, import_jsx_runtime183.jsx)(RootComponent, _object_spread_props(_object_spread({
    getRootRef: rootEl,
    Component: "fieldset",
    baseClassName: clsx("vkuiFormLayoutGroup__host", sizeY !== "regular" && sizeYClassNames22[sizeY], mode === "horizontal" && clsx("vkuiFormLayoutGroup__modeHorizontal", "vkuiInternalFormLayoutGroup--mode-horizontal"), mode === "vertical" && "vkuiInternalFormLayoutGroup--mode-vertical", isRemovable && clsx("vkuiFormLayoutGroup__withRemovable", "vkuiInternalFormLayoutGroup--removable"), segmented && clsx("vkuiFormLayoutGroup__segmented", "vkuiInternalFormLayoutGroup--segmented")),
    disabled
  }, restProps), {
    children: isRemovable ? (0, import_jsx_runtime183.jsx)(Removable, {
      className: "vkuiFormLayoutGroup__removable",
      align: "start",
      removePlaceholder,
      onRemove: (e) => {
        if (rootEl === null || rootEl === void 0 ? void 0 : rootEl.current) {
          onRemove === null || onRemove === void 0 ? void 0 : onRemove(e, rootEl.current);
        }
      },
      disabled,
      indent: removable === "indent",
      children
    }) : (0, import_jsx_runtime183.jsxs)(React182.Fragment, {
      children: [
        children,
        (0, import_jsx_runtime183.jsx)("span", {
          className: "vkuiFormLayoutGroup__offset",
          "aria-hidden": true
        })
      ]
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/FormStatus/FormStatus.js
var import_jsx_runtime184 = __toESM(require_jsx_runtime(), 1);
var React183 = __toESM(require_react(), 1);
var FormStatus = (_param) => {
  var { mode, children, className, role = mode === "error" ? "alert" : "status", title } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "children",
    "className",
    "role",
    "title"
  ]);
  return (0, import_jsx_runtime184.jsx)(Banner, _object_spread_props(_object_spread({}, restProps), {
    title,
    role,
    subtitle: children,
    className: clsx("vkuiInternalFormStatus", mode === "error" && clsx("vkuiFormStatus__modeError", "vkuiInternalFormStatus--mode-error"), className)
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Switch/Switch.js
var import_jsx_runtime185 = __toESM(require_jsx_runtime(), 1);
var React184 = __toESM(require_react(), 1);
var warn25 = warnOnce("Switch");
var sizeYClassNames23 = {
  none: "vkuiSwitch__sizeYNone",
  compact: "vkuiSwitch__sizeYCompact"
};
var Switch = (_param) => {
  var { style: rootStyle, className: rootClassName, getRootRef: rootGetRootRef, getRef, slotProps } = _param, restProps = _object_without_properties(_param, [
    "style",
    "className",
    "getRootRef",
    "getRef",
    "slotProps"
  ]);
  if (getRef) {
    warn25("Свойство `getRef` устаревшее, используйте `slotProps={ input: { getRootRef: ... } }`");
  }
  const rootRest = useMergeProps({
    style: rootStyle,
    className: rootClassName,
    getRootRef: rootGetRootRef
  }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.root);
  const _useMergeProps = useMergeProps(_object_spread({
    getRootRef: getRef
  }, restProps), slotProps === null || slotProps === void 0 ? void 0 : slotProps.input), { checked: checkedProp, onBlur: onBlurProp, onFocus: onFocusProp, onClick } = _useMergeProps, inputRest = _object_without_properties(_useMergeProps, [
    "checked",
    "onBlur",
    "onFocus",
    "onClick"
  ]);
  const direction = useConfigDirection();
  const isRtl = direction === "rtl";
  const platform3 = usePlatform();
  const { sizeY = "none" } = useAdaptivity();
  const { focusVisible, onBlur, onFocus } = useFocusVisible();
  const focusVisibleClassNames = useFocusVisibleClassName({
    focusVisible,
    mode: "outside"
  });
  const handleBlur = callMultiple(onBlur, onBlurProp);
  const handleFocus = callMultiple(onFocus, onFocusProp);
  const [localUncontrolledChecked, setLocalUncontrolledChecked] = React184.useState(Boolean(inputRest.defaultChecked));
  const isControlled = checkedProp !== void 0;
  const syncUncontrolledCheckedStateOnClick = React184.useCallback((e) => {
    if (isControlled) {
      return;
    }
    const switchTarget = e.target;
    setLocalUncontrolledChecked(switchTarget.checked);
  }, [
    isControlled
  ]);
  const inputProps = _object_spread({
    Component: "input",
    type: "checkbox",
    role: "switch",
    onBlur: handleBlur,
    onFocus: handleFocus,
    onClick: callMultiple(syncUncontrolledCheckedStateOnClick, onClick)
  }, inputRest);
  if (isControlled) {
    inputProps.checked = checkedProp;
    inputProps["aria-checked"] = checkedProp ? "true" : "false";
  } else {
    inputProps["aria-checked"] = localUncontrolledChecked ? "true" : "false";
  }
  return (0, import_jsx_runtime185.jsxs)(RootComponent, _object_spread_props(_object_spread({
    Component: "label",
    baseClassName: clsx("vkuiSwitch__host", sizeY !== "regular" && sizeYClassNames23[sizeY], platform3 === "ios" ? "vkuiSwitch__ios" : "vkuiSwitch__default", inputRest.disabled && "vkuiSwitch__disabled", isRtl && "vkuiSwitch__rtl", focusVisibleClassNames)
  }, rootRest), {
    children: [
      (0, import_jsx_runtime185.jsx)(VisuallyHidden, _object_spread({
        baseClassName: "vkuiSwitch__inputNative"
      }, inputProps)),
      (0, import_jsx_runtime185.jsxs)("span", {
        "aria-hidden": true,
        className: "vkuiSwitch__inputFake",
        children: [
          (0, import_jsx_runtime185.jsx)("span", {
            className: "vkuiSwitch__track"
          }),
          (0, import_jsx_runtime185.jsx)("span", {
            "aria-hidden": true,
            className: clsx("vkuiSwitch__handle", platform3 !== "ios" && !inputRest.disabled && "vkuiSwitch__handleWithRipple")
          })
        ]
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/File/File.js
var import_jsx_runtime186 = __toESM(require_jsx_runtime(), 1);
var React185 = __toESM(require_react(), 1);
var warn26 = warnOnce("File");
var File = (_param) => {
  var { getRootRef, className, style, children = "Выберите файл", align = "left", size: size5, mode, stretched, before, after, loading, getRef, appearance, slotProps } = _param, restProps = _object_without_properties(_param, [
    "getRootRef",
    "className",
    "style",
    "children",
    "align",
    "size",
    "mode",
    "stretched",
    "before",
    "after",
    "loading",
    "getRef",
    "appearance",
    "slotProps"
  ]);
  if (getRef) {
    warn26("Свойство `getRef` устаревшее, используйте `slotProps={ input: { getRootRef: ... } }`");
  }
  const rootProps = useMergeProps({
    className,
    style,
    getRootRef
  }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.root);
  const inputRest = useMergeProps(_object_spread({
    getRootRef: getRef
  }, restProps), slotProps === null || slotProps === void 0 ? void 0 : slotProps.input);
  return (0, import_jsx_runtime186.jsxs)(Button, _object_spread_props(_object_spread({
    Component: "label",
    align,
    stretched,
    mode,
    appearance,
    size: size5,
    before,
    after,
    loading,
    disabled: inputRest.disabled
  }, rootProps), {
    children: [
      (0, import_jsx_runtime186.jsx)(VisuallyHidden, _object_spread({
        title: "",
        Component: "input",
        type: "file"
      }, inputRest)),
      children
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/DropZone/DropZone.js
var import_jsx_runtime188 = __toESM(require_jsx_runtime(), 1);
var React186 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/DropZone/components/DropZoneGrid.js
var import_jsx_runtime187 = __toESM(require_jsx_runtime(), 1);
var directionStyle = {
  row: "vkuicomponents__row",
  column: "vkuicomponents__column"
};
var DropZoneGrid = (_param) => {
  var { direction = "column" } = _param, props = _object_without_properties(_param, [
    "direction"
  ]);
  return (0, import_jsx_runtime187.jsx)(RootComponent, _object_spread({
    baseClassName: clsx("vkuicomponents__host", directionStyle[direction])
  }, props));
};

// node_modules/@vkontakte/vkui/dist/components/DropZone/DropZone.js
var DropZone = (_param) => {
  var { onDragOver, onDragLeave, onDrop, children } = _param, props = _object_without_properties(_param, [
    "onDragOver",
    "onDragLeave",
    "onDrop",
    "children"
  ]);
  const [active, setActive] = React186.useState(false);
  const onActive = (event) => {
    if (event.isPropagationStopped()) {
      return;
    }
    setActive(true);
  };
  const offActive = () => {
    setActive(false);
  };
  return (0, import_jsx_runtime188.jsx)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: clsx("vkuiDropZone__host", active && "vkuiDropZone__active"),
    onDragOver: callMultiple(onDragOver, onActive),
    onDragLeave: callMultiple(onDragLeave, offActive),
    onDrop: callMultiple(onDrop, offActive)
  }, props), {
    children: typeof children === "function" ? children({
      active
    }) : children
  }));
};
DropZone.Grid = DropZoneGrid;
if (true) {
  defineComponentDisplayNames(DropZone.Grid, "DropZone.Grid");
}

// node_modules/@vkontakte/vkui/dist/components/Input/Input.js
var import_jsx_runtime189 = __toESM(require_jsx_runtime(), 1);
var React187 = __toESM(require_react(), 1);
var warn27 = warnOnce("Input");
var sizeYClassNames24 = {
  none: "vkuiInput__sizeYNone",
  compact: "vkuiInput__sizeYCompact"
};
var Input = (_param) => {
  var { type = "text", align = "left", getRef, className: rootClassName, getRootRef, style, before, after, status, mode, slotProps } = _param, restProps = _object_without_properties(_param, [
    "type",
    "align",
    "getRef",
    "className",
    "getRootRef",
    "style",
    "before",
    "after",
    "status",
    "mode",
    "slotProps"
  ]);
  if (getRef) {
    warn27("Свойство `getRef` устаревшее, используйте `slotProps={ input: { getRootRef: ... } }`");
  }
  const { sizeY = "none" } = useAdaptivity();
  const _useMergeProps = useMergeProps({
    className: rootClassName,
    getRootRef,
    style
  }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.root), { className } = _useMergeProps, rootProps = _object_without_properties(_useMergeProps, [
    "className"
  ]);
  const inputRest = useMergeProps(_object_spread({
    className: "vkuiInput__el",
    getRootRef: getRef
  }, restProps), slotProps === null || slotProps === void 0 ? void 0 : slotProps.input);
  return (0, import_jsx_runtime189.jsx)(FormField, _object_spread_props(_object_spread({
    className: clsx("vkuiInput__host", align === "right" && "vkuiInput__alignRight", align === "center" && "vkuiInput__alignCenter", sizeY !== "regular" && sizeYClassNames24[sizeY], before && "vkuiInput__hasBefore", after && "vkuiInput__hasAfter", className),
    before,
    after,
    disabled: inputRest.disabled,
    mode,
    status
  }, rootProps), {
    children: (0, import_jsx_runtime189.jsx)(UnstyledTextField, _object_spread({
      as: "input",
      type
    }, inputRest))
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ChipsInputBase/Chip/Chip.js
var import_jsx_runtime190 = __toESM(require_jsx_runtime(), 1);
var React188 = __toESM(require_react(), 1);
var sizeYClassNames25 = {
  none: "vkuiChip__sizeYNone",
  compact: "vkuiChip__sizeYCompact"
};
var modeClassNames3 = {
  primary: "vkuiChip__modePrimary",
  secondary: "vkuiChip__modeSecondary"
};
var Chip = (_param) => {
  var { mode = "primary", Component: Component2 = "span", value = "", removable = true, onRemove, removeLabel = "Удалить", before, after, disabled, readOnly, children, className, onFocus: onFocusProp, onBlur: onBlurProp } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "Component",
    "value",
    "removable",
    "onRemove",
    "removeLabel",
    "before",
    "after",
    "disabled",
    "readOnly",
    "children",
    "className",
    "onFocus",
    "onBlur"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const { focusVisible, onFocus, onBlur } = useFocusVisible();
  const focusVisibleClassName = useFocusVisibleClassName({
    focusVisible
  });
  const handleFocus = (event) => {
    if (onFocusProp) {
      onFocusProp(event);
    }
    onFocus(event);
  };
  const handleBlur = (event) => {
    if (onBlurProp) {
      onBlurProp(event);
    }
    onBlur(event);
  };
  const onRemoveWrapper = React188.useCallback((event) => {
    onRemove === null || onRemove === void 0 ? void 0 : onRemove(event, value);
  }, [
    onRemove,
    value
  ]);
  return (0, import_jsx_runtime190.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    Component: Component2,
    className: clsx("vkuiChip__host", sizeY !== "regular" && sizeYClassNames25[sizeY], modeClassNames3[mode], focusVisibleClassName, className),
    "aria-readonly": readOnly,
    "aria-disabled": disabled,
    onFocus: disabled ? void 0 : handleFocus,
    onBlur: disabled ? void 0 : handleBlur,
    children: [
      (0, import_jsx_runtime190.jsxs)("div", {
        className: "vkuiChip__in",
        children: [
          hasReactNode(before) && (0, import_jsx_runtime190.jsx)("div", {
            className: "vkuiChip__before",
            children: before
          }),
          (0, import_jsx_runtime190.jsx)(Footnote, {
            className: "vkuiChip__content",
            children
          }),
          hasReactNode(after) && (0, import_jsx_runtime190.jsx)("div", {
            className: "vkuiChip__after",
            children: after
          })
        ]
      }),
      !readOnly && removable && (0, import_jsx_runtime190.jsx)("div", {
        className: "vkuiChip__removable",
        children: (0, import_jsx_runtime190.jsxs)("button", {
          type: "button",
          tabIndex: -1,
          disabled,
          className: "vkuiChip__remove",
          onClick: disabled ? void 0 : onRemoveWrapper,
          children: [
            (0, import_jsx_runtime190.jsxs)(VisuallyHidden, {
              children: [
                "  ",
                removeLabel,
                " ",
                children
              ]
            }),
            (0, import_jsx_runtime190.jsx)(Icon16Cancel, {})
          ]
        })
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ChipsInput/ChipsInput.js
var import_jsx_runtime194 = __toESM(require_jsx_runtime(), 1);

// node_modules/@vkontakte/vkui/dist/components/ChipsInputBase/ChipsInputBase.js
var import_jsx_runtime193 = __toESM(require_jsx_runtime(), 1);
var React191 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/FormFieldClearButton/FormFieldClearButton.js
var import_jsx_runtime191 = __toESM(require_jsx_runtime(), 1);
var React189 = __toESM(require_react(), 1);
var FormFieldClearButton = (_param) => {
  var { className, onClick } = _param, restProps = _object_without_properties(_param, [
    "className",
    "onClick"
  ]);
  return (0, import_jsx_runtime191.jsx)(IconButton, _object_spread_props(_object_spread({
    Component: "button",
    label: "Очистить поле",
    onKeyDown: stopPropagation,
    type: "button",
    activeMode: "opacity",
    hoverMode: "opacity"
  }, restProps), {
    className,
    onClick: (e) => {
      stopPropagation(e);
      e.preventDefault();
      onClick();
    },
    children: (0, import_jsx_runtime191.jsx)(Icon16Cancel, {})
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ChipsInputBase/constants.js
var import_jsx_runtime192 = __toESM(require_jsx_runtime(), 1);
var React190 = __toESM(require_react(), 1);
var DEFAULT_VALUE = [];
var DEFAULT_INPUT_VALUE = "";
function getOptionValueDefault(option) {
  return option.value;
}
function getOptionLabelDefault(option) {
  return option.label;
}
function getNewOptionDataDefault(value, label) {
  return {
    value,
    label
  };
}
function renderChipDefault(props) {
  const { label } = props, rest = _object_without_properties(props, [
    "label"
  ]);
  return (0, import_jsx_runtime192.jsx)(Chip, _object_spread_props(_object_spread({
    removable: !props.disabled
  }, rest), {
    children: label
  }));
}

// node_modules/@vkontakte/vkui/dist/components/ChipsInputBase/helpers.js
var isValueLikeChipOptionObject = (v) => typeof v === "object" && "value" in v;
var isInputValueEmpty = (input) => input ? input.value === DEFAULT_INPUT_VALUE : true;
var getChipOptionIndexByValueProp = (optionProp, valueProp) => {
  const value = isValueLikeChipOptionObject(optionProp) ? optionProp.value : optionProp;
  return valueProp.findIndex((option) => option.value === value);
};
var getChipOptionIndexByHTMLElement = (el) => {
  const value = el && el.dataset.index;
  return typeof value === "string" ? Number(value) : -1;
};
var getChipOptionValueByHTMLElement = (el) => {
  const value = el && el.dataset.value;
  const valueType = el && el.dataset.valueType;
  if (valueType === "number") {
    return Number(value);
  }
  return typeof value === "string" ? value : -1;
};
var getNextChipOptionIndexByNavigateToProp = (currentIndex, navigateTo, length) => {
  const LAST_INDEX = length - 1;
  switch (navigateTo) {
    case "prev":
      const prevIndex = currentIndex - 1;
      return prevIndex < 0 ? LAST_INDEX : prevIndex;
    case "next":
      const nextIndex = currentIndex + 1;
      return nextIndex > LAST_INDEX ? 0 : nextIndex;
    case "last":
      return LAST_INDEX;
    case "first":
      return 0;
    default:
      return -1;
  }
};

// node_modules/@vkontakte/vkui/dist/components/ChipsInputBase/ChipsInputBase.js
var warn28 = warnOnce("ChipsInputBase");
var sizeYClassNames26 = {
  none: "vkuiChipsInputBase__sizeYNone",
  compact: "vkuiChipsInputBase__sizeYCompact"
};
var ChipsInputBase = (_param) => {
  var {
    // FormFieldProps
    "getRootRef": rootGetRootRef,
    "style": rootStyle,
    "className": rootClassName,
    before,
    after,
    status,
    mode,
    maxHeight,
    // option
    value = DEFAULT_VALUE,
    onAddChipOption,
    "onRemoveChipOption": onRemoveChipOptionProp,
    renderChip = renderChipDefault,
    // input
    getRef,
    "inputValue": inputValueProp = DEFAULT_INPUT_VALUE,
    addOnBlur,
    onInputChange,
    // clear
    ClearButton = FormFieldClearButton,
    clearButtonShown,
    clearButtonTestId,
    onClear,
    // a11y
    chipsListLabel = "Выбранные элементы",
    "aria-label": ariaLabel = "",
    slotProps
  } = _param, restProps = _object_without_properties(_param, [
    "getRootRef",
    "style",
    "className",
    "before",
    "after",
    "status",
    "mode",
    "maxHeight",
    "value",
    "onAddChipOption",
    "onRemoveChipOption",
    "renderChip",
    "getRef",
    "inputValue",
    "addOnBlur",
    "onInputChange",
    "ClearButton",
    "clearButtonShown",
    "clearButtonTestId",
    "onClear",
    "chipsListLabel",
    "aria-label",
    "slotProps"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  if (getRef) {
    warn28("Свойство `getRef` устаревшее, используйте `slotProps={ input: { getRootRef: ... } }`");
  }
  const _useMergeProps = useMergeProps({
    getRootRef: rootGetRootRef,
    style: rootStyle,
    className: rootClassName
  }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.root), { className, style, getRootRef, onClick: onRootClick, onMouseDown: onRootMouseDown } = _useMergeProps, rootRest = _object_without_properties(_useMergeProps, [
    "className",
    "style",
    "getRootRef",
    "onClick",
    "onMouseDown"
  ]);
  const _useMergeProps1 = useMergeProps(_object_spread({
    getRootRef: getRef,
    className: "vkuiChipsInputBase__el",
    value: inputValueProp,
    onChange: onInputChange
  }, restProps), slotProps === null || slotProps === void 0 ? void 0 : slotProps.input), { getRootRef: getInputRef, onBlur, placeholder, readOnly, disabled, id, value: inputValue = DEFAULT_INPUT_VALUE } = _useMergeProps1, inputRest = _object_without_properties(_useMergeProps1, [
    "getRootRef",
    "onBlur",
    "placeholder",
    "readOnly",
    "disabled",
    "id",
    "value"
  ]);
  const idGenerated = React191.useId();
  const inputRef = useExternRef(getInputRef);
  const containerRef = React191.useRef(null);
  const listboxRef = React191.useRef(null);
  const valueLength = value.length;
  const withPlaceholder = valueLength === 0;
  const [lastFocusedChipOptionIndex, setLastFocusedChipOptionIndex] = React191.useState(0);
  const resetChipOptionFocusToInputEl = (inputEl) => {
    setLastFocusedChipOptionIndex(0);
    inputEl.focus();
  };
  const moveFocusToChipOption = (currentIndex, navigateTo, listboxEl) => {
    const index2 = getNextChipOptionIndexByNavigateToProp(currentIndex, navigateTo, valueLength);
    const foundEl = listboxEl.querySelector(`[data-index="${index2}"]`);
    if (foundEl) {
      setLastFocusedChipOptionIndex(index2);
      foundEl.focus();
    }
  };
  const removeChipOption = (o, index2) => {
    if (!inputRef.current || !listboxRef.current) {
      return;
    }
    if (valueLength > 1) {
      if (index2 === valueLength - 1) {
        moveFocusToChipOption(index2, "prev", listboxRef.current);
      } else {
        moveFocusToChipOption(index2, "next", listboxRef.current);
      }
    } else {
      resetChipOptionFocusToInputEl(inputRef.current);
    }
    onRemoveChipOptionProp(o);
  };
  const handleListboxKeyDown = (event) => {
    const targetEl = event.target;
    if (event.defaultPrevented || !listboxRef.current || !isHTMLElement(targetEl)) {
      return;
    }
    switch (event.key) {
      case Keys.ENTER: {
        if (!readOnly && contains(targetEl, inputRef.current) && inputRef.current && !isInputValueEmpty(inputRef.current)) {
          event.preventDefault();
          onAddChipOption(inputRef.current.value);
        }
        break;
      }
      case Keys.DELETE:
      case Keys.BACKSPACE: {
        if (!readOnly && valueLength > 0) {
          if (!contains(targetEl, inputRef.current)) {
            event.preventDefault();
            removeChipOption(getChipOptionValueByHTMLElement(targetEl), getChipOptionIndexByHTMLElement(targetEl));
          } else if (event.key === Keys.BACKSPACE && isInputValueEmpty(inputRef.current)) {
            event.preventDefault();
            moveFocusToChipOption(getChipOptionIndexByHTMLElement(targetEl), "last", listboxRef.current);
          }
        }
        break;
      }
      case Keys.HOME:
      case Keys.END:
      case Keys.ARROW_UP:
      case Keys.ARROW_LEFT:
      case Keys.ARROW_DOWN:
      case Keys.ARROW_RIGHT: {
        if (valueLength !== 0 && !contains(targetEl, inputRef.current)) {
          event.preventDefault();
          moveFocusToChipOption(getChipOptionIndexByHTMLElement(targetEl), getHorizontalFocusGoTo(event.key), listboxRef.current);
        }
        break;
      }
    }
  };
  const handleInputBlur = (event) => {
    if (onBlur) {
      onBlur(event);
    }
    if (addOnBlur && !event.defaultPrevented && inputRef.current) {
      onAddChipOption(inputRef.current.value);
    }
  };
  const handleChipRemove = (event, v) => {
    event.preventDefault();
    event.stopPropagation();
    removeChipOption(v, getChipOptionIndexByValueProp(v, value));
  };
  const handleRootClick = (event) => {
    const activeElement = getActiveElementByAnotherElement(event.currentTarget);
    if (event.defaultPrevented || contains(event.currentTarget, activeElement)) {
      return;
    }
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };
  const handleClear = React191.useCallback(() => {
    if (inputRef.current) {
      resetChipOptionFocusToInputEl(inputRef.current);
    }
    onClear();
  }, [
    inputRef,
    onClear
  ]);
  const clearButton = React191.useMemo(() => {
    if (clearButtonShown) {
      return (0, import_jsx_runtime193.jsx)(ClearButton, {
        onClick: handleClear,
        disabled,
        "data-testid": clearButtonTestId
      });
    }
    return void 0;
  }, [
    ClearButton,
    clearButtonShown,
    clearButtonTestId,
    disabled,
    handleClear
  ]);
  const afterItems = React191.useMemo(() => {
    if (clearButton || after) {
      return (0, import_jsx_runtime193.jsxs)(import_jsx_runtime193.Fragment, {
        children: [
          clearButton,
          after
        ]
      });
    }
    return void 0;
  }, [
    after,
    clearButton
  ]);
  const inputId = id || `chips-input-base-generated-id-${idGenerated}`;
  const handleRootMouseDown = (e) => {
    if (isHTMLElement(e.target) && contains(listboxRef.current, e.target) && listboxRef.current !== e.target) {
      return;
    }
    const activeElement = getActiveElementByAnotherElement(e.currentTarget);
    if (contains(listboxRef.current, activeElement)) {
      return;
    }
    if (e.target === inputRef.current) {
      return;
    }
    e.preventDefault();
  };
  return (0, import_jsx_runtime193.jsx)(FormField, _object_spread_props(_object_spread({
    Component: "div",
    getRootRef,
    // role="group" добавлена, чтобы этот блок можно было найти с помощью стрелочек при использовании NVDA
    // Если убрать, то aria-label не будет читаться
    role: "group",
    "aria-label": ariaLabel,
    style,
    disabled,
    before,
    after: afterItems,
    status,
    mode,
    className,
    maxHeight,
    onClick: disabled ? onRootClick : callMultiple(handleRootClick, onRootClick),
    onMouseDown: callMultiple(handleRootMouseDown, onRootMouseDown)
  }, rootRest), {
    children: (0, import_jsx_runtime193.jsxs)("div", {
      className: clsx("vkuiChipsInputBase__host", sizeY !== "regular" && sizeYClassNames26[sizeY], withPlaceholder && "vkuiChipsInputBase__hasPlaceholder", inputValue && "vkuiChipsInputBase__hasInputValue"),
      ref: containerRef,
      onKeyDown: disabled ? void 0 : handleListboxKeyDown,
      children: [
        (0, import_jsx_runtime193.jsx)("div", {
          className: "vkuiChipsInputBase__listBox",
          // для a11y
          ref: listboxRef,
          role: "listbox",
          "aria-orientation": "horizontal",
          "aria-disabled": disabled,
          "aria-readonly": readOnly,
          "aria-label": chipsListLabel,
          children: value.map((option, index2) => (0, import_jsx_runtime193.jsx)(React191.Fragment, {
            children: renderChip({
              "Component": "div",
              "value": option.value,
              "label": option.label,
              "disabled": option.disabled || disabled,
              "readOnly": option.readOnly || readOnly,
              "className": "vkuiChipsInputBase__chip",
              "onRemove": handleChipRemove,
              // чтобы можно было легче найти этот чип в DOM
              "data-index": index2,
              "data-value": option.value,
              "data-value-type": typeof option.value,
              // для a11y
              "tabIndex": lastFocusedChipOptionIndex === index2 ? 0 : -1,
              "role": "option",
              "aria-selected": true,
              "aria-posinset": index2 + 1,
              "aria-setsize": valueLength,
              "aria-description": "Для удаления используйте Backspace или Delete"
            }, option)
          }, `${typeof option.value}-${option.value}`))
        }),
        (0, import_jsx_runtime193.jsx)(Text, _object_spread({
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          spellCheck: false,
          "aria-label": ariaLabel,
          Component: "input",
          type: "text",
          id: inputId,
          getRootRef: inputRef,
          disabled,
          readOnly,
          value: inputValue,
          placeholder: withPlaceholder ? placeholder : void 0,
          onBlur: handleInputBlur
        }, inputRest))
      ]
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ChipsInput/useChipsInput.js
var React192 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/lib/react/simulateReactInput.js
var simulateReactInput = (target, nextValue = "") => {
  try {
    const prevValue = target.value;
    target.value = nextValue;
    const tracker = target._valueTracker;
    if (tracker) {
      tracker.setValue(prevValue);
    }
    const event = new Event("input", {
      bubbles: true
    });
    target.dispatchEvent(event);
  } catch (error) {
    if (true) {
      throw error;
    }
  }
};

// node_modules/@vkontakte/vkui/dist/components/ChipsInput/useChipsInput.js
var transformValue = (value, getOptionValue, getOptionLabel) => value.map((option) => _object_spread_props(_object_spread({}, option), {
  label: getOptionLabel(option),
  value: getOptionValue(option)
}));
function getRegExpFromArray(separators) {
  const validSeparators = separators.filter((s) => s.length > 0);
  if (validSeparators.length === 0) {
    return null;
  }
  const escaped = validSeparators.map((s) => escapeRegExp(s));
  return new RegExp(`(?:${escaped.join("|")})`);
}
function getRegexFromDelimiter(delimiter) {
  if (delimiter instanceof RegExp) {
    return delimiter;
  }
  if (typeof delimiter === "string") {
    return new RegExp(escapeRegExp(delimiter));
  }
  return getRegExpFromArray(delimiter);
}
var useChipsInput = ({
  // option
  value: valueProp,
  defaultValue = DEFAULT_VALUE,
  onChange,
  getOptionLabel = getOptionLabelDefault,
  getOptionValue = getOptionValueDefault,
  getNewOptionData = getNewOptionDataDefault,
  // input
  inputValue: inputValueProp,
  defaultInputValue = DEFAULT_INPUT_VALUE,
  onInputChange: onInputChangeProp,
  // other
  disabled,
  delimiter
}) => {
  const [value, setValue] = useCustomEnsuredControl({
    disabled,
    value: valueProp ? transformValue(valueProp, getOptionValue, getOptionLabel) : void 0,
    defaultValue: transformValue(defaultValue, getOptionValue, getOptionLabel),
    onChange
  });
  const inputRef = React192.useRef(null);
  const [inputValue, setInputChange] = useEnsuredControl({
    disabled,
    value: inputValueProp,
    defaultValue: defaultInputValue,
    onChange: onInputChangeProp
  });
  const toggleOption = React192.useCallback((nextValuesProp, isNewValue) => {
    setValue((prevValue) => {
      const resolvedNextOptionsSet = /* @__PURE__ */ new Set();
      const resolvedNextOptions = nextValuesProp.map((option) => {
        const isLikeObjectOption = isValueLikeChipOptionObject(option);
        const resolvedOption = isLikeObjectOption ? getNewOptionData(option.value, option.label) : getNewOptionData(option, typeof option === "string" ? option : "");
        resolvedNextOptionsSet.add(resolvedOption.value);
        return isLikeObjectOption ? _object_spread({}, option, resolvedOption) : resolvedOption;
      });
      const nextValue = prevValue.filter((option) => !resolvedNextOptionsSet.has(option.value));
      if (isNewValue) {
        nextValue.push(...resolvedNextOptions);
      }
      return nextValue;
    });
  }, [
    setValue,
    getNewOptionData
  ]);
  const clearInput = React192.useCallback(() => {
    if (!inputRef.current) {
      return;
    }
    simulateReactInput(inputRef.current, "");
  }, [
    inputRef
  ]);
  const addOption = React192.useCallback((newValue) => toggleOption([
    newValue
  ], true), [
    toggleOption
  ]);
  const addOptions = React192.useCallback((newValues) => toggleOption(newValues, true), [
    toggleOption
  ]);
  const removeOption = React192.useCallback((newValue) => toggleOption([
    newValue
  ], false), [
    toggleOption
  ]);
  const addOptionFromInput = React192.useCallback((inputValue2) => {
    const label = inputValue2.trim();
    if (label) {
      addOption(label);
      clearInput();
    }
  }, [
    addOption,
    clearInput
  ]);
  const reset = React192.useCallback(() => {
    setValue(defaultValue);
  }, [
    defaultValue,
    setValue
  ]);
  const clearOptions = React192.useCallback(() => {
    setValue(DEFAULT_VALUE);
    clearInput();
  }, [
    clearInput,
    setValue
  ]);
  const onInputChange = React192.useCallback((e, canCreate = true) => {
    const newInputValue = e.target.value;
    const delimiterRegex = delimiter ? getRegexFromDelimiter(delimiter) : null;
    if (!delimiterRegex || !delimiterRegex.test(newInputValue) || !canCreate) {
      setInputChange(e);
      return;
    }
    const values = newInputValue.trim().split(delimiterRegex).map((v) => v.trim()).filter(Boolean);
    e.target.value = "";
    e.currentTarget.value = "";
    setInputChange(e);
    addOptions(values);
  }, [
    addOptions,
    delimiter,
    setInputChange
  ]);
  useNativeFormResetListener(inputRef, reset);
  return {
    value,
    addOption,
    addOptionFromInput,
    removeOption,
    inputRef,
    inputValue,
    onInputChange,
    clearInput,
    clearOptions
  };
};

// node_modules/@vkontakte/vkui/dist/components/ChipsInput/ChipsInput.js
var ChipsInput = (_param) => {
  var {
    // option
    value: valueProp,
    defaultValue,
    onChange,
    // input
    getRef,
    inputValue: inputValueProp,
    defaultInputValue: defaultInputValueProp,
    onInputChange: onInputChangeProp,
    getOptionValue,
    getOptionLabel,
    getNewOptionData,
    // other
    disabled: disabledProp,
    allowClearButton,
    delimiter,
    slotProps
  } = _param, restProps = _object_without_properties(_param, [
    "value",
    "defaultValue",
    "onChange",
    "getRef",
    "inputValue",
    "defaultInputValue",
    "onInputChange",
    "getOptionValue",
    "getOptionLabel",
    "getNewOptionData",
    "disabled",
    "allowClearButton",
    "delimiter",
    "slotProps"
  ]);
  const _useMergeProps = useMergeProps({
    getRootRef: getRef,
    value: inputValueProp,
    defaultValue: defaultInputValueProp,
    onChange: onInputChangeProp,
    disabled: disabledProp
  }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.input), { getRootRef: getInputRef, value: resolvedInputValue, defaultValue: resolvedInputDefaultValue, onChange: resolvedOnInputChange, disabled } = _useMergeProps, inputRest = _object_without_properties(_useMergeProps, [
    "getRootRef",
    "value",
    "defaultValue",
    "onChange",
    "disabled"
  ]);
  const {
    value,
    addOptionFromInput,
    removeOption,
    clearOptions,
    // input
    inputRef: inputRefHook,
    inputValue,
    onInputChange
  } = useChipsInput({
    // option
    value: valueProp,
    defaultValue,
    onChange,
    getOptionLabel,
    getOptionValue,
    getNewOptionData,
    // input
    inputValue: resolvedInputValue,
    defaultInputValue: resolvedInputDefaultValue,
    onInputChange: resolvedOnInputChange,
    // other
    disabled,
    delimiter
  });
  const inputRef = useExternRef(getInputRef, inputRefHook);
  return (0, import_jsx_runtime194.jsx)(ChipsInputBase, _object_spread({
    value,
    clearButtonShown: allowClearButton && (!!value.length || !!inputValue.length),
    onAddChipOption: addOptionFromInput,
    onRemoveChipOption: removeOption,
    onClear: clearOptions,
    slotProps: _object_spread_props(_object_spread({}, slotProps), {
      input: _object_spread({
        getRootRef: inputRef,
        value: inputValue,
        onChange: onInputChange,
        disabled
      }, inputRest)
    })
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/ChipsSelect/ChipsSelect.js
var import_jsx_runtime199 = __toESM(require_jsx_runtime(), 1);
var React197 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/lib/select.js
function getOptionLabelDefault2(option) {
  return option.label;
}
function defaultFilterFn(...args) {
  const [rawSearchQuery = "", option, getOptionLabel] = args;
  const foundRawLabel = getOptionLabel ? getOptionLabel(option) : getOptionLabelDefault2(option);
  if (foundRawLabel === void 0) {
    return false;
  }
  const searchQuery = rawSearchQuery.toLocaleLowerCase();
  const label = getTextFromChildren(foundRawLabel).toLocaleLowerCase();
  if (label.startsWith(searchQuery)) {
    return true;
  }
  const findAllIncludes = (target = "", search = "") => {
    const includes2 = [];
    let i = target.indexOf(search);
    while (i !== -1) {
      includes2.push(i);
      i = target.indexOf(search, i + 1);
    }
    return includes2;
  };
  const includes = findAllIncludes(label, searchQuery);
  if (includes.length) {
    const letterRegexp = new RegExp("\\p{L}", "u");
    for (const index2 of includes) {
      if (!letterRegexp.test(label[index2 - 1])) {
        return true;
      }
    }
  }
  return false;
}
var getFormFieldModeFromSelectType = (selectType = "default") => {
  return selectType === "default" ? "default" : "plain";
};

// node_modules/@vkontakte/vkui/dist/components/CustomSelectDropdown/CustomSelectDropdown.js
var import_jsx_runtime195 = __toESM(require_jsx_runtime(), 1);
var React193 = __toESM(require_react(), 1);
var CustomSelectDropdown = (_param) => {
  var {
    children,
    targetRef,
    scrollBoxRef,
    placement = "bottom",
    fetching,
    offsetDistance = 0,
    autoWidth = false,
    forcePortal = true,
    className,
    noMaxHeight = false,
    // CustomScrollView
    overscrollBehavior
  } = _param, restProps = _object_without_properties(_param, [
    "children",
    "targetRef",
    "scrollBoxRef",
    "placement",
    "fetching",
    "offsetDistance",
    "autoWidth",
    "forcePortal",
    "className",
    "noMaxHeight",
    "overscrollBehavior"
  ]);
  return (0, import_jsx_runtime195.jsx)(Popper, _object_spread_props(_object_spread({
    targetRef,
    offsetByMainAxis: offsetDistance,
    sameWidth: !autoWidth,
    placement,
    className: clsx("vkuiCustomSelectDropdown__host", "vkuiInternalCustomSelectDropdown", offsetDistance === 0 && (placement.includes("top") ? "vkuiCustomSelectDropdown__top" : "vkuiCustomSelectDropdown__bottom"), autoWidth && clsx("vkuiCustomSelectDropdown__wide", "vkuiInternalCustomSelectDropdown--wide"), className),
    usePortal: forcePortal,
    autoUpdateOnTargetResize: true,
    flipMiddlewareFallbackAxisSideDirection: "none"
  }, restProps), {
    children: (0, import_jsx_runtime195.jsx)(CustomScrollView, {
      getRootRef: scrollBoxRef,
      className: noMaxHeight ? void 0 : "vkuiCustomSelectDropdown__inWithMaxHeight",
      overscrollBehavior,
      tabIndex: -1,
      "aria-busy": fetching,
      children: fetching ? (0, import_jsx_runtime195.jsx)("div", {
        className: "vkuiCustomSelectDropdown__fetching",
        children: (0, import_jsx_runtime195.jsx)(Spinner, {
          size: "s"
        })
      }) : children
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/CustomSelectOption/CustomSelectOption.js
var import_jsx_runtime196 = __toESM(require_jsx_runtime(), 1);
var React194 = __toESM(require_react(), 1);
var sizeYClassNames27 = {
  none: "vkuiCustomSelectOption__sizeYNone",
  regular: "vkuiCustomSelectOption__sizeYRegular"
};
var CustomSelectOption = (_param) => {
  var { children, hierarchy = 0, hovered: hoveredProp, selected, before, after, description, disabled, style: styleProp, className, onClick } = _param, restProps = _object_without_properties(_param, [
    "children",
    "hierarchy",
    "hovered",
    "selected",
    "before",
    "after",
    "description",
    "disabled",
    "style",
    "className",
    "onClick"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const style = React194.useMemo(() => hierarchy > 0 ? {
    "--vkui_internal--custom_select_option_hierarchy_level": hierarchy
  } : void 0, [
    hierarchy
  ]);
  const hovered = hoveredProp && !disabled ? true : false;
  return (0, import_jsx_runtime196.jsxs)(Paragraph, _object_spread_props(_object_spread({}, restProps), {
    onClick: disabled ? void 0 : onClick,
    Component: "div",
    role: "option",
    "aria-disabled": disabled,
    "aria-selected": selected,
    "data-hovered": hovered,
    className: clsx("vkuiCustomSelectOption__host", sizeY !== "compact" && sizeYClassNames27[sizeY], hovered && "vkuiCustomSelectOption__hover", disabled && "vkuiCustomSelectOption__disabled", hierarchy > 0 && "vkuiCustomSelectOption__hierarchy", className),
    style: mergeStyle(style, styleProp),
    children: [
      hasReactNode(before) && (0, import_jsx_runtime196.jsx)("div", {
        className: "vkuiCustomSelectOption__before",
        children: before
      }),
      (0, import_jsx_runtime196.jsxs)("div", {
        className: "vkuiCustomSelectOption__main",
        children: [
          (0, import_jsx_runtime196.jsx)("div", {
            className: "vkuiCustomSelectOption__children",
            children
          }),
          hasReactNode(description) && (0, import_jsx_runtime196.jsxs)(Footnote, {
            className: "vkuiCustomSelectOption__description",
            children: [
              (0, import_jsx_runtime196.jsx)(VisuallyHidden, {
                children: " "
              }),
              description
            ]
          })
        ]
      }),
      (0, import_jsx_runtime196.jsxs)("div", {
        className: "vkuiCustomSelectOption__after",
        children: [
          hasReactNode(after) && (0, import_jsx_runtime196.jsx)("div", {
            children: after
          }),
          selected && (0, import_jsx_runtime196.jsx)(Icon16Done, {
            className: "vkuiCustomSelectOption__selectedIcon"
          })
        ]
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/DropdownIcon/DropdownIcon.js
var import_jsx_runtime197 = __toESM(require_jsx_runtime(), 1);
var React195 = __toESM(require_react(), 1);
var DropdownIcon = (_param) => {
  var { opened = false, className } = _param, restProps = _object_without_properties(_param, [
    "opened",
    "className"
  ]);
  const { sizeY } = useAdaptivityConditionalRender();
  const IconCompact = opened ? Icon20ChevronUp : Icon20Dropdown;
  const IconRegular = opened ? Icon24ChevronUp : Icon24ChevronDown;
  return (0, import_jsx_runtime197.jsxs)(React195.Fragment, {
    children: [
      sizeY.compact && (0, import_jsx_runtime197.jsx)(IconCompact, _object_spread({
        className: clsx(sizeY.compact.className, className)
      }, restProps)),
      sizeY.regular && (0, import_jsx_runtime197.jsx)(IconRegular, _object_spread({
        className: clsx(sizeY.regular.className, className)
      }, restProps))
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/ChipsSelect/constants.js
var import_jsx_runtime198 = __toESM(require_jsx_runtime(), 1);
var DEFAULT_SELECTED_BEHAVIOR = "highlight";
var DEFAULT_EMPTY_TEXT = "Ничего не найдено";
var FOCUS_ACTION_NEXT = "next";
var FOCUS_ACTION_PREV = "prev";
var renderOptionDefault = (props) => (0, import_jsx_runtime198.jsx)(CustomSelectOption, _object_spread({}, props));
var isCreateNewOptionPreset = (option) => option && "actionText" in option;
var isEmptyOptionPreset = (option) => option && "placeholder" in option;
var isNotServicePreset = (option) => !isCreateNewOptionPreset(option) && !isEmptyOptionPreset(option);

// node_modules/@vkontakte/vkui/dist/components/ChipsSelect/useChipsSelect.js
var React196 = __toESM(require_react(), 1);
var useChipsSelect = ({
  // common
  disabled,
  delimiter,
  // option
  value: valueProp,
  defaultValue,
  onChange,
  getOptionLabel = getOptionLabelDefault,
  getOptionValue = getOptionValueDefault,
  getNewOptionData = getNewOptionDataDefault,
  // input
  inputValue: inputValueProp,
  defaultInputValue = DEFAULT_INPUT_VALUE,
  onInputChange: onInputChangeProp,
  // dropdown
  creatable = false,
  emptyText = DEFAULT_EMPTY_TEXT,
  filterFn = defaultFilterFn,
  sortFn = false,
  selectedBehavior = DEFAULT_SELECTED_BEHAVIOR,
  options: optionsProp = DEFAULT_VALUE,
  onClose,
  onOpen
}) => {
  const _useChipsInput = useChipsInput({
    // option
    value: valueProp,
    defaultValue,
    onChange,
    getOptionValue,
    getOptionLabel,
    getNewOptionData,
    // input
    inputValue: inputValueProp,
    defaultInputValue,
    onInputChange: onInputChangeProp,
    // other
    disabled,
    delimiter
  }), { value, inputValue, onInputChange } = _useChipsInput, restChipsInputProps = _object_without_properties(_useChipsInput, [
    "value",
    "inputValue",
    "onInputChange"
  ]);
  const [opened, setOpened] = React196.useState(false);
  const [options, setOptions] = React196.useState(() => opened ? transformOptions({
    value,
    getOptionValue,
    getOptionLabel,
    inputValue,
    emptyText,
    creatable,
    filterFn,
    sortFn,
    options: optionsProp,
    selectedBehavior
  }) : []);
  const [focusedOptionIndex, setFocusedOptionIndex] = React196.useState(0);
  const [focusedOption, setFocusedOption] = React196.useState(null);
  const handleOpened = React196.useCallback((isOpened) => {
    isOpened ? onOpen === null || onOpen === void 0 ? void 0 : onOpen() : onClose === null || onClose === void 0 ? void 0 : onClose();
    setOpened(isOpened);
  }, [
    onOpen,
    onClose
  ]);
  const handleInputChange = React196.useCallback((event) => {
    onInputChange(event, !!creatable);
    if (!opened) {
      handleOpened(true);
      setFocusedOptionIndex(0);
    }
  }, [
    onInputChange,
    creatable,
    opened,
    handleOpened
  ]);
  useIsomorphicLayoutEffect(function handleDropdownOpen() {
    if (!opened) {
      return;
    }
    setOptions((prevOptions) => {
      const nextOptions = transformOptions({
        value,
        getOptionValue,
        getOptionLabel,
        inputValue,
        emptyText,
        creatable,
        filterFn,
        sortFn,
        options: optionsProp,
        selectedBehavior
      });
      if (isEqual(prevOptions, nextOptions)) {
        return prevOptions;
      }
      return nextOptions;
    });
  }, [
    opened,
    value,
    getOptionLabel,
    getOptionValue,
    inputValue,
    optionsProp,
    creatable,
    selectedBehavior,
    filterFn,
    sortFn
  ]);
  return _object_spread_props(_object_spread({}, restChipsInputProps), {
    // options
    value,
    // input
    inputValue,
    onInputChange: handleInputChange,
    // dropdown states
    options,
    opened,
    setOpened: handleOpened,
    focusedOption,
    focusedOptionIndex,
    setFocusedOption,
    setFocusedOptionIndex
  });
};
function transformOptions({ value, getOptionValue = getOptionValueDefault, getOptionLabel = getOptionLabelDefault, inputValue = DEFAULT_INPUT_VALUE, emptyText = DEFAULT_EMPTY_TEXT, creatable = false, sortFn = false, filterFn = defaultFilterFn, options: optionsProp = DEFAULT_VALUE, selectedBehavior = DEFAULT_SELECTED_BEHAVIOR }) {
  const filteredOptionsProp = filterFn ? optionsProp.filter((option) => filterFn(inputValue, option, getOptionLabel)) : optionsProp;
  if (filteredOptionsProp.length === 0) {
    if (inputValue !== DEFAULT_INPUT_VALUE && typeof creatable === "string") {
      return [
        {
          actionText: creatable
        }
      ];
    }
    return [
      {
        placeholder: emptyText
      }
    ];
  }
  if (sortFn) {
    filteredOptionsProp.sort((optionA, optionB) => sortFn(optionA, optionB, inputValue));
  }
  const parsedOptions = transformValue(filteredOptionsProp, getOptionValue, getOptionLabel);
  if (selectedBehavior === "hide") {
    const selected = value.map((item) => item.value);
    return parsedOptions.filter((item) => isNotServicePreset(item) ? !selected.includes(item.value) : false);
  }
  return parsedOptions;
}

// node_modules/@vkontakte/vkui/dist/components/ChipsSelect/ChipsSelect.js
var findIndexAfter = (options = [], startIndex = -1) => {
  if (startIndex >= options.length - 1) {
    return -1;
  }
  return options.findIndex((option, i) => i > startIndex && (!isNotServicePreset(option) || !option.disabled));
};
var findIndexBefore = (options = [], endIndex = options.length) => {
  let result = -1;
  if (endIndex <= 0) {
    return result;
  }
  for (let i = endIndex - 1; i >= 0; i--) {
    let option = options[i];
    if (!isNotServicePreset(option) || !option.disabled) {
      result = i;
      break;
    }
  }
  return result;
};
var ChipsSelect = (_param) => {
  var {
    // FormFieldProps
    getRootRef,
    className,
    status = "default",
    icon: dropdownIconProp,
    onChangeStart,
    // CustomSelectDropdownProps
    options: optionsProp,
    placement: placementProp = "bottom",
    closeAfterSelect = true,
    selectedBehavior = DEFAULT_SELECTED_BEHAVIOR,
    emptyText = DEFAULT_EMPTY_TEXT,
    creatable = false,
    fetching = false,
    dropdownAutoWidth,
    forceDropdownPortal,
    noMaxHeight = false,
    filterFn = defaultFilterFn,
    sortFn = false,
    dropdownTestId,
    onClose,
    onOpen,
    overscrollBehavior,
    renderDropdown,
    // ChipsInputProps
    getRef,
    value: valueProp,
    defaultValue,
    inputValue: inputValueProp,
    defaultInputValue: defaultInputValueProp,
    getOptionValue = getOptionValueDefault,
    getOptionLabel = getOptionLabelDefault,
    getNewOptionData = getNewOptionDataDefault,
    renderChip = renderChipDefault,
    renderOption = renderOptionDefault,
    onChange,
    onInputChange: onInputChangeProp,
    dropdownOffsetDistance = 0,
    allowClearButton,
    clearButtonTestId,
    delimiter,
    // a11y
    chipsListLabel,
    // input native props
    disabled: disabledProp,
    readOnly: readOnlyProp,
    id: idProp,
    onFocus: onFocusProp,
    onBlur: onBlurProp,
    onKeyDown: onKeyDownProp,
    slotProps
  } = _param, restProps = _object_without_properties(_param, [
    "getRootRef",
    "className",
    "status",
    "icon",
    "onChangeStart",
    "options",
    "placement",
    "closeAfterSelect",
    "selectedBehavior",
    "emptyText",
    "creatable",
    "fetching",
    "dropdownAutoWidth",
    "forceDropdownPortal",
    "noMaxHeight",
    "filterFn",
    "sortFn",
    "dropdownTestId",
    "onClose",
    "onOpen",
    "overscrollBehavior",
    "renderDropdown",
    "getRef",
    "value",
    "defaultValue",
    "inputValue",
    "defaultInputValue",
    "getOptionValue",
    "getOptionLabel",
    "getNewOptionData",
    "renderChip",
    "renderOption",
    "onChange",
    "onInputChange",
    "dropdownOffsetDistance",
    "allowClearButton",
    "clearButtonTestId",
    "delimiter",
    "chipsListLabel",
    "disabled",
    "readOnly",
    "id",
    "onFocus",
    "onBlur",
    "onKeyDown",
    "slotProps"
  ]);
  const _useMergeProps = useMergeProps({
    getRootRef: getRef,
    value: inputValueProp,
    defaultValue: defaultInputValueProp,
    onChange: onInputChangeProp,
    disabled: disabledProp,
    readOnly: readOnlyProp,
    id: idProp,
    onFocus: onFocusProp,
    onBlur: onBlurProp,
    onKeyDown: onKeyDownProp
  }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.input), { getRootRef: getInputRef, value: resolvedInputValue, defaultValue: resolvedDefaultInputValue, onChange: resolvedOnInputChange, disabled, readOnly, id: labelledbyId, onFocus, onBlur, onKeyDown } = _useMergeProps, inputRest = _object_without_properties(_useMergeProps, [
    "getRootRef",
    "value",
    "defaultValue",
    "onChange",
    "disabled",
    "readOnly",
    "id",
    "onFocus",
    "onBlur",
    "onKeyDown"
  ]);
  const {
    // Связано с ChipsInputProps
    // option
    value,
    addOptionFromInput,
    addOption,
    removeOption,
    clearOptions,
    // input
    inputRef: inputRefHook,
    inputValue,
    clearInput,
    onInputChange,
    // Связано с CustomSelectDropdownProps
    options,
    opened,
    setOpened,
    focusedOption,
    focusedOptionIndex,
    setFocusedOption,
    setFocusedOptionIndex
  } = useChipsSelect({
    // option
    value: valueProp,
    defaultValue,
    onChange,
    getOptionValue,
    getOptionLabel,
    getNewOptionData,
    // input
    inputValue: resolvedInputValue,
    defaultInputValue: resolvedDefaultInputValue,
    onInputChange: resolvedOnInputChange,
    // dropdown
    options: optionsProp,
    emptyText,
    creatable,
    filterFn,
    sortFn,
    selectedBehavior,
    onClose,
    onOpen,
    // other
    disabled,
    delimiter
  });
  const rootRef = useExternRef(getRootRef);
  const inputRef = useExternRef(getInputRef, inputRefHook);
  const [dropdownVerticalPlacement, setDropdownVerticalPlacement] = React197.useState(placementProp);
  const onDropdownPlacementChange = React197.useCallback((placement) => {
    if (placement.startsWith("top")) {
      setDropdownVerticalPlacement("top");
    } else if (placement.startsWith("bottom")) {
      setDropdownVerticalPlacement("bottom");
    }
  }, []);
  const dropdownId = React197.useId();
  const dropdownCurrentItemId = focusedOptionIndex !== null ? `${dropdownId}-${focusedOptionIndex}` : void 0;
  const dropdownScrollBoxRef = React197.useRef(null);
  const handleFocus = (event) => {
    if (onFocus) {
      onFocus(event);
    }
    if (!readOnly) {
      setOpened(true);
      setFocusedOptionIndex(null);
    }
  };
  const handleBlur = (event) => {
    if (onBlur) {
      onBlur(event);
    }
    if (!readOnly && !event.defaultPrevented && !creatable) {
      event.preventDefault();
    }
  };
  const chipsSelectOptions = React197.useRef([]).current;
  const scrollToElement = (index2, center = false) => {
    const dropdown = dropdownScrollBoxRef.current;
    const item = chipsSelectOptions[index2];
    if (!item || !dropdown) {
      return;
    }
    const dropdownHeight = dropdown.offsetHeight;
    const scrollTop = dropdown.scrollTop;
    const itemTop = item.offsetTop;
    const itemHeight = item.offsetHeight;
    if (center) {
      dropdown.scrollTop = itemTop - dropdownHeight / 2 + itemHeight / 2;
    } else if (itemTop + itemHeight > dropdownHeight + scrollTop) {
      dropdown.scrollTop = itemTop - dropdownHeight + itemHeight;
    } else if (itemTop < scrollTop) {
      dropdown.scrollTop = itemTop;
    }
  };
  const focusOptionByIndex = (index2, oldIndex) => {
    if (index2 === oldIndex) {
      return;
    }
    const option = options[index2];
    if (isNotServicePreset(option) && option.disabled) {
      return;
    }
    scrollToElement(index2);
    setFocusedOptionIndex(index2);
  };
  const focusOption = (nextIndex, type) => {
    let index2 = nextIndex === null ? -1 : nextIndex;
    if (type === FOCUS_ACTION_NEXT) {
      const nextIndex2 = findIndexAfter(options, index2);
      index2 = nextIndex2 === -1 ? findIndexAfter(options) : nextIndex2;
    } else if (type === FOCUS_ACTION_PREV) {
      const beforeIndex = findIndexBefore(options, index2);
      index2 = beforeIndex === -1 ? findIndexBefore(options) : beforeIndex;
    }
    focusOptionByIndex(index2, focusedOptionIndex);
  };
  const handleKeyDown = (event) => {
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.defaultPrevented || readOnly) {
      return;
    }
    switch (event.key) {
      case Keys.ARROW_UP:
      case Keys.ARROW_DOWN:
        event.preventDefault();
        if (!opened) {
          setOpened(true);
          focusOption(null, FOCUS_ACTION_NEXT);
        } else {
          focusOption(focusedOptionIndex, event.key === Keys.ARROW_UP ? FOCUS_ACTION_PREV : FOCUS_ACTION_NEXT);
        }
        break;
      case Keys.ENTER: {
        if (!opened) {
          break;
        }
        if (focusedOptionIndex != null) {
          const foundOption = options[focusedOptionIndex];
          if (foundOption && isNotServicePreset(foundOption)) {
            event.preventDefault();
            if (onChangeStart) {
              onChangeStart(event, foundOption);
            }
            addOption(foundOption);
            setFocusedOptionIndex(null);
            clearInput();
            if (closeAfterSelect) {
              setOpened(false);
            }
            break;
          }
        }
        if (!creatable) {
          event.preventDefault();
        }
        break;
      }
      case Keys.ESCAPE:
      case Keys.TAB:
        if (opened) {
          setOpened(false);
        }
    }
  };
  React197.useEffect(() => {
    if (focusedOptionIndex === null) {
      setFocusedOption(null);
    } else {
      const foundFocusedOptionIndex = options[focusedOptionIndex];
      if (foundFocusedOptionIndex && isNotServicePreset(foundFocusedOptionIndex)) {
        setFocusedOption(foundFocusedOptionIndex);
      }
    }
  }, [
    options,
    focusedOptionIndex,
    setFocusedOption
  ]);
  const onDropdownMouseLeave = React197.useCallback(() => {
    setFocusedOptionIndex(null);
  }, [
    setFocusedOptionIndex
  ]);
  const handleClickOutside = React197.useCallback(() => {
    setOpened(false);
  }, [
    setOpened
  ]);
  useGlobalOnEventOutside("mousedown", handleClickOutside, opened ? rootRef : null, opened ? dropdownScrollBoxRef : null);
  const onDropdownIconClick = React197.useCallback((e) => {
    e.preventDefault();
    setOpened(!opened);
  }, [
    opened,
    setOpened
  ]);
  const dropdownContent = React197.useMemo(() => {
    const defaultDropdownContent = options.map((option, index2) => {
      const dropdownItemId = `${dropdownId}-${index2}`;
      if (isEmptyOptionPreset(option)) {
        return (0, import_jsx_runtime199.jsx)(Footnote, {
          className: "vkuiChipsSelect__empty",
          children: option.placeholder
        }, "empty-text");
      }
      if (isCreateNewOptionPreset(option)) {
        return (0, import_jsx_runtime199.jsx)(CustomSelectOption, {
          id: dropdownItemId,
          hovered: focusedOptionIndex === index2,
          onMouseDown: () => addOptionFromInput(inputValue),
          onMouseEnter: () => setFocusedOptionIndex(index2),
          children: option.actionText
        }, "create-new-option");
      }
      return (0, import_jsx_runtime199.jsx)(React197.Fragment, {
        children: renderOption({
          id: dropdownItemId,
          disabled: option.disabled,
          hovered: focusedOption ? getOptionValue(option) === getOptionValue(focusedOption) : false,
          children: option.label,
          selected: !!value.find((selectedOption) => getOptionValue(selectedOption) === getOptionValue(option)),
          getRootRef(node) {
            if (node) {
              chipsSelectOptions[index2] = node;
            }
          },
          onMouseDown(event) {
            if (option.disabled) {
              return;
            }
            if (onChangeStart) {
              onChangeStart(event, option);
            }
            if (!event.defaultPrevented) {
              closeAfterSelect && setOpened(false);
              addOption(option);
              clearInput();
            }
          },
          onMouseEnter() {
            setFocusedOptionIndex(index2);
          }
        }, option)
      }, `${typeof option.value}-${option.value}`);
    });
    if (renderDropdown) {
      return renderDropdown({
        defaultDropdownContent
      });
    }
    return defaultDropdownContent;
  }, [
    addOption,
    addOptionFromInput,
    chipsSelectOptions,
    clearInput,
    closeAfterSelect,
    dropdownId,
    focusedOption,
    focusedOptionIndex,
    getOptionValue,
    inputValue,
    onChangeStart,
    options,
    renderDropdown,
    renderOption,
    setFocusedOptionIndex,
    setOpened,
    value
  ]);
  const openedClassNames = React197.useMemo(() => opened && dropdownOffsetDistance === 0 && (dropdownVerticalPlacement.includes("top") ? "vkuiChipsSelect__popUp" : "vkuiChipsSelect__popDown") || void 0, [
    dropdownOffsetDistance,
    opened,
    dropdownVerticalPlacement
  ]);
  const clearButtonShown = allowClearButton && (!!value.length || !!inputValue.length);
  return (0, import_jsx_runtime199.jsxs)(import_jsx_runtime199.Fragment, {
    children: [
      (0, import_jsx_runtime199.jsx)(ChipsInputBase, _object_spread({
        clearButtonShown,
        clearButtonTestId,
        // FormFieldProps
        getRootRef: rootRef,
        className: clsx("vkuiChipsSelect__host", openedClassNames, className),
        status,
        after: dropdownIconProp || (0, import_jsx_runtime199.jsx)(DropdownIcon, {
          opened,
          onClick: onDropdownIconClick,
          className: clsx("vkuiChipsSelect__dropdownIcon", clearButtonShown && "vkuiChipsSelect__dropdownIconWithOffset")
        }),
        // option
        value,
        onAddChipOption: addOptionFromInput,
        onRemoveChipOption: removeOption,
        renderChip,
        onClear: clearOptions,
        // a11y
        chipsListLabel,
        slotProps: _object_spread_props(_object_spread({}, slotProps), {
          input: _object_spread({
            "role": "combobox",
            "aria-expanded": opened,
            "aria-autocomplete": "list",
            "aria-activedescendant": opened ? dropdownCurrentItemId : void 0,
            "aria-haspopup": "listbox",
            "getRootRef": inputRef,
            "value": inputValue,
            "onChange": onInputChange,
            disabled,
            readOnly,
            "id": labelledbyId,
            "onFocus": handleFocus,
            "onBlur": handleBlur,
            "onKeyDown": handleKeyDown
          }, inputRest)
        })
      }, restProps)),
      opened && (0, import_jsx_runtime199.jsx)(CustomSelectDropdown, {
        "data-testid": dropdownTestId,
        targetRef: rootRef,
        placement: dropdownVerticalPlacement,
        scrollBoxRef: dropdownScrollBoxRef,
        onPlacementChange: onDropdownPlacementChange,
        onMouseLeave: onDropdownMouseLeave,
        fetching,
        autoWidth: dropdownAutoWidth,
        forcePortal: forceDropdownPortal,
        noMaxHeight,
        offsetDistance: dropdownOffsetDistance,
        overscrollBehavior,
        // a11y
        id: dropdownId,
        role: "listbox",
        "aria-labelledby": labelledbyId,
        children: dropdownContent
      })
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/Slider/Slider.js
var import_jsx_runtime201 = __toESM(require_jsx_runtime(), 1);
var React199 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/Slider/SliderThumb/SliderThumb.js
var import_jsx_runtime200 = __toESM(require_jsx_runtime(), 1);
var React198 = __toESM(require_react(), 1);
var SliderThumb = (_param) => {
  var { className, getRootRef, inputProps, withTooltip, isActive } = _param, restProps = _object_without_properties(_param, [
    "className",
    "getRootRef",
    "inputProps",
    "withTooltip",
    "isActive"
  ]);
  const { focusVisible, onBlur, onFocus } = useFocusVisible();
  const focusVisibleClassNames = useFocusVisibleClassName({
    focusVisible,
    mode: "vkuiSliderThumb__focusVisible"
  });
  const [arrowRef, setArrowRef] = React198.useState(null);
  const memoizedMiddlewares = React198.useMemo(() => {
    return [
      offset3({
        crossAxis: 0,
        mainAxis: 15
      }),
      flip3(),
      shift3({
        padding: 8
      }),
      arrow3({
        element: arrowRef
      })
    ];
  }, [
    arrowRef
  ]);
  const { x: floatingDataX, y: floatingDataY, placement: resolvedPlacement, refs, strategy: floatingPositionStrategy, middlewareData: { arrow: arrowCoords }, update: updateTooltipPosition } = useFloating({
    placement: "top",
    middleware: memoizedMiddlewares
  });
  const { value: isHovered, setTrue: setHoveredTrue, setFalse: setHoveredFalse } = useBooleanState(false);
  const handleRootRef = useExternRef(getRootRef, refs.setReference);
  const shouldShowTooltip = withTooltip && (focusVisible || isHovered || isActive);
  const inputValue = inputProps && inputProps.value;
  React198.useEffect(function udpateTooltipPositionOnValueChange() {
    if (shouldShowTooltip && inputValue !== "undefined") {
      updateTooltipPosition();
    }
  }, [
    inputValue,
    updateTooltipPosition,
    shouldShowTooltip
  ]);
  return (0, import_jsx_runtime200.jsxs)(React198.Fragment, {
    children: [
      (0, import_jsx_runtime200.jsx)("span", _object_spread_props(_object_spread({}, restProps), {
        ref: handleRootRef,
        onMouseEnter: setHoveredTrue,
        onMouseLeave: setHoveredFalse,
        className: clsx("vkuiSliderThumb__host", focusVisibleClassNames, isActive && "vkuiSliderThumb__active", isHovered && "vkuiSliderThumb__hover", className),
        children: (0, import_jsx_runtime200.jsx)("input", _object_spread_props(_object_spread({}, inputProps), {
          type: "range",
          className: "vkuiSliderThumb__nativeInput",
          "aria-orientation": "horizontal",
          onBlur,
          onFocus
        }))
      })),
      shouldShowTooltip && (0, import_jsx_runtime200.jsx)(TooltipBase, {
        appearance: "neutral",
        getRootRef: refs.setFloating,
        style: convertFloatingDataToReactCSSProperties({
          strategy: floatingPositionStrategy,
          x: floatingDataX,
          y: floatingDataY
        }),
        arrowProps: {
          coords: arrowCoords,
          placement: resolvedPlacement,
          getRootRef: setArrowRef
        },
        description: inputValue
      })
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/Slider/helpers.js
var toPercent = (v, min2, max2) => (v - min2) / (max2 - min2) * 100;
var offsetToValue = (startX, width, min2, max2, step) => {
  return rescale(startX, [
    0,
    width
  ], [
    min2,
    max2
  ], {
    step
  });
};
var restrictValueByMinMax = (value, min2, max2) => {
  if (value < min2) {
    return min2;
  }
  if (value > max2) {
    return max2;
  }
  return value;
};
var updateInternalStateValue = (prevValue, nextValue, min2, max2, dragging) => {
  const [prevStartValue, prevEndValue] = prevValue;
  if (prevEndValue === null) {
    return [
      restrictValueByMinMax(nextValue, min2, max2),
      null
    ];
  }
  switch (dragging) {
    case "start":
      return nextValue > prevEndValue ? [
        prevEndValue,
        prevEndValue
      ] : [
        restrictValueByMinMax(nextValue, min2, max2),
        prevEndValue
      ];
    case "end":
      return nextValue < prevStartValue ? [
        prevStartValue,
        prevStartValue
      ] : [
        prevStartValue,
        restrictValueByMinMax(nextValue, min2, max2)
      ];
    case null:
    default:
      return prevValue;
  }
};
var updateInternalStateValueByNativeChange = (prevValue, nextValue, dragging) => {
  const [prevStartValue, prevEndValue] = prevValue;
  switch (dragging) {
    case "start":
      return [
        nextValue,
        prevEndValue
      ];
    case "end":
      return [
        prevStartValue,
        nextValue
      ];
    case null:
    default:
      return prevValue;
  }
};
function isMultipleValues(value) {
  return value[1] !== null;
}
var snapDirection = (prevValue, nextValue, type) => {
  if (type === "start") {
    return "start";
  }
  if (type === "end") {
    return "end";
  }
  const [startRaw, endRaw] = prevValue;
  const FORCE_DIFF_VALUE = 0.1;
  const start = endRaw !== null ? startRaw - FORCE_DIFF_VALUE : startRaw;
  const end = endRaw !== null ? endRaw + FORCE_DIFF_VALUE : 0;
  return Math.abs(start - nextValue) <= Math.abs(end - nextValue) ? "start" : "end";
};
var getDraggingTypeByTargetDataset = (target) => {
  if (target) {
    if (target.dataset.type === "start") {
      return "start";
    }
    if (target.dataset.type === "end") {
      return "end";
    }
  }
  return null;
};
var resetProps = {
  "aria-label": void 0,
  "aria-valuetext": void 0,
  "aria-labelledby": void 0
};
var extractSliderAriaAttributesFromRestProps = (restProps) => {
  const ariaLabel = restProps["aria-label"];
  const ariaValueText = restProps["aria-valuetext"];
  const ariaLabelledBy = restProps["aria-labelledby"];
  return _object_spread_props(_object_spread({}, restProps, resetProps), {
    ariaLabel,
    ariaValueText,
    ariaLabelledBy
  });
};

// node_modules/@vkontakte/vkui/dist/components/Slider/Slider.js
var sizeYClassNames28 = {
  none: "vkuiSlider__sizeYNone",
  compact: "vkuiSlider__sizeYCompact"
};
var sizeClassNames5 = {
  l: "vkuiSlider__sizeL",
  m: "vkuiSlider__sizeM",
  s: "vkuiSlider__sizeS"
};
var Slider = (_param) => {
  var { step = 1, min: min2 = 0, max: max2 = 100, value: valueProp, multiple: multipleProp, defaultValue = multipleProp ? [
    min2,
    max2
  ] : min2, disabled, className, getRootRef, getAriaLabel, getAriaValueText, startThumbTestId, endThumbTestId, onChange, withTooltip, size: size5 = "l", style: styleProp } = _param, restProps = _object_without_properties(_param, [
    "step",
    "min",
    "max",
    "value",
    "multiple",
    "defaultValue",
    "disabled",
    "className",
    "getRootRef",
    "getAriaLabel",
    "getAriaValueText",
    "startThumbTestId",
    "endThumbTestId",
    "onChange",
    "withTooltip",
    "size",
    "style"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const direction = useConfigDirection();
  const isRtl = direction === "rtl";
  const isControlled = valueProp !== void 0;
  const [localValue, setValue] = React199.useState(defaultValue);
  const value = React199.useMemo(() => {
    const resolvedValue = isControlled ? valueProp : localValue;
    return Array.isArray(resolvedValue) ? [
      clamp2(resolvedValue[0], min2, max2),
      clamp2(resolvedValue[1], min2, max2)
    ] : [
      clamp2(resolvedValue, min2, max2),
      null
    ];
  }, [
    isControlled,
    valueProp,
    localValue,
    min2,
    max2
  ]);
  const [startValue, endValue] = value;
  const multiple = multipleProp && endValue !== null;
  const startValueInPercent = toPercent(startValue, min2, max2);
  const endReversedValueInPercent = multiple ? toPercent(endValue, min2, max2) : 0;
  const [activeThumb, setActiveThumb] = React199.useState(null);
  const gesture = React199.useRef({
    dragging: null,
    startX: 0,
    containerWidth: 0
  }).current;
  const thumbsContainerRef = useExternRef(getRootRef);
  const thumbStartInputRef = React199.useRef(null);
  const thumbEndInputRef = React199.useRef(null);
  const _extractSliderAriaAttributesFromRestProps = extractSliderAriaAttributesFromRestProps(restProps), { ariaLabel, ariaValueText, ariaLabelledBy } = _extractSliderAriaAttributesFromRestProps, restPropsWithoutAriaAttributes = _object_without_properties(_extractSliderAriaAttributesFromRestProps, [
    "ariaLabel",
    "ariaValueText",
    "ariaLabelledBy"
  ]);
  const changeValue = (nextValue, event) => {
    if (disabled || value[0] === nextValue[0] && value[1] === nextValue[1]) {
      return;
    }
    if (multipleProp) {
      if (isMultipleValues(nextValue)) {
        !isControlled && setValue(nextValue);
        onChange && onChange(nextValue, event);
      }
    } else {
      !isControlled && setValue(nextValue[0]);
      onChange && onChange(nextValue[0], event);
    }
  };
  const handlePointerStart = (event) => {
    if (!thumbsContainerRef.current) {
      return;
    }
    const { left: nextContainerX, width: nextContainerWidth } = thumbsContainerRef.current.getBoundingClientRect();
    const foundDraggingType = getDraggingTypeByTargetDataset(event.originalEvent.target);
    let nextStartX = event.startX - nextContainerX;
    if (isRtl) {
      nextStartX = nextContainerWidth - nextStartX;
    }
    const nextValue = offsetToValue(nextStartX, nextContainerWidth, min2, max2, step);
    const nextDragging = snapDirection(value, nextValue, foundDraggingType);
    gesture.dragging = nextDragging;
    gesture.containerWidth = nextContainerWidth;
    gesture.startX = nextStartX;
    const updatedInternalStateValue = updateInternalStateValue(value, nextValue, min2, max2, nextDragging);
    const [nextStartValue, nextEndValue] = updatedInternalStateValue;
    if (thumbStartInputRef.current && (foundDraggingType === "start" || nextStartValue !== startValue && nextEndValue === endValue)) {
      thumbStartInputRef.current.focus();
      event.originalEvent.preventDefault();
    } else if (thumbEndInputRef.current && (foundDraggingType === "end" || nextEndValue !== endValue && nextStartValue === startValue)) {
      thumbEndInputRef.current.focus();
      event.originalEvent.preventDefault();
    }
    changeValue(updatedInternalStateValue, event);
    event.originalEvent.stopPropagation();
    setActiveThumb(gesture.dragging);
  };
  const handlePointerMove = (event) => {
    const { startX, containerWidth, dragging } = gesture;
    const { shiftX = 0 } = event;
    const nextStartX = startX + (isRtl ? -shiftX : shiftX);
    const nextValue = offsetToValue(nextStartX, containerWidth, min2, max2, step);
    changeValue(updateInternalStateValue(value, nextValue, min2, max2, dragging), event);
    event.originalEvent.stopPropagation();
    event.originalEvent.preventDefault();
  };
  const handlePointerEnd = (event) => {
    gesture.dragging = null;
    event.originalEvent.stopPropagation();
    setActiveThumb(null);
  };
  const handleChangeByNativeInput = (event) => {
    changeValue(updateInternalStateValueByNativeChange(value, Number(event.target.value), getDraggingTypeByTargetDataset(event.target)), event);
  };
  const style = {
    "--vkui_internal--Slider_start_value": String(startValueInPercent),
    "--vkui_internal--Slider_end_value": String(endReversedValueInPercent)
  };
  return (0, import_jsx_runtime201.jsxs)(Touch, _object_spread_props(_object_spread({
    "data-value": multiple ? `${startValue},${endValue}` : startValue
  }, restPropsWithoutAriaAttributes), {
    className: clsx("vkuiSlider__host", disabled && "vkuiSlider__disabled", sizeY !== "regular" && sizeYClassNames28[sizeY], sizeClassNames5[size5], multiple && "vkuiSlider__multiple", isRtl && "vkuiSlider__rtl", className),
    style: mergeStyle(styleProp, style),
    getRootRef,
    onStart: disabled ? void 0 : handlePointerStart,
    onMove: disabled ? void 0 : handlePointerMove,
    onEnd: disabled ? void 0 : handlePointerEnd,
    children: [
      (0, import_jsx_runtime201.jsx)("div", {
        className: "vkuiSlider__track"
      }),
      (0, import_jsx_runtime201.jsx)("div", {
        className: "vkuiSlider__trackFill"
      }),
      (0, import_jsx_runtime201.jsxs)("div", {
        ref: thumbsContainerRef,
        className: "vkuiSlider__thumbs",
        children: [
          (0, import_jsx_runtime201.jsx)(SliderThumb, {
            "data-type": "start",
            className: clsx("vkuiSlider__thumb", "vkuiSlider__thumbStart"),
            style: {
              // Меняем местами порядок слоёв, иначе, при достижении `start` и `end` 100%, `end` будет перекрывать `start`.
              zIndex: multiple && startValueInPercent >= 50 ? 2 : void 0
            },
            withTooltip,
            inputProps: {
              "data-type": "start",
              "data-testid": startThumbTestId,
              "ref": thumbStartInputRef,
              "step": step,
              "min": min2,
              "value": startValue,
              "max": multiple ? endValue : max2,
              "disabled": disabled,
              "aria-label": getAriaLabel ? getAriaLabel(0) : ariaLabel,
              "aria-valuetext": getAriaValueText ? getAriaValueText(startValue, 0) : ariaValueText,
              "aria-labelledby": ariaLabelledBy,
              "onChange": handleChangeByNativeInput
            },
            isActive: activeThumb === "start"
          }),
          multiple && (0, import_jsx_runtime201.jsx)(SliderThumb, {
            "data-type": "end",
            className: clsx("vkuiSlider__thumb", "vkuiSlider__thumbEnd"),
            withTooltip,
            inputProps: {
              "data-type": "end",
              "data-testid": endThumbTestId,
              "ref": thumbEndInputRef,
              "step": step,
              "min": startValue,
              "value": endValue,
              "max": max2,
              "disabled": disabled,
              "aria-label": getAriaLabel ? getAriaLabel(1) : ariaLabel,
              "aria-valuetext": getAriaValueText ? getAriaValueText(endValue, 1) : ariaValueText,
              "aria-labelledby": ariaLabelledBy,
              "onChange": handleChangeByNativeInput
            },
            isActive: activeThumb === "end"
          })
        ]
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Textarea/Textarea.js
var import_jsx_runtime202 = __toESM(require_jsx_runtime(), 1);
var React200 = __toESM(require_react(), 1);
var warn29 = warnOnce("Textarea");
var sizeYClassNames29 = {
  none: "vkuiTextarea__sizeYNone",
  compact: "vkuiTextarea__sizeYCompact"
};
var Textarea = (_param) => {
  var { className: rootClassName, getRootRef, style, grow = true, onResize, getRef, rows = 2, maxHeight, status, align, mode, after, before, afterAlign, beforeAlign, slotProps } = _param, restProps = _object_without_properties(_param, [
    "className",
    "getRootRef",
    "style",
    "grow",
    "onResize",
    "getRef",
    "rows",
    "maxHeight",
    "status",
    "align",
    "mode",
    "after",
    "before",
    "afterAlign",
    "beforeAlign",
    "slotProps"
  ]);
  if (getRef) {
    warn29("Свойство `getRef` устаревшее, используйте `slotProps={ textArea: { getRootRef: ... } }`");
  }
  const { sizeY = "none" } = useAdaptivity();
  const platform3 = usePlatform();
  const { window: window2 } = useDOM();
  const _useMergeProps = useMergeProps({
    className: rootClassName,
    getRootRef,
    style
  }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.root), { className } = _useMergeProps, rootProps = _object_without_properties(_useMergeProps, [
    "className"
  ]);
  const _useMergeProps1 = useMergeProps(_object_spread({
    className: "vkuiTextarea__el",
    getRootRef: getRef
  }, restProps), slotProps === null || slotProps === void 0 ? void 0 : slotProps.textArea), { onChange, getRootRef: getTextAreaRef, value } = _useMergeProps1, textAreaRest = _object_without_properties(_useMergeProps1, [
    "onChange",
    "getRootRef",
    "value"
  ]);
  const [refResizeTextarea, resize] = useResizeTextarea(onResize, grow);
  const elementRef = useExternRef(getTextAreaRef, refResizeTextarea);
  React200.useEffect(resize, [
    resize,
    sizeY,
    platform3,
    value
  ]);
  useResizeObserver(window2, resize);
  return (0, import_jsx_runtime202.jsx)(FormField, _object_spread_props(_object_spread({
    className: clsx("vkuiTextarea__host", sizeY !== "regular" && sizeYClassNames29[sizeY], align === "right" && "vkuiTextarea__alignRight", align === "center" && "vkuiTextarea__alignCenter", className),
    disabled: textAreaRest.disabled,
    status,
    mode,
    after,
    before,
    afterAlign,
    beforeAlign,
    maxHeight
  }, rootProps), {
    children: (0, import_jsx_runtime202.jsx)(UnstyledTextField, _object_spread({
      value,
      as: "textarea",
      rows,
      getRootRef: elementRef,
      onChange: callMultiple(onChange, resize)
    }, textAreaRest))
  }));
};

// node_modules/@vkontakte/vkui/dist/components/SelectionControl/SelectionControl.js
var import_jsx_runtime204 = __toESM(require_jsx_runtime(), 1);
var React201 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/SelectionControl/SelectionControlContext.js
var import_react25 = __toESM(require_react(), 1);
var SelectionControlContext = (0, import_react25.createContext)({
  noPadding: false
});
var useSelectionControlContext = () => (0, import_react25.useContext)(SelectionControlContext);

// node_modules/@vkontakte/vkui/dist/components/SelectionControl/SelectionControlLabel/SelectionControlLabel.js
var import_jsx_runtime203 = __toESM(require_jsx_runtime(), 1);
var sizeYClassNames30 = {
  none: "vkuiSelectionControlLabel__sizeYNone",
  compact: "vkuiSelectionControlLabel__sizeYCompact"
};
function SelectionControlLabel(_param) {
  var { children, titleAfter, description } = _param, restProps = _object_without_properties(_param, [
    "children",
    "titleAfter",
    "description"
  ]);
  const { noPadding } = useSelectionControlContext();
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime203.jsxs)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: clsx("vkuiSelectionControlLabel__host", sizeY !== "regular" && sizeYClassNames30[sizeY], !noPadding && "vkuiSelectionControlLabel__withPadding")
  }, restProps), {
    children: [
      (0, import_jsx_runtime203.jsxs)("div", {
        className: "vkuiSelectionControlLabel__titleLayout",
        children: [
          (0, import_jsx_runtime203.jsx)(Text, {
            className: "vkuiSelectionControlLabel__title",
            children
          }),
          (0, import_jsx_runtime203.jsx)("div", {
            className: "vkuiSelectionControlLabel__titleAfter",
            children: titleAfter
          })
        ]
      }),
      hasReactNode(description) && (0, import_jsx_runtime203.jsx)(Footnote, {
        className: "vkuiSelectionControlLabel__description",
        children: description
      })
    ]
  }));
}

// node_modules/@vkontakte/vkui/dist/components/SelectionControl/SelectionControl.js
var sizeYClassNames31 = {
  none: "vkuiSelectionControl__sizeYNone",
  compact: "vkuiSelectionControl__sizeYCompact"
};
var SelectionControl = (_param) => {
  var { noPadding = false, hoverMode: hoverModeProp, activeMode: activeModeProp } = _param, restProps = _object_without_properties(_param, [
    "noPadding",
    "hoverMode",
    "activeMode"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const platform3 = usePlatform();
  const hoverMode = hoverModeProp || (noPadding ? "opacity" : "background");
  const activeMode = activeModeProp || (noPadding ? "opacity" : "background");
  return (0, import_jsx_runtime204.jsx)(SelectionControlContext.Provider, {
    value: {
      noPadding
    },
    children: (0, import_jsx_runtime204.jsx)(Tappable, _object_spread({
      Component: "label",
      baseClassName: clsx("vkuiSelectionControl__host", sizeY !== "regular" && sizeYClassNames31[sizeY], !noPadding && "vkuiSelectionControl__withPadding"),
      activeEffectDelay: platform3 === "ios" ? 100 : DEFAULT_ACTIVE_EFFECT_DELAY,
      hoverMode,
      activeMode
    }, restProps))
  });
};
SelectionControl.Label = SelectionControlLabel;

// node_modules/@vkontakte/vkui/dist/components/Radio/Radio.js
var import_jsx_runtime206 = __toESM(require_jsx_runtime(), 1);
var React203 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/Radio/RadioInput/RadioInput.js
var import_jsx_runtime205 = __toESM(require_jsx_runtime(), 1);
var React202 = __toESM(require_react(), 1);
var warn30 = warnOnce("Radio.Input");
function RadioIcon24(props) {
  return (0, import_jsx_runtime205.jsxs)("svg", _object_spread_props(_object_spread({
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    "aria-hidden": true
  }, props), {
    children: [
      (0, import_jsx_runtime205.jsx)("circle", {
        cx: "12",
        cy: "12",
        r: "10",
        stroke: "currentColor",
        strokeWidth: "2",
        fill: "none"
      }),
      (0, import_jsx_runtime205.jsx)("circle", {
        cx: "12",
        cy: "12",
        r: "7",
        className: "vkuiRadioInput__pin",
        fill: "currentColor"
      })
    ]
  }));
}
function RadioIcon20(props) {
  return (0, import_jsx_runtime205.jsxs)("svg", _object_spread_props(_object_spread({
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    "aria-hidden": true
  }, props), {
    children: [
      (0, import_jsx_runtime205.jsx)("circle", {
        cx: "10",
        cy: "10",
        r: "7.75",
        stroke: "currentColor",
        strokeWidth: "1.5",
        fill: "none"
      }),
      (0, import_jsx_runtime205.jsx)("circle", {
        cx: "10",
        cy: "10",
        r: "5.5",
        className: "vkuiRadioInput__pin",
        fill: "currentColor"
      })
    ]
  }));
}
function RadioIcon() {
  return (0, import_jsx_runtime205.jsx)("div", {
    className: "vkuiRadioInput__icon",
    children: (0, import_jsx_runtime205.jsx)(AdaptiveIconRenderer, {
      IconCompact: RadioIcon20,
      IconRegular: RadioIcon24
    })
  });
}
function RadioInput(_param) {
  var { className, style, getRootRef, getRef, slotProps } = _param, restProps = _object_without_properties(_param, [
    "className",
    "style",
    "getRootRef",
    "getRef",
    "slotProps"
  ]);
  if (getRef) {
    warn30("Свойство `getRef` устаревшее, используйте `slotProps={ input: { getRootRef: ... } }`");
  }
  const rootRest = useMergeProps({
    className,
    style,
    getRootRef
  }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.root);
  const inputProps = useMergeProps(_object_spread({
    getRootRef: getRef
  }, restProps), slotProps === null || slotProps === void 0 ? void 0 : slotProps.input);
  return (0, import_jsx_runtime205.jsxs)(RootComponent, _object_spread_props(_object_spread({}, rootRest), {
    children: [
      (0, import_jsx_runtime205.jsx)(VisuallyHidden, _object_spread({
        Component: "input",
        type: "radio",
        baseClassName: "vkuiRadioInput__input"
      }, inputProps)),
      (0, import_jsx_runtime205.jsx)(RadioIcon, {})
    ]
  }));
}

// node_modules/@vkontakte/vkui/dist/components/Radio/Radio.js
var warn31 = warnOnce("Radio");
var Radio2 = (_param) => {
  var { children, description, style, className, getRootRef, titleAfter, getRef, labelProps, hoverMode, activeMode, hasHover: hasHover2, hasActive, focusVisibleMode, slotProps } = _param, restProps = _object_without_properties(_param, [
    "children",
    "description",
    "style",
    "className",
    "getRootRef",
    "titleAfter",
    "getRef",
    "labelProps",
    "hoverMode",
    "activeMode",
    "hasHover",
    "hasActive",
    "focusVisibleMode",
    "slotProps"
  ]);
  if (true) {
    if (labelProps) {
      warn31("Свойство `labelProps` устаревшее, используйте `slotProps={ root: {...} }`");
    }
    if (getRef) {
      warn31("Свойство `getRef` устаревшее, используйте `slotProps={ input: { getRootRef: ... } }`");
    }
  }
  const rootProps = useMergeProps(_object_spread({
    style,
    className: clsx("vkuiRadio__host", className),
    getRootRef
  }, labelProps), slotProps === null || slotProps === void 0 ? void 0 : slotProps.root);
  const inputRest = useMergeProps(_object_spread({
    getRootRef: getRef
  }, restProps), slotProps === null || slotProps === void 0 ? void 0 : slotProps.input);
  return (0, import_jsx_runtime206.jsxs)(SelectionControl, _object_spread_props(_object_spread({
    hoverMode,
    activeMode,
    hasHover: hasHover2,
    hasActive,
    focusVisibleMode,
    disabled: inputRest.disabled
  }, rootProps), {
    children: [
      (0, import_jsx_runtime206.jsx)(RadioInput, {
        slotProps: {
          input: inputRest
        }
      }),
      (0, import_jsx_runtime206.jsx)(SelectionControlLabel, {
        titleAfter,
        description,
        children
      })
    ]
  }));
};
Radio2.Input = RadioInput;

// node_modules/@vkontakte/vkui/dist/components/RadioGroup/RadioGroup.js
var import_jsx_runtime207 = __toESM(require_jsx_runtime(), 1);
var React204 = __toESM(require_react(), 1);
var RadioGroup = (_param) => {
  var { mode = "vertical" } = _param, restProps = _object_without_properties(_param, [
    "mode"
  ]);
  return (0, import_jsx_runtime207.jsx)(RootComponent, _object_spread({
    baseClassName: clsx("vkuiRadioGroup__host", "vkuiInternalRadioGroup", mode === "horizontal" && "vkuiRadioGroup__modeHorizontal"),
    role: "radiogroup"
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Checkbox/Checkbox.js
var import_jsx_runtime210 = __toESM(require_jsx_runtime(), 1);
var React206 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/Checkbox/CheckboxInput/CheckboxInput.js
var import_jsx_runtime208 = __toESM(require_jsx_runtime(), 1);
var React205 = __toESM(require_react(), 1);
function setIndeterminate(el, indeterminate) {
  el.indeterminate = indeterminate;
}
var warn32 = warnOnce("Checkbox");
function CheckboxInput(_param) {
  var { className, style, getRootRef, getRef, indeterminate, defaultIndeterminate, IconOnCompact = Icon20CheckBoxOn, IconOnRegular = Icon24CheckBoxOn, IconOffCompact = Icon20CheckBoxOff, IconOffRegular = Icon24CheckBoxOff, IconIndeterminate = Icon20CheckBoxIndetermanate, slotProps } = _param, restProps = _object_without_properties(_param, [
    "className",
    "style",
    "getRootRef",
    "getRef",
    "indeterminate",
    "defaultIndeterminate",
    "IconOnCompact",
    "IconOnRegular",
    "IconOffCompact",
    "IconOffRegular",
    "IconIndeterminate",
    "slotProps"
  ]);
  const rootRest = useMergeProps({
    className,
    style,
    getRootRef
  }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.root);
  const _useMergeProps = useMergeProps(_object_spread({
    getRootRef: getRef
  }, restProps), slotProps === null || slotProps === void 0 ? void 0 : slotProps.input), { onChange, getRootRef: getInputRef } = _useMergeProps, inputRest = _object_without_properties(_useMergeProps, [
    "onChange",
    "getRootRef"
  ]);
  const inputRef = useExternRef(getInputRef);
  const platform3 = usePlatform();
  const { sizeY: adaptiveSizeY } = useAdaptivityConditionalRender();
  React205.useEffect(() => {
    const indeterminateValue = indeterminate === void 0 ? defaultIndeterminate : indeterminate;
    if (inputRef.current) {
      setIndeterminate(inputRef.current, Boolean(indeterminateValue));
    }
  }, [
    defaultIndeterminate,
    indeterminate,
    inputRef
  ]);
  const handleChange = React205.useCallback((event) => {
    if (defaultIndeterminate !== void 0 && indeterminate === void 0 && inputRest.checked === void 0 && inputRef.current) {
      setIndeterminate(inputRef.current, false);
    }
    if (indeterminate !== void 0 && inputRef.current) {
      setIndeterminate(inputRef.current, Boolean(indeterminate));
    }
    onChange && onChange(event);
  }, [
    defaultIndeterminate,
    indeterminate,
    inputRest.checked,
    onChange,
    inputRef
  ]);
  if (true) {
    if (getRef) {
      warn32("Свойство `getRef` устаревшее, используйте `slotProps={ input: { getRootRef: ... } }`");
    }
    if (defaultIndeterminate && inputRest.defaultChecked) {
      warn32("defaultIndeterminate и defaultChecked не могут быть true одновременно", "error");
    }
    if (indeterminate && inputRest.checked) {
      warn32("indeterminate и checked не могут быть true одновременно", "error");
    }
    if (inputRest.defaultChecked && inputRest.checked) {
      warn32("defaultChecked и checked не могут быть true одновременно", "error");
    }
  }
  return (0, import_jsx_runtime208.jsxs)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: "vkuiCheckboxInput__host"
  }, rootRest), {
    children: [
      (0, import_jsx_runtime208.jsx)(VisuallyHidden, _object_spread({
        Component: "input",
        type: "checkbox",
        onChange: handleChange,
        getRootRef: inputRef,
        baseClassName: "vkuiCheckboxInput__input"
      }, inputRest)),
      platform3 === "vkcom" ? (0, import_jsx_runtime208.jsx)(IconOnCompact, {
        className: "vkuiCheckboxInput__iconOn"
      }) : (0, import_jsx_runtime208.jsxs)(React205.Fragment, {
        children: [
          adaptiveSizeY.compact && (0, import_jsx_runtime208.jsx)(IconOnCompact, {
            className: clsx("vkuiCheckboxInput__iconOn", adaptiveSizeY.compact.className)
          }),
          adaptiveSizeY.regular && (0, import_jsx_runtime208.jsx)(IconOnRegular, {
            className: clsx("vkuiCheckboxInput__iconOn", adaptiveSizeY.regular.className)
          })
        ]
      }),
      platform3 === "vkcom" ? (0, import_jsx_runtime208.jsx)(IconOffCompact, {
        className: "vkuiCheckboxInput__iconOff"
      }) : (0, import_jsx_runtime208.jsxs)(React205.Fragment, {
        children: [
          adaptiveSizeY.compact && (0, import_jsx_runtime208.jsx)(IconOffCompact, {
            className: clsx("vkuiCheckboxInput__iconOff", adaptiveSizeY.compact.className)
          }),
          adaptiveSizeY.regular && (0, import_jsx_runtime208.jsx)(IconOffRegular, {
            className: clsx("vkuiCheckboxInput__iconOff", adaptiveSizeY.regular.className)
          })
        ]
      }),
      platform3 === "vkcom" ? (0, import_jsx_runtime208.jsx)(IconIndeterminate, {
        width: 20,
        height: 20,
        className: "vkuiCheckboxInput__iconIndeterminate"
      }) : (0, import_jsx_runtime208.jsxs)(React205.Fragment, {
        children: [
          adaptiveSizeY.compact && (0, import_jsx_runtime208.jsx)(IconIndeterminate, {
            className: clsx("vkuiCheckboxInput__iconIndeterminate", adaptiveSizeY.compact.className),
            width: 20,
            height: 20
          }),
          adaptiveSizeY.regular && (0, import_jsx_runtime208.jsx)(IconIndeterminate, {
            className: clsx("vkuiCheckboxInput__iconIndeterminate", adaptiveSizeY.regular.className),
            width: 24,
            height: 24
          })
        ]
      })
    ]
  }));
}

// node_modules/@vkontakte/vkui/dist/components/Checkbox/CheckboxSimple/CheckboxSimple.js
var import_jsx_runtime209 = __toESM(require_jsx_runtime(), 1);
var sizeYClassNames32 = {
  none: "vkuiCheckboxSimple__sizeYNone",
  compact: "vkuiCheckboxSimple__sizeYCompact"
};
function CheckboxSimple(_param) {
  var { children, className, style, getRootRef, getRef, description, hoverMode: hoverModeProp, activeMode: activeModeProp, hasHover: hasHover2, hasActive, focusVisibleMode, titleAfter, noPadding, indeterminate, defaultIndeterminate, IconOnCompact, IconOnRegular, IconOffCompact, IconOffRegular, IconIndeterminate, slotProps } = _param, restProps = _object_without_properties(_param, [
    "children",
    "className",
    "style",
    "getRootRef",
    "getRef",
    "description",
    "hoverMode",
    "activeMode",
    "hasHover",
    "hasActive",
    "focusVisibleMode",
    "titleAfter",
    "noPadding",
    "indeterminate",
    "defaultIndeterminate",
    "IconOnCompact",
    "IconOnRegular",
    "IconOffCompact",
    "IconOffRegular",
    "IconIndeterminate",
    "slotProps"
  ]);
  const rootRest = useMergeProps({
    className,
    style,
    getRootRef
  }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.root);
  const inputRest = useMergeProps(_object_spread({
    getRootRef: getRef
  }, restProps), slotProps === null || slotProps === void 0 ? void 0 : slotProps.input);
  const { sizeY = "none" } = useAdaptivity();
  const hoverMode = hoverModeProp || (noPadding ? "opacity" : "background");
  const activeMode = activeModeProp || (noPadding ? "opacity" : "background");
  return (0, import_jsx_runtime209.jsx)(Tappable, _object_spread_props(_object_spread({
    baseClassName: clsx("vkuiCheckboxSimple__host", !noPadding && "vkuiCheckboxSimple__withPadding", sizeY !== "regular" && sizeYClassNames32[sizeY]),
    disabled: inputRest.disabled,
    hoverMode,
    activeMode,
    hasHover: hasHover2,
    hasActive,
    focusVisibleMode,
    Component: "label"
  }, rootRest), {
    children: (0, import_jsx_runtime209.jsx)(CheckboxInput, {
      indeterminate,
      defaultIndeterminate,
      IconIndeterminate,
      IconOnCompact,
      IconOnRegular,
      IconOffCompact,
      IconOffRegular,
      slotProps: {
        input: inputRest
      }
    })
  }));
}

// node_modules/@vkontakte/vkui/dist/components/Checkbox/Checkbox.js
var warn33 = warnOnce("Checkbox");
var CheckboxComponent = (_param) => {
  var { children, className, style, getRootRef, getRef, description, hoverMode, activeMode, hasHover: hasHover2, hasActive, focusVisibleMode, titleAfter, noPadding, indeterminate, defaultIndeterminate, IconOnCompact, IconOnRegular, IconOffCompact, IconOffRegular, IconIndeterminate, slotProps } = _param, restProps = _object_without_properties(_param, [
    "children",
    "className",
    "style",
    "getRootRef",
    "getRef",
    "description",
    "hoverMode",
    "activeMode",
    "hasHover",
    "hasActive",
    "focusVisibleMode",
    "titleAfter",
    "noPadding",
    "indeterminate",
    "defaultIndeterminate",
    "IconOnCompact",
    "IconOnRegular",
    "IconOffCompact",
    "IconOffRegular",
    "IconIndeterminate",
    "slotProps"
  ]);
  const rootRest = useMergeProps({
    className,
    style,
    getRootRef
  }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.root);
  const inputRest = useMergeProps(_object_spread({
    getRootRef: getRef
  }, restProps), slotProps === null || slotProps === void 0 ? void 0 : slotProps.input);
  return (0, import_jsx_runtime210.jsxs)(SelectionControl, _object_spread_props(_object_spread({
    disabled: inputRest.disabled,
    hoverMode,
    activeMode,
    hasHover: hasHover2,
    hasActive,
    focusVisibleMode,
    noPadding
  }, rootRest), {
    children: [
      (0, import_jsx_runtime210.jsx)(CheckboxInput, {
        indeterminate,
        defaultIndeterminate,
        IconIndeterminate,
        IconOnCompact,
        IconOnRegular,
        IconOffCompact,
        IconOffRegular,
        slotProps: {
          input: inputRest
        }
      }),
      (0, import_jsx_runtime210.jsx)(SelectionControlLabel, {
        titleAfter,
        description,
        children
      })
    ]
  }));
};
var Checkbox = (props) => {
  if (props.getRef) {
    warn33("Свойство `getRef` устаревшее, используйте `slotProps={ input: { getRootRef: ... } }`");
  }
  const simple = !(hasReactNode(props.children) || hasReactNode(props.description));
  if (simple) {
    return (0, import_jsx_runtime210.jsx)(CheckboxSimple, _object_spread({}, props));
  }
  return (0, import_jsx_runtime210.jsx)(CheckboxComponent, _object_spread({}, props));
};
Checkbox.Input = CheckboxInput;

// node_modules/@vkontakte/vkui/dist/components/Select/Select.js
var import_jsx_runtime217 = __toESM(require_jsx_runtime(), 1);
var React218 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/CustomSelect.js
var import_jsx_runtime216 = __toESM(require_jsx_runtime(), 1);
var React217 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/NativeSelect/NativeSelect.js
var import_jsx_runtime212 = __toESM(require_jsx_runtime(), 1);
var React207 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/SelectTypography/SelectTypography.js
var import_jsx_runtime211 = __toESM(require_jsx_runtime(), 1);
var SelectTypography = (_param) => {
  var { selectType = "default", children } = _param, restProps = _object_without_properties(_param, [
    "selectType",
    "children"
  ]);
  return (0, import_jsx_runtime211.jsx)(Text, _object_spread_props(_object_spread({
    weight: selectType === "accent" ? "2" : "3"
  }, restProps), {
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/NativeSelect/NativeSelect.js
var warn34 = warnOnce("NativeSelect");
var sizeYClassNames33 = {
  none: "vkuiSelect__sizeYNone",
  compact: "vkuiSelect__sizeYCompact"
};
var NOT_SELECTED = {
  NATIVE: "__vkui_internal_Select_not_selected__",
  CUSTOM: null
};
var remapFromSelectValueToNativeValue = (value) => value === NOT_SELECTED.CUSTOM ? NOT_SELECTED.NATIVE : value;
var remapFromNativeValueToSelectValue = (value) => value === NOT_SELECTED.NATIVE ? NOT_SELECTED.CUSTOM : value;
var NativeSelect = (_param) => {
  var { style: rootStyle, className: rootClassName, getRootRef: rootGetRootRef, align, placeholder, children, getRef, multiline, selectType = "default", status, icon = (0, import_jsx_runtime212.jsx)(DropdownIcon, {}), before, onChange, value, defaultValue, slotProps } = _param, restProps = _object_without_properties(_param, [
    "style",
    "className",
    "getRootRef",
    "align",
    "placeholder",
    "children",
    "getRef",
    "multiline",
    "selectType",
    "status",
    "icon",
    "before",
    "onChange",
    "value",
    "defaultValue",
    "slotProps"
  ]);
  if (getRef) {
    warn34("Свойство `getRef` устаревшее, используйте `slotProps={ select: { getRootRef: ... } }`");
  }
  const [title, setTitle] = React207.useState("");
  const [empty, setEmpty] = React207.useState(false);
  const { sizeY = "none" } = useAdaptivity();
  const _useMergeProps = useMergeProps({
    style: rootStyle,
    className: rootClassName,
    getRootRef: rootGetRootRef
  }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.root), { className, style, getRootRef } = _useMergeProps, rootRest = _object_without_properties(_useMergeProps, [
    "className",
    "style",
    "getRootRef"
  ]);
  const _useMergeProps1 = useMergeProps(_object_spread({
    getRootRef: getRef
  }, restProps), slotProps === null || slotProps === void 0 ? void 0 : slotProps.select), { getRootRef: getSelectRef } = _useMergeProps1, selectRest = _object_without_properties(_useMergeProps1, [
    "getRootRef"
  ]);
  const selectRef = useExternRef(getSelectRef);
  const checkSelectedOption = () => {
    var _selectRef_current;
    const selectedOption = (_selectRef_current = selectRef.current) === null || _selectRef_current === void 0 ? void 0 : _selectRef_current.options[selectRef.current.selectedIndex];
    if (selectedOption) {
      setTitle(selectedOption.text);
      setEmpty(selectedOption.value === NOT_SELECTED.NATIVE && placeholder != null);
    }
  };
  const _onChange = (e) => {
    const newValue = remapFromNativeValueToSelectValue(e.target.value);
    if (e.target.value === NOT_SELECTED.NATIVE) {
      e.target.value = "";
    }
    if (e.currentTarget.value === NOT_SELECTED.NATIVE) {
      e.currentTarget.value = "";
    }
    onChange === null || onChange === void 0 ? void 0 : onChange(e, newValue);
  };
  useIsomorphicLayoutEffect(checkSelectedOption, [
    children
  ]);
  return (0, import_jsx_runtime212.jsxs)(FormField, _object_spread_props(_object_spread({
    Component: "div",
    className: clsx("vkuiSelect__host", "vkuiInternalNativeSelect", before && "vkuiSelect__hasBefore", empty && "vkuiSelect__empty", multiline && "vkuiSelect__multiline", align === "center" && "vkuiSelect__alignCenter", align === "right" && "vkuiSelect__alignRight", sizeY !== "regular" && sizeYClassNames33[sizeY], className),
    style,
    getRootRef,
    disabled: selectRest.disabled,
    before,
    after: icon,
    status,
    mode: getFormFieldModeFromSelectType(selectType)
  }, rootRest), {
    children: [
      (0, import_jsx_runtime212.jsxs)(RootComponent, _object_spread_props(_object_spread({
        Component: "select",
        baseClassName: "vkuiSelect__el",
        value: value !== void 0 ? remapFromSelectValueToNativeValue(value) : value,
        defaultValue: defaultValue !== void 0 ? remapFromSelectValueToNativeValue(defaultValue) : defaultValue,
        onChange: callMultiple(_onChange, checkSelectedOption),
        getRootRef: selectRef
      }, selectRest), {
        children: [
          placeholder && (0, import_jsx_runtime212.jsx)("option", {
            value: NOT_SELECTED.NATIVE,
            children: placeholder
          }),
          children
        ]
      })),
      (0, import_jsx_runtime212.jsx)("div", {
        className: "vkuiSelect__container",
        "aria-hidden": true,
        children: (0, import_jsx_runtime212.jsx)(SelectTypography, {
          className: "vkuiSelect__title",
          selectType,
          children: title
        })
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/CustomSelectInput/CustomSelectInput.js
var import_jsx_runtime213 = __toESM(require_jsx_runtime(), 1);
var React208 = __toESM(require_react(), 1);
var sizeYClassNames34 = {
  none: "vkuiCustomSelectInput__sizeYNone",
  compact: "vkuiCustomSelectInput__sizeYCompact"
};
var CustomSelectInput = (_param) => {
  var { style: rootStyle, className: rootClassName, getRootRef: rootGetRootRef, align = "left", getRef, before, after, status, children, placeholder, selectType = "default", multiline, fetching, labelTextTestId, searchable, accessible, slotProps } = _param, restProps = _object_without_properties(_param, [
    "style",
    "className",
    "getRootRef",
    "align",
    "getRef",
    "before",
    "after",
    "status",
    "children",
    "placeholder",
    "selectType",
    "multiline",
    "fetching",
    "labelTextTestId",
    "searchable",
    "accessible",
    "slotProps"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const _useMergeProps = useMergeProps({
    style: rootStyle,
    className: rootClassName,
    getRootRef: rootGetRootRef
  }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.root), { style, className, getRootRef } = _useMergeProps, rootRest = _object_without_properties(_useMergeProps, [
    "style",
    "className",
    "getRootRef"
  ]);
  const _useMergeProps1 = useMergeProps(_object_spread({
    getRootRef: getRef
  }, restProps), slotProps === null || slotProps === void 0 ? void 0 : slotProps.input), { className: inputClassName, value, readOnly, disabled } = _useMergeProps1, inputProps = _object_without_properties(_useMergeProps1, [
    "className",
    "value",
    "readOnly",
    "disabled"
  ]);
  const title = children || placeholder;
  const showLabelOrPlaceholder = !Boolean(value);
  const handleRootRef = useExternRef(getRootRef);
  const focusWithin = useFocusWithin(handleRootRef);
  const inputReadonly = readOnly || disabled && fetching;
  const input = (0, import_jsx_runtime213.jsx)(Text, _object_spread({
    type: "text",
    disabled: disabled && !fetching,
    readOnly: inputReadonly,
    Component: "input",
    normalize: false,
    placeholder: children ? "" : placeholder,
    className: clsx("vkuiCustomSelectInput__el", (readOnly || showLabelOrPlaceholder && !focusWithin) && "vkuiCustomSelectInput__elCursorPointer", inputClassName),
    value
  }, inputProps));
  const inputHidden = React208.useMemo(() => {
    if (accessible) {
      if (!searchable) {
        return true;
      }
      return !focusWithin || inputReadonly && !fetching;
    } else {
      return false;
    }
  }, [
    accessible,
    fetching,
    focusWithin,
    inputReadonly,
    searchable
  ]);
  const labelHidden = showLabelOrPlaceholder ? false : !inputHidden;
  const platform3 = usePlatform();
  return (0, import_jsx_runtime213.jsx)(FormField, _object_spread_props(_object_spread({
    Component: "div",
    style,
    className: clsx("vkuiCustomSelectInput__host", align === "right" && "vkuiCustomSelectInput__alignRight", align === "center" && "vkuiCustomSelectInput__alignCenter", !children && "vkuiCustomSelectInput__empty", multiline && "vkuiCustomSelectInput__multiline", sizeY !== "regular" && sizeYClassNames34[sizeY], before && "vkuiCustomSelectInput__hasBefore", after && "vkuiCustomSelectInput__hasAfter", inputHidden && "vkuiCustomSelectInput__inputHidden", labelHidden && "vkuiCustomSelectInput__labelHidden", accessible && "vkuiCustomSelectInput__accessible", value && "vkuiCustomSelectInput__hasInputValue", className),
    getRootRef: handleRootRef,
    before,
    after,
    disabled,
    mode: getFormFieldModeFromSelectType(selectType),
    status
  }, rootRest), {
    children: (0, import_jsx_runtime213.jsxs)("div", {
      className: "vkuiCustomSelectInput__inputGroup",
      children: [
        (0, import_jsx_runtime213.jsx)("div", {
          className: clsx("vkuiCustomSelectInput__container", className),
          tabIndex: -1,
          "aria-hidden": true,
          "data-testid": labelTextTestId,
          children: (0, import_jsx_runtime213.jsx)(SelectTypography, {
            selectType,
            className: "vkuiCustomSelectInput__title",
            children: title
          })
        }),
        readOnly && platform3 === "ios" ? (0, import_jsx_runtime213.jsx)(VisuallyHidden, {
          children: input
        }) : input
      ]
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/helpers.js
var findIndexAfter2 = (options = [], startIndex = -1) => {
  if (startIndex >= options.length - 1) {
    return -1;
  }
  return options.findIndex((option, i) => i > startIndex && !option.disabled);
};
var findIndexBefore2 = (options = [], endIndex = options.length) => {
  let result = -1;
  if (endIndex <= 0) {
    return result;
  }
  for (let i = endIndex - 1; i >= 0; i--) {
    let option = options[i];
    if (!option.disabled) {
      result = i;
      break;
    }
  }
  return result;
};
var warn35 = warnOnce("CustomSelect");
var checkDeprecatedProps = ({ getRef, getSelectInputRef, nativeSelectTestId }) => {
  if (getRef) {
    warn35("Свойство `getRef` устаревшее, используйте `slotProps={ select: { getRootRef: ... } }`");
  }
  if (getSelectInputRef) {
    warn35("Свойство `getSelectInputRef` устаревшее, используйте `slotProps={ input: { getRootRef: ... } }`");
  }
  if (nativeSelectTestId) {
    warn35("Свойство `nativeSelectTestId` устаревшее, используйте `slotProps={ select: { 'data-testid': ... } }`");
  }
};
var checkOptionsValueType = (options) => {
  if (new Set(options.map((item) => typeof item.value)).size > 1) {
    warn35("Некоторые значения ваших опций имеют разные типы. onChange всегда возвращает строковый тип.", "error");
  }
};
var checkMixControlledAndUncontrolledState = (oldIsControlled, newIsControlled) => {
  if (!oldIsControlled && newIsControlled) {
    warn35(`Похоже, что компонент был переведен из состояния Uncontrolled в Controlled. Пожалуйста, не делайте так. Если вам нужно отобразить невыбранное состояние компонента, используйте value=null вместо undefined`, "error");
  }
  if (oldIsControlled && !newIsControlled) {
    warn35(`Похоже, что компонент был переведен из состояния Controlled в Uncontrolled. Пожалуйста, не делайте так. Если вам нужно отобразить невыбранное состояние компонента, используйте value=null вместо undefined`, "error");
  }
};
function findSelectedIndex(options = [], value) {
  if (value === NOT_SELECTED.CUSTOM) {
    return -1;
  }
  var _options_findIndex;
  return (_options_findIndex = options.findIndex((item) => {
    value = typeof item.value === "number" ? Number(value) : value;
    return item.value === value;
  })) !== null && _options_findIndex !== void 0 ? _options_findIndex : -1;
}
function getOptionByValue(options = [], value) {
  const index2 = findSelectedIndex(options, value);
  if (index2 === -1) {
    return null;
  }
  return options[index2];
}
var filter = (options, inputValue, filterFn) => {
  return typeof filterFn === "function" ? options.filter((option) => filterFn(inputValue, option)) : options;
};
function calculateInputValueFromOptions(options = [], selectValue) {
  const selectedOption = getOptionByValue(options, selectValue);
  return selectedOption ? getTextFromChildren(selectedOption.label) : "";
}

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/hooks/useAfterItems.js
var import_jsx_runtime215 = __toESM(require_jsx_runtime(), 1);
var React210 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/CustomSelectClearButton.js
var import_jsx_runtime214 = __toESM(require_jsx_runtime(), 1);
var React209 = __toESM(require_react(), 1);
var CustomSelectClearButton = (_param) => {
  var { className, onClick } = _param, restProps = _object_without_properties(_param, [
    "className",
    "onClick"
  ]);
  return (0, import_jsx_runtime214.jsx)(IconButton, _object_spread_props(_object_spread({
    Component: "button",
    label: "Очистить поле",
    onKeyDown: stopPropagation,
    type: "button",
    activeMode: "opacity",
    hoverMode: "opacity"
  }, restProps), {
    className,
    onClick: (e) => {
      stopPropagation(e);
      e.preventDefault();
      onClick();
    },
    children: (0, import_jsx_runtime214.jsx)(Icon16Cancel, {})
  }));
};

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/hooks/useAfterItems.js
function useAfterItems({ value, nativeSelectValue, isControlledOutside, opened, allowClearButton, ClearButton = CustomSelectClearButton, onClearButtonClick, clearButtonTestId, disabled, readOnly, icon: iconProp }) {
  const onClearButtonClickCb = useStableCallback(onClearButtonClick);
  const controlledValueSet = isControlledOutside && value !== NOT_SELECTED.CUSTOM;
  const uncontrolledValueSet = !isControlledOutside && nativeSelectValue !== NOT_SELECTED.NATIVE;
  const clearButtonShown = allowClearButton && !opened && (controlledValueSet || uncontrolledValueSet);
  const clearButton = React210.useMemo(() => {
    if (!clearButtonShown) {
      return null;
    }
    return (0, import_jsx_runtime215.jsx)(ClearButton, {
      className: iconProp === void 0 ? "vkuiCustomSelect__clearIcon" : void 0,
      onClick: onClearButtonClickCb,
      disabled,
      "data-testid": clearButtonTestId
    });
  }, [
    clearButtonShown,
    ClearButton,
    iconProp,
    onClearButtonClickCb,
    disabled,
    clearButtonTestId
  ]);
  const icon = React210.useMemo(() => {
    if (iconProp !== void 0) {
      return iconProp;
    }
    return (0, import_jsx_runtime215.jsx)(DropdownIcon, {
      className: clearButtonShown ? "vkuiCustomSelect__dropdownIcon" : void 0,
      opened
    });
  }, [
    clearButtonShown,
    iconProp,
    opened
  ]);
  return React210.useMemo(() => !readOnly && (icon || clearButtonShown) && (0, import_jsx_runtime215.jsxs)(React210.Fragment, {
    children: [
      clearButton,
      icon
    ]
  }), [
    clearButton,
    clearButtonShown,
    icon,
    readOnly
  ]);
}

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/hooks/useDropdownOpenedController.js
var React211 = __toESM(require_react(), 1);
function useDropdownOpenedController({ onClose, onOpen, onOpened, onClosed }) {
  const [opened, setOpened] = React211.useState(false);
  const onCloseCb = useStableCallback(onClose || noop);
  const onOpenCb = useStableCallback(onOpen || noop);
  const onOpenedCb = useStableCallback(onOpened || noop);
  const onClosedCb = useStableCallback(onClosed || noop);
  const close = React211.useCallback(() => {
    if (!opened) {
      return;
    }
    setOpened(false);
    onCloseCb === null || onCloseCb === void 0 ? void 0 : onCloseCb();
  }, [
    onCloseCb,
    opened
  ]);
  const open = React211.useCallback(() => {
    if (opened) {
      return;
    }
    setOpened(true);
    onOpenCb === null || onOpenCb === void 0 ? void 0 : onOpenCb();
  }, [
    onOpenCb,
    opened
  ]);
  const toggleOpened = React211.useCallback(() => {
    if (opened) {
      close();
    } else {
      open();
    }
  }, [
    close,
    open,
    opened
  ]);
  React211.useEffect(() => {
    if (opened) {
      onOpenedCb();
    } else {
      onClosedCb();
    }
  }, [
    onClosedCb,
    onOpenedCb,
    opened
  ]);
  return {
    opened,
    open,
    close,
    toggleOpened
  };
}

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/hooks/useFocusedOptionController.js
var React212 = __toESM(require_react(), 1);
function useFocusedOptionController({ selectedOptionValue, filteredOptions, scrollToElement }) {
  const [focusedOptionValue, setFocusedOptionValue] = React212.useState(null);
  const focusOptionByIndex = React212.useCallback((index2, scrollTo = true) => {
    if (index2 === void 0 || index2 < 0 || index2 > filteredOptions.length - 1) {
      return;
    }
    const option = filteredOptions[index2];
    if (!option || option.disabled) {
      return;
    }
    if (scrollTo) {
      scrollToElement(index2);
    }
    setFocusedOptionValue(option.value);
  }, [
    filteredOptions,
    scrollToElement
  ]);
  const resetFocusedOption = React212.useCallback(() => {
    setFocusedOptionValue(null);
  }, []);
  const focusOption = React212.useCallback((type) => {
    let index2 = findSelectedIndex(filteredOptions, focusedOptionValue);
    if (type === "next") {
      const nextIndex = findIndexAfter2(filteredOptions, index2);
      index2 = nextIndex === -1 ? findIndexAfter2(filteredOptions) : nextIndex;
    } else if (type === "prev") {
      const beforeIndex = findIndexBefore2(filteredOptions, index2);
      index2 = beforeIndex === -1 ? findIndexBefore2(filteredOptions) : beforeIndex;
    }
    focusOptionByIndex(index2);
  }, [
    filteredOptions,
    focusedOptionValue,
    focusOptionByIndex
  ]);
  const selectFocusedValue = React212.useCallback(() => setFocusedOptionValue(selectedOptionValue), [
    selectedOptionValue
  ]);
  return {
    focusedOptionValue,
    setFocusedOptionValue,
    focusOptionByIndex,
    resetFocusedOption,
    focusOption,
    selectFocusedValue
  };
}

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/hooks/useInputKeyboardController.js
var React213 = __toESM(require_react(), 1);
var KEYS_TO_PREVENT_DEFAULT = [
  Keys.ARROW_UP,
  Keys.ARROW_DOWN,
  Keys.ESCAPE,
  Keys.ENTER
];
function useInputKeyboardController({ opened, resetFocusedOption, focusOption, scrollBoxRef, selectFocused, onInputKeyDown, open, close }) {
  const handleKeyDownSelect = React213.useCallback((event) => {
    const key = pressedKey(event);
    if (event.key.length === 1 && key !== Keys.SPACE) {
      open();
      resetFocusedOption();
      return;
    }
    if (!key) {
      return;
    }
    const areOptionsShown = () => scrollBoxRef.current !== null;
    if (KEYS_TO_PREVENT_DEFAULT.includes(key)) {
      event.preventDefault();
    }
    switch (key) {
      case Keys.ARROW_UP:
        if (opened) {
          areOptionsShown() && focusOption("prev");
        } else {
          open();
        }
        break;
      case Keys.ARROW_DOWN:
        if (opened) {
          areOptionsShown() && focusOption("next");
        } else {
          open();
        }
        break;
      case Keys.ESCAPE:
        close();
        break;
      case Keys.BACKSPACE:
      case Keys.DELETE: {
        open();
        resetFocusedOption();
        break;
      }
      case Keys.ENTER:
      case Keys.SPACE:
        if (opened) {
          areOptionsShown() && selectFocused();
        } else {
          open();
        }
        break;
    }
  }, [
    scrollBoxRef,
    opened,
    close,
    focusOption,
    open,
    resetFocusedOption,
    selectFocused
  ]);
  const handleInputKeydown = React213.useCallback((event) => {
    onInputKeyDown === null || onInputKeyDown === void 0 ? void 0 : onInputKeyDown(event, opened);
  }, [
    opened,
    onInputKeyDown
  ]);
  const _onInputKeyDown = callMultiple(handleKeyDownSelect, handleInputKeydown);
  return _onInputKeyDown;
}

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/hooks/useInputValueController.js
var React214 = __toESM(require_react(), 1);
function useInputValueController({ options, accessible, selectedValue, onInputChange: onInputChangeProp }) {
  const [inputValue, setInputValue] = React214.useState("");
  const optionsRef = React214.useRef(options);
  useIsomorphicLayoutEffect(() => {
    optionsRef.current = options;
  }, [
    options
  ]);
  const resetInputValueBySelectedOption = React214.useCallback(() => {
    setInputValue(calculateInputValueFromOptions(optionsRef.current, selectedValue));
  }, [
    selectedValue
  ]);
  useIsomorphicLayoutEffect(() => {
    if (accessible) {
      resetInputValueBySelectedOption();
    }
  }, [
    accessible,
    resetInputValueBySelectedOption
  ]);
  const resetInputValue = React214.useCallback(() => {
    setInputValue("");
  }, []);
  const onInputChange = React214.useCallback((e) => {
    onInputChangeProp && onInputChangeProp(e);
    setInputValue(e.target.value);
  }, [
    onInputChangeProp,
    setInputValue
  ]);
  return {
    inputValue,
    resetInputValue,
    resetInputValueBySelectedOption,
    onInputChange
  };
}

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/hooks/useScrollListController.js
var React215 = __toESM(require_react(), 1);
function useScrollListController() {
  const scrollBoxRef = React215.useRef(null);
  const optionsWrapperRef = React215.useRef(null);
  const scrollToElement = React215.useCallback((index2, center = false) => {
    const dropdown = scrollBoxRef.current;
    const optionsWrapper = optionsWrapperRef.current;
    if (!dropdown || !optionsWrapper || index2 < 0 || index2 > optionsWrapper.children.length) {
      return;
    }
    const item = optionsWrapper.children[index2];
    if (!item) {
      return;
    }
    const dropdownHeight = dropdown.offsetHeight;
    const scrollTop = dropdown.scrollTop;
    const itemTop = item.offsetTop;
    const itemHeight = item.offsetHeight;
    if (center) {
      dropdown.scrollTop = itemTop - dropdownHeight / 2 + itemHeight / 2;
    } else if (itemTop + itemHeight > dropdownHeight + scrollTop) {
      dropdown.scrollTop = itemTop - dropdownHeight + itemHeight;
    } else if (itemTop < scrollTop) {
      dropdown.scrollTop = itemTop;
    }
  }, [
    optionsWrapperRef,
    scrollBoxRef
  ]);
  return {
    scrollToElement,
    scrollBoxRef,
    optionsWrapperRef
  };
}

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/hooks/useSelectedOptionController.js
var React216 = __toESM(require_react(), 1);
function useSelectedOptionController({ value, defaultValue, isControlledOutside, allowClearButton, onChange }) {
  const [[nativeSelectValue, prevNativeSelectValue], setNativeSelectValue] = useStateWithPrev(() => {
    if (value !== void 0) {
      return remapFromSelectValueToNativeValue(value);
    }
    if (defaultValue !== void 0) {
      return remapFromSelectValueToNativeValue(defaultValue);
    }
    return NOT_SELECTED.NATIVE;
  });
  const nativeSelectValueRef = React216.useRef(nativeSelectValue);
  const [selectedOptionValue, setSelectedOptionValue] = React216.useState(() => remapFromNativeValueToSelectValue(nativeSelectValue));
  const _setNativeSelectValue = React216.useCallback((newValue) => {
    setNativeSelectValue(newValue);
    nativeSelectValueRef.current = newValue;
  }, [
    setNativeSelectValue
  ]);
  React216.useEffect(function syncNativeSelectValueWithPropValue() {
    if (value !== void 0) {
      _setNativeSelectValue(remapFromSelectValueToNativeValue(value));
    }
  }, [
    value,
    _setNativeSelectValue
  ]);
  React216.useEffect(function syncNativeSelectValueWithSelectedOptionValue() {
    const remappedSelectedValue = remapFromSelectValueToNativeValue(selectedOptionValue);
    if (nativeSelectValueRef.current !== remappedSelectedValue) {
      setNativeSelectValue(remappedSelectedValue);
    }
  }, [
    selectedOptionValue,
    setNativeSelectValue
  ]);
  const onNativeSelectChange = (e) => {
    const convertedNativeSelectValue = typeof nativeSelectValue === "number" && (typeof value === "string" || typeof prevNativeSelectValue === "string") ? String(nativeSelectValue) : nativeSelectValue;
    const isCalledWithSameControlledOptionValue = isControlledOutside && value === remapFromNativeValueToSelectValue(convertedNativeSelectValue);
    const isNativeValueChanged = convertedNativeSelectValue !== prevNativeSelectValue && prevNativeSelectValue !== void 0;
    const isTriggeredByClearButton = allowClearButton && // Проверяем, что новое значение NOT_SELECTED.NATIVE
    nativeSelectValue === NOT_SELECTED.NATIVE && // Проверяем, что предыдущее значение не undefined(кейс с первой отрисовкой, когда предыдущего значения не было)
    prevNativeSelectValue !== void 0 && // Проверяем, что предыдущее значение не NOT_SELECTED.NATIVE(если до этого было уже сброшенное значение)
    prevNativeSelectValue !== NOT_SELECTED.NATIVE;
    const shouldCallOnChange = !isCalledWithSameControlledOptionValue && (isNativeValueChanged || isTriggeredByClearButton);
    if (!shouldCallOnChange) {
      return;
    }
    const remappedNativeValue = remapFromNativeValueToSelectValue(e.currentTarget.value);
    if (e.target.value === NOT_SELECTED.NATIVE) {
      e.target.value = "";
    }
    if (e.currentTarget.value === NOT_SELECTED.NATIVE) {
      e.currentTarget.value = "";
    }
    onChange === null || onChange === void 0 ? void 0 : onChange(e, remappedNativeValue);
  };
  return {
    selectedOptionValue,
    setSelectedOptionValue,
    nativeSelectValue,
    setNativeSelectValue: _setNativeSelectValue,
    onNativeSelectChange
  };
}

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/CustomSelect.js
var sizeYClassNames35 = {
  none: "vkuiCustomSelect__sizeYNone",
  compact: "vkuiCustomSelect__sizeYCompact"
};
function defaultRenderOptionFn(_param) {
  var { option } = _param, props = _object_without_properties(_param, [
    "option"
  ]);
  return (0, import_jsx_runtime216.jsx)(CustomSelectOption, _object_spread({}, props));
}
function isMousePositionChanged(event, prevPosition) {
  return Math.abs(prevPosition.x - event.clientX) >= 1 || Math.abs(prevPosition.y - event.clientY) >= 1;
}
var FETCH_STATUS_RESET_DELAY = 2e3;
var FetchingStatus = ({ fetching = false, options, fetchingInProgressLabel = "Список опций загружается...", fetchingCompletedLabel = `Загружено опций: ${options.length}` }) => {
  const [status, setStatus] = React217.useState("none");
  const content = getRequiredValueByKey(status, {
    fetching: fetchingInProgressLabel,
    loaded: typeof fetchingCompletedLabel === "function" ? fetchingCompletedLabel(options.length) : fetchingCompletedLabel,
    none: ""
  });
  useIsomorphicLayoutEffect(function updateStatus() {
    if (fetching) {
      setStatus("fetching");
    } else {
      if (status === "fetching") {
        setStatus("loaded");
        setTimeout(() => setStatus("none"), FETCH_STATUS_RESET_DELAY);
      }
    }
  }, [
    fetching
  ]);
  return (0, import_jsx_runtime216.jsx)(VisuallyHidden, {
    "aria-live": "polite",
    children: content
  });
};
function CustomSelect(props) {
  const { style, className, getRootRef, before, name, getRef, popupDirection = "bottom", onChange, children, "onInputChange": onInputChangeProp, renderDropdown, onOpen, onClose, fetching, labelTextTestId, multiline, placeholder, status, forceDropdownPortal, align, selectType = "default", searchable = false, "renderOption": renderOptionProp = defaultRenderOptionFn, "options": options, emptyText = "Ничего не найдено", filterFn = defaultFilterFn, "icon": iconProp, ClearButton, allowClearButton = false, dropdownOffsetDistance = 0, dropdownAutoWidth = false, noMaxHeight = false, "aria-labelledby": ariaLabelledBy, clearButtonTestId, nativeSelectTestId, defaultValue, required, getSelectInputRef, overscrollBehavior, "onInputKeyDown": onInputKeyDownProp, accessible = false, fetchingInProgressLabel, fetchingCompletedLabel, "value": selectValue, "onBlur": onSelectBlur, "onFocus": onSelectFocus, "onClick": onSelectClick, slotProps } = props, restProps = _object_without_properties(props, [
    "style",
    "className",
    "getRootRef",
    "before",
    "name",
    "getRef",
    "popupDirection",
    "onChange",
    "children",
    "onInputChange",
    "renderDropdown",
    "onOpen",
    "onClose",
    "fetching",
    "labelTextTestId",
    "multiline",
    "placeholder",
    "status",
    "forceDropdownPortal",
    "align",
    "selectType",
    "searchable",
    "renderOption",
    "options",
    "emptyText",
    "filterFn",
    "icon",
    "ClearButton",
    "allowClearButton",
    "dropdownOffsetDistance",
    "dropdownAutoWidth",
    "noMaxHeight",
    "aria-labelledby",
    "clearButtonTestId",
    "nativeSelectTestId",
    "defaultValue",
    "required",
    "getSelectInputRef",
    "overscrollBehavior",
    "onInputKeyDown",
    "accessible",
    "fetchingInProgressLabel",
    "fetchingCompletedLabel",
    "value",
    "onBlur",
    "onFocus",
    "onClick",
    "slotProps"
  ]);
  if (true) {
    checkOptionsValueType(options);
    checkDeprecatedProps(props);
  }
  const { sizeY = "none" } = useAdaptivity();
  const _useMergeProps = useMergeProps({
    style,
    className,
    getRootRef
  }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.root), { onClick: onRootClick, onMouseMove: onRootMouseMove, onMouseDown: onRootMouseDown, getRootRef: rootRef } = _useMergeProps, rootRest = _object_without_properties(_useMergeProps, [
    "onClick",
    "onMouseMove",
    "onMouseDown",
    "getRootRef"
  ]);
  const _useMergeProps1 = useMergeProps({
    getRootRef: getRef,
    onBlur: onSelectBlur,
    onFocus: onSelectFocus,
    onClick: onSelectClick
  }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.select), { getRootRef: getSelectRef } = _useMergeProps1, selectRest = _object_without_properties(_useMergeProps1, [
    "getRootRef"
  ]);
  const _useMergeProps2 = useMergeProps(_object_spread({
    getRootRef: getSelectInputRef,
    onChange: onInputChangeProp
  }, restProps), slotProps === null || slotProps === void 0 ? void 0 : slotProps.input), { getRootRef: getInputRef, onChange: onChangeInput, onFocus: onInputFocus, onBlur: onInputBlur, onKeyDown: onNativeInputKeyDown, onClick: onNativeInputClick, readOnly } = _useMergeProps2, inputRest = _object_without_properties(_useMergeProps2, [
    "getRootRef",
    "onChange",
    "onFocus",
    "onBlur",
    "onKeyDown",
    "onClick",
    "readOnly"
  ]);
  const containerRef = React217.useRef(null);
  const handleRootRef = useExternRef(containerRef, rootRef);
  const selectElRef = useExternRef(getSelectRef);
  const selectInputRef = useExternRef(getInputRef);
  const propsValue = React217.useMemo(() => {
    var _getOptionByValue;
    if (selectValue === void 0) {
      return void 0;
    }
    var _getOptionByValue_value;
    return (_getOptionByValue_value = (_getOptionByValue = getOptionByValue(options, selectValue)) === null || _getOptionByValue === void 0 ? void 0 : _getOptionByValue.value) !== null && _getOptionByValue_value !== void 0 ? _getOptionByValue_value : null;
  }, [
    options,
    selectValue
  ]);
  const [isControlledOutside, setIsControlledOutside] = React217.useState(selectValue !== void 0);
  const [popperPlacement, setPopperPlacement] = React217.useState(popupDirection);
  const { nativeSelectValue, setNativeSelectValue, selectedOptionValue, setSelectedOptionValue, onNativeSelectChange } = useSelectedOptionController({
    value: propsValue,
    defaultValue,
    isControlledOutside,
    allowClearButton,
    onChange
  });
  const selected = React217.useMemo(() => options.find((option) => option.value === selectedOptionValue), [
    options,
    selectedOptionValue
  ]);
  const { inputValue, onInputChange, resetInputValue, resetInputValueBySelectedOption } = useInputValueController({
    options,
    accessible,
    selectedValue: selectedOptionValue,
    onInputChange: onChangeInput
  });
  const filteredOptions = React217.useMemo(() => filter(options, searchable ? inputValue : "", filterFn), [
    filterFn,
    inputValue,
    options,
    searchable
  ]);
  const { scrollToElement, optionsWrapperRef, scrollBoxRef } = useScrollListController();
  const { focusedOptionValue, setFocusedOptionValue, resetFocusedOption, focusOptionByIndex, focusOption, selectFocusedValue } = useFocusedOptionController({
    selectedOptionValue,
    filteredOptions,
    scrollToElement
  });
  const scrollToSelectedOption = () => {
    scrollToElement(findSelectedIndex(filteredOptions, selectedOptionValue), true);
  };
  const { opened, open, close, toggleOpened } = useDropdownOpenedController({
    onOpen: callMultiple(selectFocusedValue, onOpen),
    onOpened: scrollToSelectedOption,
    onClose,
    onClosed: accessible ? resetInputValueBySelectedOption : resetInputValue
  });
  React217.useEffect(function updateOptionsValue() {
    const value = propsValue !== void 0 ? propsValue : remapFromNativeValueToSelectValue(nativeSelectValue);
    setSelectedOptionValue(value);
    setFocusedOptionValue(value);
  }, [
    propsValue,
    nativeSelectValue,
    setFocusedOptionValue,
    setSelectedOptionValue
  ]);
  React217.useEffect(function syncIsControlledState() {
    setIsControlledOutside((oldIsControlled) => {
      const newIsControlled = propsValue !== void 0;
      checkMixControlledAndUncontrolledState(oldIsControlled, newIsControlled);
      return newIsControlled;
    });
  }, [
    propsValue
  ]);
  useIsomorphicLayoutEffect(() => {
    if (filteredOptions.some(({ value }) => nativeSelectValue === value) || allowClearButton && nativeSelectValue === NOT_SELECTED.NATIVE) {
      var _selectElRef_current;
      const event = new Event("change", {
        bubbles: true
      });
      (_selectElRef_current = selectElRef.current) === null || _selectElRef_current === void 0 ? void 0 : _selectElRef_current.dispatchEvent(event);
    }
  }, [
    nativeSelectValue
  ]);
  const openedClassNames = React217.useMemo(() => opened && dropdownOffsetDistance === 0 && (popperPlacement.includes("top") ? "vkuiCustomSelect__popUp" : "vkuiCustomSelect__popDown") || void 0, [
    dropdownOffsetDistance,
    opened,
    popperPlacement
  ]);
  const selectOption = React217.useCallback((value) => {
    setNativeSelectValue(value !== null && value !== void 0 ? value : NOT_SELECTED.NATIVE);
    close();
    const shouldTriggerOnChangeWhenControlledAndInnerValueIsOutOfSync = isControlledOutside && propsValue !== nativeSelectValue && nativeSelectValue === value;
    if (shouldTriggerOnChangeWhenControlledAndInnerValueIsOutOfSync) {
      var _selectElRef_current;
      const event = new Event("change", {
        bubbles: true
      });
      (_selectElRef_current = selectElRef.current) === null || _selectElRef_current === void 0 ? void 0 : _selectElRef_current.dispatchEvent(event);
    }
  }, [
    close,
    setNativeSelectValue,
    isControlledOutside,
    propsValue,
    nativeSelectValue,
    selectElRef
  ]);
  const selectFocused = React217.useCallback(() => {
    if (focusedOptionValue === null) {
      return;
    }
    selectOption(focusedOptionValue);
  }, [
    focusedOptionValue,
    selectOption
  ]);
  const handleInputKeyDown = useInputKeyboardController({
    opened,
    open,
    close,
    resetFocusedOption,
    selectFocused,
    focusOption,
    scrollBoxRef,
    onInputKeyDown: onInputKeyDownProp
  });
  const onBlur = React217.useCallback(() => {
    var _selectElRef_current;
    close();
    const event = new Event("focusout", {
      bubbles: true
    });
    (_selectElRef_current = selectElRef.current) === null || _selectElRef_current === void 0 ? void 0 : _selectElRef_current.dispatchEvent(event);
  }, [
    close,
    selectElRef
  ]);
  const onFocus = React217.useCallback(() => {
    var _selectElRef_current;
    const event = new Event("focusin", {
      bubbles: true
    });
    (_selectElRef_current = selectElRef.current) === null || _selectElRef_current === void 0 ? void 0 : _selectElRef_current.dispatchEvent(event);
  }, [
    selectElRef
  ]);
  const handleOptionClick = React217.useCallback((e) => {
    var _e_currentTarget_parentNode;
    const index2 = Array.prototype.indexOf.call((_e_currentTarget_parentNode = e.currentTarget.parentNode) === null || _e_currentTarget_parentNode === void 0 ? void 0 : _e_currentTarget_parentNode.children, e.currentTarget);
    const option = filteredOptions[index2];
    if (option && !option.disabled) {
      selectOption(option.value);
    }
  }, [
    filteredOptions,
    selectOption
  ]);
  const lastMousePositionRef = React217.useRef({
    x: 0,
    y: 0
  });
  const focusOptionOnMouseMove = React217.useCallback((e, index2) => {
    if (isMousePositionChanged(e, lastMousePositionRef.current)) {
      focusOptionByIndex(index2, false);
    }
  }, [
    focusOptionByIndex
  ]);
  const popupAriaId = React217.useId();
  const renderOption = React217.useCallback((option, index2) => {
    const hovered = option.value === focusedOptionValue;
    const selected2 = option.value === selectedOptionValue;
    return (0, import_jsx_runtime216.jsx)(React217.Fragment, {
      children: renderOptionProp(_object_spread({
        option,
        hovered,
        children: option.label,
        selected: selected2,
        disabled: option.disabled,
        onClick: handleOptionClick,
        onMouseDown: preventDefault,
        // Используем `onMouseMove` вместо `onMouseEnter/onMouseOver`.
        // Потому что если при навигации с клавиатуры курсор наведён на
        // список, то при первом автоматическом скролле списка вызывается событие MouseOver/MouseEnter
        // обработчик которого фокусирует опцию под курсором, хотя при навигация с клавиатуры пользователь мог уйти дальше по списку, это путает.
        // Причём координаты события меняются на пару пикселей по сравнению с прошлым вызовом,
        // а значит нельзя на них опираться, чтобы запретить обработку такого события.
        // C mousemove такой проблемы нет, что позволяет реализовать поведение при наведении с клавиатуры и при наведении мышью идентично `<select>`.
        onMouseMove: (e) => focusOptionOnMouseMove(e, index2),
        id: `${popupAriaId}-${option.value}`
      }, option))
    }, `${typeof option.value}-${option.value}`);
  }, [
    focusedOptionValue,
    selectedOptionValue,
    renderOptionProp,
    handleOptionClick,
    popupAriaId,
    focusOptionOnMouseMove
  ]);
  const resolvedContent = React217.useMemo(() => {
    const defaultDropdownContent = filteredOptions.length > 0 ? (0, import_jsx_runtime216.jsx)("div", {
      ref: optionsWrapperRef,
      children: filteredOptions.map(renderOption)
    }) : (0, import_jsx_runtime216.jsx)(Footnote, {
      className: "vkuiCustomSelect__empty",
      children: emptyText
    });
    if (typeof renderDropdown === "function") {
      return renderDropdown({
        defaultDropdownContent
      });
    } else {
      return defaultDropdownContent;
    }
  }, [
    emptyText,
    filteredOptions,
    optionsWrapperRef,
    renderDropdown,
    renderOption
  ]);
  const afterItems = useAfterItems({
    value: propsValue,
    nativeSelectValue,
    isControlledOutside,
    opened,
    allowClearButton,
    ClearButton,
    onClearButtonClick: () => {
      setNativeSelectValue(NOT_SELECTED.NATIVE);
      resetInputValue();
      selectInputRef.current && selectInputRef.current.focus();
    },
    clearButtonTestId,
    disabled: restProps.disabled,
    readOnly,
    icon: iconProp
  });
  const { document: document2 } = useDOM();
  const passClickAndFocusToInputOnClick = React217.useCallback((e) => {
    if (!selectInputRef.current || !document2) {
      return;
    }
    const clickTargetIsNotAnInput = e.target !== selectInputRef.current;
    if (clickTargetIsNotAnInput) {
      selectInputRef.current.click();
      const inputIsNotFocused = document2.activeElement !== selectInputRef.current;
      if (inputIsNotFocused) {
        selectInputRef.current.focus();
      }
    }
  }, [
    document2,
    selectInputRef
  ]);
  const preventInputBlurWhenClickInsideFocusedSelectArea = (e) => {
    const isInputFocused = document2 && document2.activeElement === selectInputRef.current;
    if (isInputFocused) {
      e.preventDefault();
    }
  };
  const ariaActiveDescendantId = focusedOptionValue !== null ? focusedOptionValue : void 0;
  const selectInputAriaProps = {
    "role": "combobox",
    "aria-controls": popupAriaId,
    "aria-expanded": opened,
    "aria-activedescendant": ariaActiveDescendantId && opened ? `${popupAriaId}-${ariaActiveDescendantId}` : void 0,
    "aria-labelledby": ariaLabelledBy,
    "aria-haspopup": "listbox",
    "aria-autocomplete": "none"
  };
  const resetOptionFocusOnMouseLeave = React217.useCallback((event) => {
    if (isMousePositionChanged(event, lastMousePositionRef.current)) {
      resetFocusedOption();
    }
  }, [
    resetFocusedOption
  ]);
  const updateLastMousePosition = (e) => {
    lastMousePositionRef.current = {
      x: e.clientX,
      y: e.clientY
    };
  };
  return (0, import_jsx_runtime216.jsxs)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: clsx("vkuiCustomSelect__host", sizeY !== "regular" && sizeYClassNames35[sizeY]),
    getRootRef: handleRootRef,
    onClick: callMultiple(onRootClick, passClickAndFocusToInputOnClick),
    onMouseDown: callMultiple(onRootMouseDown, preventInputBlurWhenClickInsideFocusedSelectArea),
    onMouseMove: callMultiple(onRootMouseMove, updateLastMousePosition)
  }, rootRest), {
    children: [
      (0, import_jsx_runtime216.jsx)(CustomSelectInput, {
        autoComplete: "off",
        autoCapitalize: "none",
        autoCorrect: "off",
        spellCheck: "false",
        fetching,
        searchable,
        accessible,
        before,
        after: afterItems,
        selectType,
        align,
        status,
        placeholder,
        multiline,
        labelTextTestId,
        slotProps: {
          root: {
            className: openedClassNames
          },
          input: _object_spread({
            getRootRef: selectInputRef,
            onChange: onInputChange,
            onFocus: callMultiple(onFocus, onInputFocus),
            onBlur: callMultiple(onBlur, onInputBlur),
            onKeyDown: !readOnly ? callMultiple(handleInputKeyDown, onNativeInputKeyDown) : onNativeInputKeyDown,
            onClick: !readOnly ? callMultiple(toggleOpened, onNativeInputClick) : onNativeInputClick,
            value: inputValue,
            readOnly: readOnly || !searchable
          }, selectInputAriaProps, inputRest)
        },
        children: selected === null || selected === void 0 ? void 0 : selected.label
      }),
      (0, import_jsx_runtime216.jsx)(FetchingStatus, {
        fetching,
        options: filteredOptions,
        fetchingInProgressLabel,
        fetchingCompletedLabel
      }),
      (0, import_jsx_runtime216.jsxs)(RootComponent, _object_spread_props(_object_spread({
        Component: "select",
        baseClassName: "vkuiCustomSelect__control",
        tabIndex: -1,
        name,
        value: nativeSelectValue,
        "aria-hidden": true,
        "data-testid": nativeSelectTestId,
        required,
        onChange: onNativeSelectChange,
        getRootRef: selectElRef
      }, selectRest), {
        children: [
          (allowClearButton || nativeSelectValue === NOT_SELECTED.NATIVE) && (0, import_jsx_runtime216.jsx)("option", {
            value: NOT_SELECTED.NATIVE
          }, NOT_SELECTED.NATIVE),
          options.map((item) => (0, import_jsx_runtime216.jsx)("option", {
            value: item.value
          }, `${item.value}`))
        ]
      })),
      opened && (0, import_jsx_runtime216.jsx)(CustomSelectDropdown, {
        targetRef: containerRef,
        placement: popperPlacement,
        scrollBoxRef,
        onPlacementChange: setPopperPlacement,
        onMouseLeave: resetOptionFocusOnMouseLeave,
        fetching,
        overscrollBehavior,
        offsetDistance: dropdownOffsetDistance,
        autoWidth: dropdownAutoWidth,
        forcePortal: forceDropdownPortal,
        noMaxHeight,
        role: "listbox",
        id: popupAriaId,
        "aria-labelledby": ariaLabelledBy,
        tabIndex: -1,
        children: resolvedContent
      })
    ]
  }));
}

// node_modules/@vkontakte/vkui/dist/components/Select/Select.js
var Select = (_param) => {
  var { children, className } = _param, props = _object_without_properties(_param, [
    "children",
    "className"
  ]);
  const { options = [], searchable, emptyText, onInputChange, filterFn, popupDirection, renderOption, renderDropdown, fetching, onClose, onOpen, icon, ClearButton, allowClearButton, clearButtonTestId, dropdownOffsetDistance, dropdownAutoWidth, forceDropdownPortal, noMaxHeight, labelTextTestId, nativeSelectTestId, after, mode, pattern, minLength, maxLength, readOnly, getSelectInputRef, overscrollBehavior, beforeAlign, afterAlign, onInputKeyDown, accessible, fetchingCompletedLabel, fetchingInProgressLabel, slotProps } = props, restProps = _object_without_properties(props, [
    "options",
    "searchable",
    "emptyText",
    "onInputChange",
    "filterFn",
    "popupDirection",
    "renderOption",
    "renderDropdown",
    "fetching",
    "onClose",
    "onOpen",
    "icon",
    "ClearButton",
    "allowClearButton",
    "clearButtonTestId",
    "dropdownOffsetDistance",
    "dropdownAutoWidth",
    "forceDropdownPortal",
    "noMaxHeight",
    "labelTextTestId",
    "nativeSelectTestId",
    "after",
    "mode",
    "pattern",
    "minLength",
    "maxLength",
    "readOnly",
    "getSelectInputRef",
    "overscrollBehavior",
    "beforeAlign",
    "afterAlign",
    "onInputKeyDown",
    "accessible",
    "fetchingCompletedLabel",
    "fetchingInProgressLabel",
    "slotProps"
  ]);
  const { deviceType } = useAdaptivityConditionalRender();
  const nativeProps = restProps;
  return (0, import_jsx_runtime217.jsxs)(React218.Fragment, {
    children: [
      deviceType.desktop && (0, import_jsx_runtime217.jsx)(CustomSelect, _object_spread({
        className: clsx(className, deviceType.desktop.className),
        slotProps
      }, props)),
      deviceType.mobile && (0, import_jsx_runtime217.jsx)(NativeSelect, _object_spread_props(_object_spread({
        className: clsx(className, deviceType.mobile.className),
        slotProps: {
          select: _object_spread({}, slotProps === null || slotProps === void 0 ? void 0 : slotProps.input, slotProps === null || slotProps === void 0 ? void 0 : slotProps.select),
          root: slotProps === null || slotProps === void 0 ? void 0 : slotProps.root
        }
      }, nativeProps), {
        children: options.map(({ label, value, disabled }) => (0, import_jsx_runtime217.jsx)("option", {
          value,
          disabled,
          children: label
        }, `${value}`))
      }))
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/SelectMimicry/SelectMimicry.js
var import_jsx_runtime218 = __toESM(require_jsx_runtime(), 1);
var React219 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useAutoFocus.js
function useAutoFocus(ref, autoFocus) {
  useIsomorphicLayoutEffect(() => {
    if (!autoFocus || !ref.current) {
      return;
    }
    ref.current.focus();
  }, []);
}

// node_modules/@vkontakte/vkui/dist/components/SelectMimicry/SelectMimicry.js
var sizeYClassNames36 = {
  none: "vkuiSelect__sizeYNone",
  compact: "vkuiSelect__sizeYCompact"
};
var SelectMimicry = (_param) => {
  var { tabIndex = 0, placeholder, children, align, getRootRef, multiline, disabled, onClick, before, after = (0, import_jsx_runtime218.jsx)(DropdownIcon, {}), selectType = "default", status, className, autoFocus } = _param, restProps = _object_without_properties(_param, [
    "tabIndex",
    "placeholder",
    "children",
    "align",
    "getRootRef",
    "multiline",
    "disabled",
    "onClick",
    "before",
    "after",
    "selectType",
    "status",
    "className",
    "autoFocus"
  ]);
  const rootRef = useExternRef(getRootRef);
  const { sizeY = "none" } = useAdaptivity();
  const title = children || placeholder;
  useAutoFocus(rootRef, autoFocus);
  return (0, import_jsx_runtime218.jsx)(FormField, _object_spread_props(_object_spread({}, restProps), {
    tabIndex: disabled ? void 0 : tabIndex,
    className: clsx("vkuiSelect__host", sizeY !== "regular" && sizeYClassNames36[sizeY], !children && "vkuiSelect__empty", multiline && "vkuiSelect__multiline", align === "center" && "vkuiSelect__alignCenter", align === "right" && "vkuiSelect__alignRight", before && "vkuiSelect__hasBefore", className),
    getRootRef: rootRef,
    onClick: disabled ? void 0 : onClick,
    disabled,
    before,
    after,
    mode: getFormFieldModeFromSelectType(selectType),
    status,
    children: (0, import_jsx_runtime218.jsx)("div", {
      className: "vkuiSelect__container",
      children: (0, import_jsx_runtime218.jsx)(SelectTypography, {
        selectType,
        className: "vkuiSelect__title",
        children: title
      })
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/SegmentedControl/SegmentedControl.js
var import_jsx_runtime220 = __toESM(require_jsx_runtime(), 1);
var React221 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/SegmentedControl/SegmentedControlOption/SegmentedControlOption.js
var import_jsx_runtime219 = __toESM(require_jsx_runtime(), 1);
var React220 = __toESM(require_react(), 1);
var SegmentedControlOption = ({ getRef, children, getRootRef, before, rootProps, inputProps }) => (0, import_jsx_runtime219.jsxs)(Clickable, _object_spread_props(_object_spread({
  Component: "label",
  baseClassName: "vkuiSegmentedControlOption__host",
  hoverClassName: "vkuiSegmentedControlOption__hover",
  activeClassName: "vkuiSegmentedControlOption__hover",
  getRootRef
}, rootProps), {
  children: [
    inputProps && (0, import_jsx_runtime219.jsx)(VisuallyHidden, _object_spread_props(_object_spread({}, inputProps), {
      Component: "input",
      getRootRef: getRef,
      type: "radio"
    })),
    hasReactNode(before) && (0, import_jsx_runtime219.jsx)("div", {
      className: "vkuiSegmentedControlOption__before",
      children: before
    }),
    (0, import_jsx_runtime219.jsx)(Headline, {
      level: "2",
      weight: "2",
      children
    })
  ]
}));

// node_modules/@vkontakte/vkui/dist/components/SegmentedControl/SegmentedControl.js
var _options_;
var sizeYClassNames37 = {
  none: "vkuiSegmentedControl__sizeYNone",
  regular: "vkuiSegmentedControl__sizeYRegular"
};
var warn36 = warnOnce("SegmentedControl");
var SegmentedControl = (_param) => {
  var { size: size5 = "l", name, options, defaultValue = (_options_ = options[0]) === null || _options_ === void 0 ? void 0 : _options_.value, children, onChange: onChangeProp, value: valueProp, role = "radiogroup" } = _param, restProps = _object_without_properties(_param, [
    "size",
    "name",
    "options",
    "defaultValue",
    "children",
    "onChange",
    "value",
    "role"
  ]);
  const id = React221.useId();
  const direction = useConfigDirection();
  const isRtl = direction === "rtl";
  const [value, onChange] = useCustomEnsuredControl({
    onChange: onChangeProp,
    value: valueProp,
    defaultValue
  });
  const { sizeY = "none" } = useAdaptivity();
  const { tabsRef } = useTabsNavigation(role === "tablist", isRtl);
  const actualIndex = options.findIndex((option) => option.value === value);
  useIsomorphicLayoutEffect(() => {
    if (actualIndex === -1 && true) {
      warn36("defaultValue: такого значения нет среди опций!", "error");
    }
  }, [
    actualIndex
  ]);
  const sliderStyle = {
    "--vkui_internal--SegmentedControl_actual_index": String(actualIndex),
    "--vkui_internal--SegmentedControl_options": String(options.length)
  };
  return (0, import_jsx_runtime220.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiSegmentedControl__host", sizeY !== "compact" && sizeYClassNames37[sizeY], size5 === "l" && "vkuiSegmentedControl__sizeL", isRtl && "vkuiSegmentedControl__rtl"),
    children: (0, import_jsx_runtime220.jsxs)("div", {
      role,
      ref: tabsRef,
      className: "vkuiSegmentedControl__in",
      children: [
        actualIndex > -1 && (0, import_jsx_runtime220.jsx)("div", {
          "aria-hidden": true,
          className: "vkuiSegmentedControl__slider",
          style: sliderStyle
        }),
        options.map((_param2) => {
          var { label, before } = _param2, optionProps = _object_without_properties(_param2, [
            "label",
            "before"
          ]);
          const selected = value === optionProps.value;
          const onSelect = () => onChange(optionProps.value);
          var _optionProps_tabIndex;
          const optionRootProps = role === "tablist" ? _object_spread({
            "role": "tab",
            "aria-selected": selected,
            "onClick": onSelect,
            "tabIndex": (_optionProps_tabIndex = optionProps.tabIndex) !== null && _optionProps_tabIndex !== void 0 ? _optionProps_tabIndex : selected ? 0 : -1
          }, optionProps) : void 0;
          const optionInputProps = role !== "tablist" ? _object_spread({
            role: optionProps.role || (role === "radiogroup" ? "radio" : void 0),
            checked: selected,
            onChange: onSelect,
            name: name !== null && name !== void 0 ? name : id
          }, optionProps) : void 0;
          return (0, import_jsx_runtime220.jsx)(SegmentedControlOption, {
            before,
            rootProps: optionRootProps,
            inputProps: optionInputProps,
            children: label
          }, `${optionProps.value}`);
        })
      ]
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Calendar/Calendar.js
var import_jsx_runtime226 = __toESM(require_jsx_runtime(), 1);
var React229 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useCalendar.js
var React222 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/lib/calendar.js
var DEFAULT_MAX_YEAR = 9999;
var DEFAULT_MIN_YEAR = 100;
var getYears = (currentYear, range2) => {
  const years = [];
  const minYear = clamp2(currentYear - range2, DEFAULT_MIN_YEAR, DEFAULT_MAX_YEAR);
  const maxYear = clamp2(currentYear + range2, DEFAULT_MIN_YEAR, DEFAULT_MAX_YEAR);
  for (let i = minYear; i <= maxYear; i++) {
    years.push({
      label: String(i).padStart(4, "0"),
      value: i
    });
  }
  return years;
};
var getMonths = (locale) => {
  const months = [];
  const formatter = new Intl.DateTimeFormat(locale, {
    month: "long"
  });
  for (let i = 0; i < 12; i++) {
    months.push({
      label: formatter.format(new Date(2023, i, 15)),
      value: i
    });
  }
  return months;
};
var getDaysNames = (now2, weekStartsOn, locale) => {
  const shortFormatter = new Intl.DateTimeFormat(locale, {
    weekday: "short"
  });
  const longFormatter = new Intl.DateTimeFormat(locale, {
    weekday: "long"
  });
  return eachDayOfInterval(startOfWeek(now2, {
    weekStartsOn
  }), endOfWeek(now2, {
    weekStartsOn
  })).map((day) => ({
    short: shortFormatter.format(day),
    long: longFormatter.format(day)
  }));
};
var NAVIGATION_KEYS = [
  Keys.ARROW_UP,
  Keys.ARROW_DOWN,
  Keys.ARROW_LEFT,
  Keys.ARROW_RIGHT,
  Keys.HOME,
  Keys.END,
  Keys.PAGE_UP,
  Keys.PAGE_DOWN
];
var navigateDate = (date, key) => {
  let newDate = date !== null && date !== void 0 ? date : /* @__PURE__ */ new Date();
  switch (key) {
    case Keys.ARROW_RIGHT:
      newDate = addDays2(newDate, 1);
      break;
    case Keys.ARROW_LEFT:
      newDate = subDays(newDate, 1);
      break;
    case Keys.ARROW_UP:
      newDate = subWeeks(newDate, 1);
      break;
    case Keys.ARROW_DOWN:
      newDate = addWeeks(newDate, 1);
      break;
    case Keys.HOME:
      newDate = startOfWeek(newDate, {
        weekStartsOn: MONDAY
      });
      break;
    case Keys.END:
      newDate = endOfWeek(newDate, {
        weekStartsOn: MONDAY
      });
      break;
    case Keys.PAGE_UP:
      newDate = subMonths(newDate, 1);
      break;
    case Keys.PAGE_DOWN:
      newDate = addMonths(newDate, 1);
      break;
  }
  return newDate;
};
var getWeeks = (viewDate, weekStartsOn) => {
  const start = startOfWeek(startOfMonth(viewDate), {
    weekStartsOn
  });
  const end = endOfWeek(endOfMonth(viewDate), {
    weekStartsOn
  });
  let count = 0;
  let current = start;
  const nestedWeeks = [];
  let lastDay = null;
  while (current < end) {
    const weekNumber = Math.floor(count / 7);
    nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
    const day = current.getDay();
    if (lastDay !== day) {
      lastDay = day;
      nestedWeeks[weekNumber].push(current);
      count += 1;
    }
    current = addDays2(current, 1);
  }
  return nestedWeeks;
};
var setTimeEqual = (to, from) => {
  if (from) {
    to.setHours(from.getHours());
    to.setMinutes(from.getMinutes());
    to.setSeconds(from.getSeconds());
    to.setMilliseconds(from.getMilliseconds());
  }
  return to;
};
var isFirstDay = (day, dayOfWeek) => dayOfWeek === 0 || day.getDate() === 1;
var isLastDay = (day, dayOfWeek) => dayOfWeek === 6 || isLastDayOfMonth(day);
function clamp3(day, options = {}) {
  const { min: min2, max: max2 } = options;
  if (min2 && day < min2) {
    return min2;
  }
  if (max2 && day > max2) {
    return max2;
  }
  return day;
}
function isDayMinMaxRestricted(day, options = {}) {
  const { min: min2, max: max2, withTime = false } = options;
  if (!withTime && (min2 && isSameDate(day, min2) || max2 && isSameDate(day, max2))) {
    return false;
  }
  return Boolean(min2 && day < min2 || max2 && day > max2);
}

// node_modules/@vkontakte/vkui/dist/hooks/useCalendar.js
function useCalendar({ value, disablePast, disableFuture, shouldDisableDate, onHeaderChange, onNextMonth, onPrevMonth, minDateTime, maxDateTime }) {
  var _ref;
  const [viewDate, setViewDate] = React222.useState((_ref = Array.isArray(value) ? value[0] : value) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ new Date());
  const [focusedDay, setFocusedDay] = React222.useState();
  const setPrevMonth = React222.useCallback(() => {
    onPrevMonth === null || onPrevMonth === void 0 ? void 0 : onPrevMonth();
    setViewDate(subMonths(viewDate, 1));
  }, [
    viewDate,
    onPrevMonth
  ]);
  const setNextMonth = React222.useCallback(() => {
    onNextMonth === null || onNextMonth === void 0 ? void 0 : onNextMonth();
    setViewDate(addMonths(viewDate, 1));
  }, [
    viewDate,
    onNextMonth
  ]);
  const handleSetViewDate = React222.useCallback((value2) => {
    onHeaderChange === null || onHeaderChange === void 0 ? void 0 : onHeaderChange(value2);
    setViewDate(value2);
  }, [
    onHeaderChange
  ]);
  const isDayFocused = React222.useCallback((day) => Boolean(focusedDay && isSameDate(day, focusedDay)), [
    focusedDay
  ]);
  const isDayDisabled = React222.useCallback((day, withTime) => {
    const now2 = /* @__PURE__ */ new Date();
    if (shouldDisableDate) {
      return shouldDisableDate(day);
    }
    if (disableFuture) {
      return startOfDay(day) > now2;
    }
    if (disablePast) {
      return endOfDay(day) < now2;
    }
    if (minDateTime || maxDateTime) {
      return isDayMinMaxRestricted(day, {
        min: minDateTime,
        max: maxDateTime,
        withTime
      });
    }
    return false;
  }, [
    disableFuture,
    disablePast,
    shouldDisableDate,
    minDateTime,
    maxDateTime
  ]);
  const isMonthDisabled = React222.useCallback((month, year) => {
    const now2 = /* @__PURE__ */ new Date();
    year = year || viewDate.getFullYear();
    const minMonth = minDateTime ? minDateTime.getMonth() : 0;
    const maxMonth = maxDateTime ? maxDateTime.getMonth() : 11;
    const minYear = (minDateTime === null || minDateTime === void 0 ? void 0 : minDateTime.getFullYear()) || DEFAULT_MIN_YEAR;
    const maxYear = (maxDateTime === null || maxDateTime === void 0 ? void 0 : maxDateTime.getFullYear()) || DEFAULT_MAX_YEAR;
    let isDisabled = year >= minYear && year <= maxYear ? year === minYear && minMonth > month || year === maxYear && month > maxMonth : true;
    if (disableFuture) {
      isDisabled = isDisabled || (year === now2.getFullYear() ? month > now2.getMonth() : year > now2.getFullYear());
    }
    if (disablePast) {
      isDisabled = isDisabled || (year === now2.getFullYear() ? month < now2.getMonth() : year < now2.getFullYear());
    }
    return isDisabled;
  }, [
    disableFuture,
    disablePast,
    viewDate,
    minDateTime,
    maxDateTime
  ]);
  const isYearDisabled = React222.useCallback((year) => {
    const now2 = /* @__PURE__ */ new Date();
    const minYear = (minDateTime === null || minDateTime === void 0 ? void 0 : minDateTime.getFullYear()) || DEFAULT_MIN_YEAR;
    const maxYear = (maxDateTime === null || maxDateTime === void 0 ? void 0 : maxDateTime.getFullYear()) || DEFAULT_MAX_YEAR;
    let isDisabled = minYear > year || year > maxYear;
    if (disableFuture) {
      isDisabled = isDisabled || year > now2.getFullYear();
    }
    if (disablePast) {
      isDisabled = isDisabled || year < now2.getFullYear();
    }
    return isDisabled;
  }, [
    disableFuture,
    disablePast,
    minDateTime,
    maxDateTime
  ]);
  return {
    viewDate,
    setViewDate: handleSetViewDate,
    setPrevMonth,
    setNextMonth,
    focusedDay,
    setFocusedDay,
    isDayFocused,
    isDayDisabled,
    isMonthDisabled,
    isYearDisabled
  };
}

// node_modules/@vkontakte/vkui/dist/components/CalendarDays/CalendarDays.js
var import_jsx_runtime222 = __toESM(require_jsx_runtime(), 1);
var React225 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useTodayDate.js
var React223 = __toESM(require_react(), 1);
function useTodayDate(listenDayChangesForUpdate = false) {
  const { document: document2, window: window2 } = useDOM();
  const [todayDate, setTodayDate] = React223.useState(() => /* @__PURE__ */ new Date());
  React223.useEffect(function setupTodaysDateRecalculationListener() {
    if (!listenDayChangesForUpdate || !document2 || !window2) {
      return;
    }
    let timeout = void 0;
    const recalcTimeout = () => {
      if (document2.visibilityState === "visible") {
        const now2 = /* @__PURE__ */ new Date();
        const timeToDayChange = Number(startOfTomorrow()) - Number(now2);
        window2.clearTimeout(timeout);
        timeout = window2.setTimeout(() => {
          setTodayDate(/* @__PURE__ */ new Date());
        }, timeToDayChange);
        if (!isSameDate(todayDate, now2)) {
          setTodayDate(now2);
        }
      }
    };
    recalcTimeout();
    document2.addEventListener("visibilitychange", recalcTimeout);
    return () => {
      window2.clearTimeout(timeout);
      document2.removeEventListener("visibilitychange", recalcTimeout);
    };
  }, [
    document2,
    listenDayChangesForUpdate,
    todayDate,
    window2
  ]);
  return todayDate;
}

// node_modules/@vkontakte/vkui/dist/components/CalendarDay/CalendarDay.js
var import_jsx_runtime221 = __toESM(require_jsx_runtime(), 1);
var React224 = __toESM(require_react(), 1);
var CalendarDay = React224.memo((_param) => {
  var { day, today, selected, onChange, hidden, disabled, active, selectionStart, selectionEnd, focused, onEnter, onLeave, onFocus, onBlur, hinted, hintedSelectionStart, hintedSelectionEnd, sameMonth, size: size5, children, renderDayContent, testId, role, "aria-colindex": colIndex } = _param, restProps = _object_without_properties(_param, [
    "day",
    "today",
    "selected",
    "onChange",
    "hidden",
    "disabled",
    "active",
    "selectionStart",
    "selectionEnd",
    "focused",
    "onEnter",
    "onLeave",
    "onFocus",
    "onBlur",
    "hinted",
    "hintedSelectionStart",
    "hintedSelectionEnd",
    "sameMonth",
    "size",
    "children",
    "renderDayContent",
    "testId",
    "role",
    "aria-colindex"
  ]);
  const { locale, direction } = useConfigProvider();
  const ref = React224.useRef(null);
  const onClick = React224.useCallback(() => onChange(day), [
    day,
    onChange
  ]);
  const handleEnter = React224.useCallback(() => onEnter === null || onEnter === void 0 ? void 0 : onEnter(day), [
    day,
    onEnter
  ]);
  const handleLeave = React224.useCallback(() => onLeave === null || onLeave === void 0 ? void 0 : onLeave(day), [
    day,
    onLeave
  ]);
  const handleFocus = React224.useCallback(() => onFocus === null || onFocus === void 0 ? void 0 : onFocus(day), [
    day,
    onFocus
  ]);
  const focusVisibleMode = active ? "outside" : "inside";
  const _useFocusVisible = useFocusVisible(), { focusVisible } = _useFocusVisible, focusEvents = _object_without_properties(_useFocusVisible, [
    "focusVisible"
  ]);
  const focusVisibleClassNames = useFocusVisibleClassName({
    focusVisible,
    mode: focusVisibleMode
  });
  const focusHandlers = mergeCalls(focusEvents, {
    onFocus: handleFocus,
    onBlur
  });
  const label = new Intl.DateTimeFormat(locale, {
    weekday: "long",
    month: "long",
    day: "numeric"
  }).format(day);
  React224.useEffect(() => {
    if (focused && ref.current) {
      ref.current.focus();
    }
  }, [
    focused
  ]);
  const content = React224.useMemo(() => {
    if (renderDayContent) {
      return renderDayContent(day);
    }
    return (0, import_jsx_runtime221.jsxs)("div", {
      className: "vkuiCalendarDay__dayNumber",
      children: [
        (0, import_jsx_runtime221.jsx)(VisuallyHidden, {
          children: children !== null && children !== void 0 ? children : label
        }),
        (0, import_jsx_runtime221.jsx)("span", {
          "aria-hidden": true,
          children: day.getDate()
        })
      ]
    });
  }, [
    renderDayContent,
    day,
    children,
    label
  ]);
  if (hidden) {
    return (0, import_jsx_runtime221.jsx)("div", {
      role,
      "aria-colindex": colIndex,
      className: clsx("vkuiCalendarDay__hidden", size5 === "s" && "vkuiCalendarDay__sizeS")
    });
  }
  return (0, import_jsx_runtime221.jsx)(Tappable, _object_spread_props(_object_spread({
    baseClassName: clsx("vkuiCalendarDay__host", size5 === "s" && "vkuiCalendarDay__sizeS", direction === "rtl" && "vkuiCalendarDay__rtl", focusVisibleClassNames),
    role,
    "aria-colindex": colIndex,
    hoverMode: "vkuiCalendarDay__hostHovered",
    activeMode: "vkuiCalendarDay__hostActivated",
    hasActive: false,
    onClick,
    disabled,
    getRootRef: ref,
    onPointerEnter: handleEnter,
    onPointerLeave: handleLeave,
    "data-testid": typeof testId === "string" ? testId : testId === null || testId === void 0 ? void 0 : testId(day)
  }, restProps, focusHandlers), {
    children: (0, import_jsx_runtime221.jsx)("div", {
      className: clsx("vkuiCalendarDay__content", size5 === "s" && "vkuiCalendarDay__sizeS", today && "vkuiCalendarDay__today", selected && !disabled && "vkuiCalendarDay__selected", selectionStart && "vkuiCalendarDay__selectionStart", selectionEnd && "vkuiCalendarDay__selectionEnd", disabled && "vkuiCalendarDay__disabled", !sameMonth && "vkuiCalendarDay__notSameMonth"),
      children: (0, import_jsx_runtime221.jsx)("div", {
        className: clsx("vkuiCalendarDay__hinted", hinted && "vkuiCalendarDay__hintedActive", hintedSelectionStart && "vkuiCalendarDay__hintedSelectionStart", hintedSelectionEnd && "vkuiCalendarDay__hintedSelectionEnd"),
        children: (0, import_jsx_runtime221.jsx)("div", {
          className: clsx("vkuiCalendarDay__inner", active && !disabled && "vkuiCalendarDay__innerActive"),
          children: content
        })
      })
    })
  }));
});
if (true) {
  defineComponentDisplayNames(CalendarDay, "CalendarDay");
}

// node_modules/@vkontakte/vkui/dist/components/CalendarDays/CalendarDays.js
var CalendarDays = (_param) => {
  var { viewDate, value, weekStartsOn, onDayChange, isDaySelected, isDayActive, isDaySelectionEnd, isDaySelectionStart, onDayEnter, onDayLeave, onDayFocus, isDayHinted, isHintedDaySelectionStart, isHintedDaySelectionEnd, isDayFocused, isDayFocusable, isDayDisabled, size: size5, showNeighboringMonth = false, dayProps, listenDayChangesForUpdate = false, getRootRef, renderDayContent, dayTestId } = _param, props = _object_without_properties(_param, [
    "viewDate",
    "value",
    "weekStartsOn",
    "onDayChange",
    "isDaySelected",
    "isDayActive",
    "isDaySelectionEnd",
    "isDaySelectionStart",
    "onDayEnter",
    "onDayLeave",
    "onDayFocus",
    "isDayHinted",
    "isHintedDaySelectionStart",
    "isHintedDaySelectionEnd",
    "isDayFocused",
    "isDayFocusable",
    "isDayDisabled",
    "size",
    "showNeighboringMonth",
    "dayProps",
    "listenDayChangesForUpdate",
    "getRootRef",
    "renderDayContent",
    "dayTestId"
  ]);
  const { locale } = useConfigProvider();
  const now2 = useTodayDate(listenDayChangesForUpdate);
  const weeks = React225.useMemo(() => getWeeks(viewDate, weekStartsOn), [
    weekStartsOn,
    viewDate
  ]);
  const daysNames = React225.useMemo(() => getDaysNames(now2, weekStartsOn, locale), [
    locale,
    now2,
    weekStartsOn
  ]);
  const handleDayChange = React225.useCallback((date) => {
    onDayChange(date);
  }, [
    onDayChange
  ]);
  const viewDateLabelId = React225.useId();
  const currentMonthLabel = value ? new Intl.DateTimeFormat(locale, {
    year: "numeric",
    month: "long"
  }).format(viewDate) : null;
  return (0, import_jsx_runtime222.jsxs)(React225.Fragment, {
    children: [
      (0, import_jsx_runtime222.jsx)(VisuallyHidden, {
        "aria-live": "polite",
        id: viewDateLabelId,
        children: currentMonthLabel
      }),
      (0, import_jsx_runtime222.jsxs)(RootComponent, _object_spread_props(_object_spread({
        role: "grid"
      }, props), {
        baseClassName: "vkuiCalendarDays__host",
        "aria-labelledby": viewDateLabelId,
        children: [
          (0, import_jsx_runtime222.jsx)("div", {
            role: "row",
            "aria-rowindex": 1,
            className: clsx("vkuiCalendarDays__row", size5 === "s" && "vkuiCalendarDays__rowSizeS"),
            children: daysNames.map(({ short: shortDayName, long: longDayName }) => (0, import_jsx_runtime222.jsx)(Footnote, {
              role: "columnheader",
              "aria-label": longDayName,
              className: "vkuiCalendarDays__weekday",
              children: shortDayName
            }, shortDayName))
          }),
          weeks.map((week, i) => (0, import_jsx_runtime222.jsx)("div", {
            role: "row",
            "aria-rowindex": i + 2,
            className: clsx("vkuiCalendarDays__row", size5 === "s" && "vkuiCalendarDays__rowSizeS"),
            children: week.map((day, i2) => {
              const sameMonth = isSameMonth(day, viewDate);
              const isHidden = !showNeighboringMonth && !sameMonth;
              const isToday = isSameDate(day, now2);
              const isActive = isDayActive(day);
              const isFocused = isDayFocused(day);
              return (0, import_jsx_runtime222.jsx)(CalendarDay, _object_spread_props(_object_spread({
                role: "gridcell",
                "aria-current": isToday ? "date" : void 0,
                "aria-selected": isActive ? "true" : "false",
                "aria-colindex": i2 + 1,
                tabIndex: (isDayFocusable === null || isDayFocusable === void 0 ? void 0 : isDayFocusable(day)) ? 0 : -1,
                day,
                today: isToday,
                active: isActive,
                onChange: handleDayChange,
                hidden: isHidden,
                disabled: isDayDisabled(day),
                selectionStart: isDaySelectionStart(day, i2),
                selectionEnd: isDaySelectionEnd(day, i2),
                hintedSelectionStart: isHintedDaySelectionStart === null || isHintedDaySelectionStart === void 0 ? void 0 : isHintedDaySelectionStart(day, i2),
                hintedSelectionEnd: isHintedDaySelectionEnd === null || isHintedDaySelectionEnd === void 0 ? void 0 : isHintedDaySelectionEnd(day, i2),
                selected: isDaySelected === null || isDaySelected === void 0 ? void 0 : isDaySelected(day),
                focused: isFocused,
                onEnter: onDayEnter,
                onLeave: onDayLeave,
                onFocus: onDayFocus,
                hinted: isDayHinted === null || isDayHinted === void 0 ? void 0 : isDayHinted(day),
                sameMonth,
                size: size5,
                renderDayContent,
                testId: dayTestId
              }, dayProps), {
                className: clsx(dayProps === null || dayProps === void 0 ? void 0 : dayProps.className, "vkuiCalendarDays__rowDay")
              }), day.toISOString());
            })
          }, i))
        ]
      }))
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/CalendarHeader/CalendarHeader.js
var import_jsx_runtime224 = __toESM(require_jsx_runtime(), 1);
var React227 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/AdaptivityProvider/AdaptivityProvider.js
var import_jsx_runtime223 = __toESM(require_jsx_runtime(), 1);
var React226 = __toESM(require_react(), 1);
var AdaptivityProvider = ({ viewWidth, viewHeight, sizeX: sizeXProp, sizeY: sizeYProp, hasPointer, hasHover: hasHover2, children }) => {
  const adaptivity = React226.useMemo(() => {
    const nextProps = {
      viewWidth,
      viewHeight,
      sizeX: sizeXProp,
      sizeY: sizeYProp,
      hasPointer,
      hasHover: hasHover2
    };
    if (sizeXProp === void 0 && viewWidth !== void 0) {
      nextProps.sizeX = getSizeX(viewWidth);
    }
    if (sizeYProp === void 0) {
      if (isCompactByViewWidth(viewWidth, hasPointer) || isCompactByViewHeight(viewHeight)) {
        nextProps.sizeY = "compact";
      } else if (viewWidth !== void 0 || viewHeight !== void 0) {
        nextProps.sizeY = "regular";
      }
    }
    return nextProps;
  }, [
    viewWidth,
    viewHeight,
    sizeXProp,
    sizeYProp,
    hasPointer,
    hasHover2
  ]);
  return (0, import_jsx_runtime223.jsx)(AdaptivityContext.Provider, {
    value: adaptivity,
    children
  });
};

// node_modules/@vkontakte/vkui/dist/components/CalendarHeader/CalendarHeader.js
var CalendarHeader = (_param) => {
  var { viewDate, onChange, prevMonthHidden: prevMonthHiddenProp = false, nextMonthHidden: nextMonthHiddenProp = false, disablePickers = false, onNextMonth, onPrevMonth, prevMonthProps = {}, nextMonthProps = {}, prevMonthLabel = "Предыдущий месяц", nextMonthLabel = "Следующий месяц", changeMonthLabel = "Изменить месяц", changeYearLabel = "Изменить год", prevMonthIcon = (0, import_jsx_runtime224.jsx)(Icon20ChevronLeftOutline, {
    className: "vkuiCalendarHeader__navIconAccent",
    width: 30,
    height: 30
  }), nextMonthIcon = (0, import_jsx_runtime224.jsx)(Icon20ChevronRightOutline, {
    className: "vkuiCalendarHeader__navIconAccent",
    width: 30,
    height: 30
  }), isMonthDisabled, isYearDisabled, monthDropdownTestId, yearDropdownTestId, prevMonthButtonTestId, nextMonthButtonTestId } = _param, restProps = _object_without_properties(_param, [
    "viewDate",
    "onChange",
    "prevMonthHidden",
    "nextMonthHidden",
    "disablePickers",
    "onNextMonth",
    "onPrevMonth",
    "prevMonthProps",
    "nextMonthProps",
    "prevMonthLabel",
    "nextMonthLabel",
    "changeMonthLabel",
    "changeYearLabel",
    "prevMonthIcon",
    "nextMonthIcon",
    "isMonthDisabled",
    "isYearDisabled",
    "monthDropdownTestId",
    "yearDropdownTestId",
    "prevMonthButtonTestId",
    "nextMonthButtonTestId"
  ]);
  const { locale, direction } = useConfigProvider();
  const onMonthsChange = React227.useCallback((_, newValue) => onChange(setMonth(viewDate, Number(newValue))), [
    onChange,
    viewDate
  ]);
  const onYearChange = React227.useCallback((_, newValue) => onChange(setYear(viewDate, Number(newValue))), [
    onChange,
    viewDate
  ]);
  const currentYear = viewDate.getFullYear();
  const currentMonth = viewDate.getMonth();
  const months = React227.useMemo(() => getMonths(locale).map(({ value, label }) => ({
    value,
    label: (0, import_jsx_runtime224.jsx)("span", {
      className: "vkuiCalendarHeader__month",
      children: label
    }),
    disabled: isMonthDisabled && isMonthDisabled(value)
  })), [
    locale,
    isMonthDisabled
  ]);
  const years = React227.useMemo(() => getYears(currentYear, 100).map((year) => _object_spread_props(_object_spread({}, year), {
    disabled: isYearDisabled && isYearDisabled(year.value)
  })), [
    currentYear,
    isYearDisabled
  ]);
  const formatter = new Intl.DateTimeFormat(locale, {
    year: "numeric",
    month: "long"
  });
  const { className: prevMonthClassName } = prevMonthProps, restPrevMonthProps = _object_without_properties(prevMonthProps, [
    "className"
  ]);
  const { className: nextMonthClassName } = nextMonthProps, restNextMonthProps = _object_without_properties(nextMonthProps, [
    "className"
  ]);
  let nextMonthHidden = nextMonthHiddenProp || currentMonth === 11 && currentYear === DEFAULT_MAX_YEAR;
  if (isMonthDisabled && !nextMonthHidden) {
    nextMonthHidden = isMonthDisabled(currentMonth === 11 ? 0 : currentMonth + 1, currentMonth === 11 ? Math.min(currentYear + 1, DEFAULT_MAX_YEAR) : currentYear);
  }
  let prevMonthHidden = prevMonthHiddenProp || currentMonth === 0 && currentYear === DEFAULT_MIN_YEAR;
  if (isMonthDisabled && !prevMonthHidden) {
    prevMonthHidden = isMonthDisabled(currentMonth === 0 ? 11 : currentMonth - 1, currentMonth === 0 ? Math.max(currentYear - 1, DEFAULT_MIN_YEAR) : currentYear);
  }
  const stopPropogationOfEscapeKeyboardEventWhenSelectIsOpen = React227.useCallback((event, isOpen) => {
    if (isOpen && event.key === "Escape") {
      event.stopPropagation();
    }
  }, []);
  return (0, import_jsx_runtime224.jsxs)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: "vkuiCalendarHeader__host"
  }, restProps), {
    children: [
      !prevMonthHidden && (0, import_jsx_runtime224.jsx)(AdaptivityProvider, {
        sizeX: "regular",
        children: (0, import_jsx_runtime224.jsxs)(Tappable, _object_spread_props(_object_spread({
          baseClassName: clsx("vkuiCalendarHeader__navIcon", "vkuiCalendarHeader__navIconPrev", prevMonthClassName),
          onClick: onPrevMonth,
          "data-testid": prevMonthButtonTestId
        }, restPrevMonthProps), {
          children: [
            (0, import_jsx_runtime224.jsxs)(VisuallyHidden, {
              children: [
                prevMonthLabel,
                ", ",
                formatter.format(subMonths(viewDate, 1))
              ]
            }),
            direction === "ltr" ? prevMonthIcon : nextMonthIcon
          ]
        }))
      }),
      disablePickers ? (0, import_jsx_runtime224.jsxs)(Paragraph, {
        className: clsx("vkuiCalendarHeader__pickers", "vkuiInternalCalendarHeader__pickers"),
        weight: "2",
        children: [
          (0, import_jsx_runtime224.jsx)("span", {
            className: "vkuiCalendarHeader__month",
            children: new Intl.DateTimeFormat(locale, {
              month: "long"
            }).format(viewDate)
          }),
          " ",
          new Intl.DateTimeFormat(locale, {
            year: "numeric"
          }).format(viewDate)
        ]
      }) : (0, import_jsx_runtime224.jsx)(AdaptivityProvider, {
        sizeY: "compact",
        children: (0, import_jsx_runtime224.jsxs)("div", {
          className: clsx("vkuiCalendarHeader__pickers", "vkuiInternalCalendarHeader__pickers"),
          children: [
            (0, import_jsx_runtime224.jsx)(CustomSelect, {
              className: clsx("vkuiCalendarHeader__picker", "vkuiInternalCalendarHeader__picker"),
              value: currentMonth,
              options: months,
              dropdownOffsetDistance: 4,
              dropdownAutoWidth: true,
              icon: (0, import_jsx_runtime224.jsx)(Icon12Dropdown, {}),
              onChange: onMonthsChange,
              forceDropdownPortal: false,
              selectType: "accent",
              "aria-label": changeMonthLabel,
              "data-testid": typeof monthDropdownTestId === "string" ? monthDropdownTestId : monthDropdownTestId === null || monthDropdownTestId === void 0 ? void 0 : monthDropdownTestId(currentMonth),
              onInputKeyDown: stopPropogationOfEscapeKeyboardEventWhenSelectIsOpen
            }),
            (0, import_jsx_runtime224.jsx)(CustomSelect, {
              className: clsx("vkuiCalendarHeader__picker", "vkuiInternalCalendarHeader__picker"),
              value: currentYear,
              options: years,
              dropdownOffsetDistance: 4,
              dropdownAutoWidth: true,
              icon: (0, import_jsx_runtime224.jsx)(Icon12Dropdown, {}),
              onChange: onYearChange,
              forceDropdownPortal: false,
              selectType: "accent",
              "aria-label": changeYearLabel,
              "data-testid": typeof yearDropdownTestId === "string" ? yearDropdownTestId : yearDropdownTestId === null || yearDropdownTestId === void 0 ? void 0 : yearDropdownTestId(currentYear),
              onInputKeyDown: stopPropogationOfEscapeKeyboardEventWhenSelectIsOpen
            })
          ]
        })
      }),
      !nextMonthHidden && (0, import_jsx_runtime224.jsx)(AdaptivityProvider, {
        sizeX: "regular",
        children: (0, import_jsx_runtime224.jsxs)(Tappable, _object_spread_props(_object_spread({
          baseClassName: clsx("vkuiCalendarHeader__navIcon", "vkuiCalendarHeader__navIconNext", nextMonthClassName),
          onClick: onNextMonth,
          "data-testid": nextMonthButtonTestId
        }, restNextMonthProps), {
          children: [
            (0, import_jsx_runtime224.jsxs)(VisuallyHidden, {
              children: [
                nextMonthLabel,
                ", ",
                formatter.format(addMonths(viewDate, 1))
              ]
            }),
            direction === "ltr" ? nextMonthIcon : prevMonthIcon
          ]
        }))
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/CalendarTime/CalendarTime.js
var import_jsx_runtime225 = __toESM(require_jsx_runtime(), 1);
var import_react26 = __toESM(require_react(), 1);
var React228 = __toESM(require_react(), 1);
var selectFilterFn = () => true;
var hours = [];
for (let i = 0; i < 24; i += 1) {
  hours.push({
    value: i,
    label: String(i).padStart(2, "0")
  });
}
var minutes = [];
for (let i = 0; i < 60; i += 1) {
  minutes.push({
    value: i,
    label: String(i).padStart(2, "0")
  });
}
var validateValue = (value, validValues) => {
  const numValue = Number(value);
  return !isNaN(numValue) && validValues.some((v) => v.value === numValue);
};
var CalendarTime = ({ value, onChange, onDoneButtonClick, changeHoursLabel, changeMinutesLabel, isDayDisabled, doneButtonText = "Готово", doneButtonDisabled = false, doneButtonShow = true, minutesTestId, hoursTestId, doneButtonTestId, DoneButton }) => {
  const hoursInputRef = (0, import_react26.useRef)(null);
  const minutesInputRef = (0, import_react26.useRef)(null);
  const doneButtonRef = (0, import_react26.useRef)(null);
  const localHours = isDayDisabled ? hours.map((hour) => {
    return _object_spread_props(_object_spread({}, hour), {
      disabled: isDayDisabled(setHours(value, hour.value), true)
    });
  }) : hours;
  const localMinutes = isDayDisabled ? minutes.map((minute) => {
    return _object_spread_props(_object_spread({}, minute), {
      disabled: isDayDisabled(setMinutes(value, minute.value), true)
    });
  }) : minutes;
  const onPickerValueChange = (e, validate, setter) => {
    const numericValue = e.target.value.replace(/\D/g, "");
    e.target.value = numericValue;
    if (validate(numericValue)) {
      onChange === null || onChange === void 0 ? void 0 : onChange(setter(value, Number(numericValue)));
    }
  };
  const onHoursInputChange = (e) => {
    onPickerValueChange(e, (numValue) => validateValue(numValue, localHours), setHours);
  };
  const onMinutesInputChange = (e) => {
    onPickerValueChange(e, (numValue) => validateValue(numValue, localMinutes), setMinutes);
  };
  const onHoursChange = React228.useCallback((_, newValue) => onChange === null || onChange === void 0 ? void 0 : onChange(setHours(value, Number(newValue))), [
    onChange,
    value
  ]);
  const onMinutesChange = React228.useCallback((_, newValue) => onChange === null || onChange === void 0 ? void 0 : onChange(setMinutes(value, Number(newValue))), [
    onChange,
    value
  ]);
  const onPickerKeyDown = (e) => {
    const key = pressedKey(e);
    if (key !== Keys.ENTER) {
      return;
    }
    const steps = [
      hoursInputRef,
      minutesInputRef,
      doneButtonRef
    ].filter((ref) => Boolean(ref.current));
    const currentStepIndex = steps.findIndex((step) => step.current === e.target);
    const nextStepIndex = currentStepIndex + 1;
    if (nextStepIndex >= steps.length) {
      return;
    }
    const nextStep = steps[nextStepIndex];
    if (nextStep.current) {
      var _nextStep_current;
      e.preventDefault();
      (_nextStep_current = nextStep.current) === null || _nextStep_current === void 0 ? void 0 : _nextStep_current.focus();
    }
  };
  const stopPropogationOfEscapeKeyboardEventWhenSelectIsOpen = React228.useCallback((event, isOpen) => {
    if (isOpen && event.key === "Escape") {
      event.stopPropagation();
    }
  }, []);
  const onSelectInputKeyDown = callMultiple(onPickerKeyDown, stopPropogationOfEscapeKeyboardEventWhenSelectIsOpen);
  const renderDoneButton = () => {
    const ButtonComponent = DoneButton !== null && DoneButton !== void 0 ? DoneButton : Button;
    return (0, import_jsx_runtime225.jsx)(ButtonComponent, {
      mode: "secondary",
      onClick: onDoneButtonClick,
      size: "l",
      getRootRef: doneButtonRef,
      onKeyDown: onPickerKeyDown,
      disabled: doneButtonDisabled,
      "data-testid": doneButtonTestId,
      children: doneButtonText
    });
  };
  return (0, import_jsx_runtime225.jsxs)("div", {
    className: clsx("vkuiCalendarTime__host", !doneButtonShow && "vkuiCalendarTime__host__withoutDone"),
    children: [
      (0, import_jsx_runtime225.jsx)("div", {
        className: "vkuiCalendarTime__picker",
        children: (0, import_jsx_runtime225.jsx)(AdaptivityProvider, {
          sizeY: "compact",
          children: (0, import_jsx_runtime225.jsx)(CustomSelect, {
            value: value.getHours(),
            options: localHours,
            onChange: onHoursChange,
            forceDropdownPortal: false,
            searchable: true,
            filterFn: selectFilterFn,
            onInputChange: onHoursInputChange,
            onInputKeyDown: onSelectInputKeyDown,
            getSelectInputRef: hoursInputRef,
            "aria-label": changeHoursLabel,
            "data-testid": hoursTestId
          })
        })
      }),
      (0, import_jsx_runtime225.jsx)("div", {
        className: "vkuiCalendarTime__divider",
        children: ":"
      }),
      (0, import_jsx_runtime225.jsx)("div", {
        className: "vkuiCalendarTime__picker",
        children: (0, import_jsx_runtime225.jsx)(AdaptivityProvider, {
          sizeY: "compact",
          children: (0, import_jsx_runtime225.jsx)(CustomSelect, {
            value: value.getMinutes(),
            options: localMinutes,
            onChange: onMinutesChange,
            forceDropdownPortal: false,
            searchable: true,
            filterFn: selectFilterFn,
            onInputChange: onMinutesInputChange,
            getSelectInputRef: minutesInputRef,
            onInputKeyDown: onSelectInputKeyDown,
            "aria-label": changeMinutesLabel,
            "data-testid": minutesTestId
          })
        })
      }),
      doneButtonShow && (0, import_jsx_runtime225.jsx)("div", {
        className: "vkuiCalendarTime__button",
        children: (0, import_jsx_runtime225.jsx)(AdaptivityProvider, {
          sizeY: "compact",
          children: renderDoneButton()
        })
      })
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/Calendar/Calendar.js
var warn37 = warnOnce("Calendar");
var Calendar = (_param) => {
  var { getRootRef, "value": valueProp, defaultValue, onChange, disablePast, disableFuture, shouldDisableDate, onDoneButtonClick, enableTime = false, doneButtonText, doneButtonDisabled, doneButtonShow, DoneButton, weekStartsOn = 1, disablePickers, "aria-label": ariaLabel = "Календарь", changeHoursLabel = "Изменить час", changeMinutesLabel = "Изменить минуту", prevMonthLabel = "Предыдущий месяц", nextMonthLabel = "Следующий месяц", changeMonthLabel = "Изменить месяц", changeYearLabel = "Изменить год", showNeighboringMonth, size: size5 = "m", "viewDate": externalViewDate, onHeaderChange, onNextMonth, onPrevMonth, prevMonthIcon, nextMonthIcon, prevMonthProps, nextMonthProps, dayProps, listenDayChangesForUpdate, renderDayContent, minDateTime, maxDateTime, timezone, minutesTestId, hoursTestId, doneButtonTestId, prevMonthButtonTestId, nextMonthButtonTestId, monthDropdownTestId, yearDropdownTestId, dayTestId } = _param, props = _object_without_properties(_param, [
    "getRootRef",
    "value",
    "defaultValue",
    "onChange",
    "disablePast",
    "disableFuture",
    "shouldDisableDate",
    "onDoneButtonClick",
    "enableTime",
    "doneButtonText",
    "doneButtonDisabled",
    "doneButtonShow",
    "DoneButton",
    "weekStartsOn",
    "disablePickers",
    "aria-label",
    "changeHoursLabel",
    "changeMinutesLabel",
    "prevMonthLabel",
    "nextMonthLabel",
    "changeMonthLabel",
    "changeYearLabel",
    "showNeighboringMonth",
    "size",
    "viewDate",
    "onHeaderChange",
    "onNextMonth",
    "onPrevMonth",
    "prevMonthIcon",
    "nextMonthIcon",
    "prevMonthProps",
    "nextMonthProps",
    "dayProps",
    "listenDayChangesForUpdate",
    "renderDayContent",
    "minDateTime",
    "maxDateTime",
    "timezone",
    "minutesTestId",
    "hoursTestId",
    "doneButtonTestId",
    "prevMonthButtonTestId",
    "nextMonthButtonTestId",
    "monthDropdownTestId",
    "yearDropdownTestId",
    "dayTestId"
  ]);
  const _onChange = React229.useCallback((date) => {
    onChange === null || onChange === void 0 ? void 0 : onChange(convertDateFromTimeZone(date, timezone) || void 0);
  }, [
    onChange,
    timezone
  ]);
  const [value, updateValue] = useCustomEnsuredControl({
    value: valueProp,
    defaultValue,
    onChange: _onChange
  });
  const timeZonedValue = React229.useMemo(() => convertDateToTimeZone(value, timezone), [
    timezone,
    value
  ]);
  const { viewDate, setViewDate, setPrevMonth, setNextMonth, focusedDay, setFocusedDay, isDayFocused, isDayDisabled, isMonthDisabled, isYearDisabled } = useCalendar({
    value: timeZonedValue,
    disableFuture,
    disablePast,
    shouldDisableDate,
    onHeaderChange,
    onNextMonth,
    onPrevMonth,
    minDateTime,
    maxDateTime
  });
  const [focusableDay, setFocusableDay] = React229.useState();
  useIsomorphicLayoutEffect(() => {
    if (timeZonedValue) {
      setViewDate(timeZonedValue);
    }
  }, [
    timeZonedValue
  ]);
  if (!disablePickers && size5 === "s") {
    warn37("Нельзя включить селекты выбора месяца/года, если размер календаря 's'", "error");
  }
  if (enableTime && size5 === "s") {
    warn37("Нельзя включить выбор времени, если размер календаря 's'", "error");
  }
  const handleKeyDown = React229.useCallback((event) => {
    const key = pressedKey(event);
    if (key && NAVIGATION_KEYS.includes(key)) {
      event.preventDefault();
      const newFocusedDay = navigateDate(focusedDay !== null && focusedDay !== void 0 ? focusedDay : timeZonedValue, key);
      if (newFocusedDay && !isSameMonth(newFocusedDay, viewDate)) {
        setViewDate(newFocusedDay);
      }
      setFocusedDay(newFocusedDay);
      setFocusableDay(newFocusedDay);
      return;
    }
    if (key === Keys.TAB) {
      setFocusedDay(void 0);
      setFocusableDay(focusedDay);
      return;
    }
    if ((key === Keys.ENTER || key === Keys.SPACE) && isHTMLElement(event.target)) {
      var _event_target_click, _event_target;
      event.preventDefault();
      (_event_target_click = (_event_target = event.target).click) === null || _event_target_click === void 0 ? void 0 : _event_target_click.call(_event_target);
    }
  }, [
    focusedDay,
    setFocusedDay,
    setFocusableDay,
    setViewDate,
    timeZonedValue,
    viewDate
  ]);
  const onDayChange = React229.useCallback((date) => {
    let actualDate = setTimeEqual(date, timeZonedValue);
    if (minDateTime || maxDateTime) {
      actualDate = clamp3(actualDate, {
        min: minDateTime,
        max: maxDateTime
      });
    }
    updateValue(actualDate);
  }, [
    timeZonedValue,
    updateValue,
    maxDateTime,
    minDateTime
  ]);
  const onDayFocus = React229.useCallback((date) => {
    if (focusedDay && isSameDate(focusedDay, date)) {
      return;
    }
    setFocusedDay(date);
    if (!focusableDay || !isSameDate(date, focusableDay)) {
      setFocusableDay(date);
    }
  }, [
    focusableDay,
    focusedDay,
    setFocusedDay
  ]);
  const isDayActive = React229.useCallback((day) => Boolean(timeZonedValue && isSameDate(day, timeZonedValue)), [
    timeZonedValue
  ]);
  const isFocusableDayInViewDateMonth = focusableDay && isSameMonth(focusableDay, viewDate);
  const isInputValueDateInViewDateMonth = timeZonedValue && isSameMonth(timeZonedValue, viewDate);
  const isDayFocusable = React229.useCallback((day) => {
    if (isFocusableDayInViewDateMonth) {
      return isSameDate(focusableDay, day);
    }
    if (isInputValueDateInViewDateMonth) {
      return isDayActive(day);
    }
    return isSameDate(startOfMonth(viewDate), day);
  }, [
    focusableDay,
    viewDate,
    isDayActive,
    isFocusableDayInViewDateMonth,
    isInputValueDateInViewDateMonth
  ]);
  return (0, import_jsx_runtime226.jsxs)(RootComponent, _object_spread_props(_object_spread({
    "aria-label": ariaLabel
  }, props), {
    baseClassName: clsx("vkuiCalendar__host", size5 === "s" && "vkuiCalendar__sizeS"),
    getRootRef,
    children: [
      (0, import_jsx_runtime226.jsx)(CalendarHeader, {
        viewDate: externalViewDate || viewDate,
        onChange: setViewDate,
        onNextMonth: setNextMonth,
        onPrevMonth: setPrevMonth,
        disablePickers: disablePickers || size5 === "s",
        className: "vkuiCalendar__header",
        prevMonthLabel,
        nextMonthLabel,
        changeMonthLabel,
        changeYearLabel,
        prevMonthIcon,
        nextMonthIcon,
        prevMonthProps,
        nextMonthProps,
        isMonthDisabled,
        isYearDisabled,
        nextMonthButtonTestId,
        prevMonthButtonTestId,
        monthDropdownTestId,
        yearDropdownTestId
      }),
      (0, import_jsx_runtime226.jsx)(CalendarDays, {
        viewDate: externalViewDate || viewDate,
        value: timeZonedValue,
        weekStartsOn,
        onKeyDown: handleKeyDown,
        onDayChange,
        isDayActive,
        onDayFocus,
        isDayFocused,
        isDayFocusable,
        isDaySelectionStart: isFirstDay,
        isDaySelectionEnd: isLastDay,
        isDayDisabled,
        showNeighboringMonth,
        size: size5,
        dayProps,
        listenDayChangesForUpdate,
        renderDayContent,
        dayTestId
      }),
      enableTime && timeZonedValue && size5 !== "s" && (0, import_jsx_runtime226.jsx)("div", {
        className: "vkuiCalendar__time",
        children: (0, import_jsx_runtime226.jsx)(CalendarTime, {
          value: timeZonedValue,
          onChange: updateValue,
          onDoneButtonClick,
          doneButtonText,
          doneButtonDisabled,
          doneButtonShow,
          DoneButton,
          changeHoursLabel,
          changeMinutesLabel,
          isDayDisabled: minDateTime || maxDateTime ? isDayDisabled : void 0,
          minutesTestId,
          hoursTestId,
          doneButtonTestId
        })
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/CalendarRange/CalendarRange.js
var import_jsx_runtime227 = __toESM(require_jsx_runtime(), 1);
var React231 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/CalendarRange/utils.js
var React230 = __toESM(require_react(), 1);
function useCalendarKeyboardNavigation({ focusedDay, value, setFocusedDay, viewDates: [firstCalendarViewDate, secondCalendarViewDate], setViewDate }) {
  const [focusableDayOnFirstCalendar, setFocusableDayOnFirstCalendar] = React230.useState();
  const [focusableDayOnSecondCalendar, setFocusableDayOnSecondCalendar] = React230.useState();
  const handleCalendarKeyDown = React230.useCallback((event, isFirst) => {
    const key = pressedKey(event);
    if (!key) {
      return;
    }
    if (NAVIGATION_KEYS.includes(key)) {
      event.preventDefault();
      const newFocusedDay = navigateDate(focusedDay !== null && focusedDay !== void 0 ? focusedDay : value === null || value === void 0 ? void 0 : value[0], key);
      if (newFocusedDay && !isSameMonth(newFocusedDay, firstCalendarViewDate) && !isSameMonth(newFocusedDay, secondCalendarViewDate)) {
        setViewDate(newFocusedDay);
      }
      if (isFirst) {
        if (isSameMonth(newFocusedDay, firstCalendarViewDate)) {
          setFocusableDayOnFirstCalendar(newFocusedDay);
        } else if (newFocusedDay > firstCalendarViewDate) {
          setFocusableDayOnSecondCalendar(newFocusedDay);
        }
      } else {
        if (isSameMonth(newFocusedDay, secondCalendarViewDate)) {
          setFocusableDayOnSecondCalendar(newFocusedDay);
        } else if (newFocusedDay < secondCalendarViewDate) {
          setFocusableDayOnFirstCalendar(newFocusedDay);
        }
      }
      setFocusedDay(newFocusedDay);
      return;
    }
    if (key === Keys.TAB) {
      setFocusedDay(void 0);
      if (isFirst) {
        setFocusableDayOnFirstCalendar(focusedDay);
      } else {
        setFocusableDayOnSecondCalendar(focusedDay);
      }
      return;
    }
    if ((key === Keys.ENTER || key === Keys.SPACE) && isHTMLElement(event.target)) {
      var _event_target_click, _event_target;
      event.preventDefault();
      (_event_target_click = (_event_target = event.target).click) === null || _event_target_click === void 0 ? void 0 : _event_target_click.call(_event_target);
    }
  }, [
    focusedDay,
    value,
    firstCalendarViewDate,
    secondCalendarViewDate,
    setFocusedDay,
    setViewDate
  ]);
  const handleFirstCalendarKeyDown = React230.useCallback((event) => {
    handleCalendarKeyDown(event, true);
  }, [
    handleCalendarKeyDown
  ]);
  const handleSecondCalendarKeyDown = React230.useCallback((event) => {
    handleCalendarKeyDown(event, false);
  }, [
    handleCalendarKeyDown
  ]);
  const handleDayFocus = React230.useCallback((value2) => {
    if (isSameMonth(firstCalendarViewDate, value2) && (!focusableDayOnFirstCalendar || !isSameDate(focusableDayOnFirstCalendar, value2))) {
      setFocusableDayOnFirstCalendar(value2);
    }
    if (isSameMonth(secondCalendarViewDate, value2) && (!focusableDayOnSecondCalendar || !isSameDate(focusableDayOnSecondCalendar, value2))) {
      setFocusableDayOnSecondCalendar(value2);
    }
  }, [
    firstCalendarViewDate,
    focusableDayOnFirstCalendar,
    focusableDayOnSecondCalendar,
    secondCalendarViewDate
  ]);
  return {
    focusableDayOnFirstCalendar,
    focusableDayOnSecondCalendar,
    handleFirstCalendarKeyDown,
    handleSecondCalendarKeyDown,
    handleDayFocus
  };
}
function useIsDayFocusable({ value, focusableDayOnFirstCalendar, focusableDayOnSecondCalendar, viewDate, isDayActive }) {
  const isValueVisibleOnCalendar = Boolean(value && (value[0] && isSameMonth(value[0], viewDate) || value[1] && isSameMonth(value[1], viewDate)));
  const isCalendarHasFocusableDay = Boolean(focusableDayOnFirstCalendar && isSameMonth(focusableDayOnFirstCalendar, viewDate) || focusableDayOnSecondCalendar && isSameMonth(focusableDayOnSecondCalendar, viewDate));
  const isDayFocusable = React230.useCallback((day) => {
    if (isCalendarHasFocusableDay) {
      return Boolean(focusableDayOnFirstCalendar && isSameDate(focusableDayOnFirstCalendar, day) || focusableDayOnSecondCalendar && isSameDate(focusableDayOnSecondCalendar, day));
    }
    if (isValueVisibleOnCalendar) {
      return isDayActive(day);
    }
    return isSameDate(startOfMonth(viewDate), day);
  }, [
    isCalendarHasFocusableDay,
    isValueVisibleOnCalendar,
    viewDate,
    isDayActive,
    focusableDayOnFirstCalendar,
    focusableDayOnSecondCalendar
  ]);
  return isDayFocusable;
}

// node_modules/@vkontakte/vkui/dist/components/CalendarRange/CalendarRange.js
var getIsDaySelected = (day, value) => {
  if (!(value === null || value === void 0 ? void 0 : value[0]) || !value[1]) {
    return false;
  }
  return isWithinInterval(day, [
    startOfDay(value[0]),
    endOfDay(value[1])
  ]);
};
var CalendarRange = (_param) => {
  var { "value": valueProp, defaultValue, onChange, disablePast, disableFuture, shouldDisableDate, weekStartsOn = MONDAY, disablePickers, prevMonthLabel = "Предыдущий месяц", nextMonthLabel = "Следующий месяц", changeMonthLabel = "Изменить месяц", changeYearLabel = "Изменить год", "aria-label": ariaLabel = "Календарь", prevMonthIcon, nextMonthIcon, listenDayChangesForUpdate, renderDayContent, dayTestId, leftPartHeaderTestsData, rightPartHeaderTestsData, getRootRef } = _param, props = _object_without_properties(_param, [
    "value",
    "defaultValue",
    "onChange",
    "disablePast",
    "disableFuture",
    "shouldDisableDate",
    "weekStartsOn",
    "disablePickers",
    "prevMonthLabel",
    "nextMonthLabel",
    "changeMonthLabel",
    "changeYearLabel",
    "aria-label",
    "prevMonthIcon",
    "nextMonthIcon",
    "listenDayChangesForUpdate",
    "renderDayContent",
    "dayTestId",
    "leftPartHeaderTestsData",
    "rightPartHeaderTestsData",
    "getRootRef"
  ]);
  const _onChange = React231.useCallback((newValue) => onChange === null || onChange === void 0 ? void 0 : onChange(newValue || void 0), [
    onChange
  ]);
  const [value, updateValue] = useCustomEnsuredControl({
    value: valueProp,
    defaultValue,
    onChange: _onChange
  });
  const { viewDate, setViewDate, setPrevMonth, setNextMonth, focusedDay, setFocusedDay, isDayFocused, isDayDisabled, isMonthDisabled, isYearDisabled } = useCalendar({
    value,
    disableFuture,
    disablePast,
    shouldDisableDate
  });
  const [hintedDate, setHintedDate] = React231.useState();
  const secondViewDate = addMonths(viewDate, 1);
  const { focusableDayOnFirstCalendar, focusableDayOnSecondCalendar, handleFirstCalendarKeyDown, handleSecondCalendarKeyDown, handleDayFocus } = useCalendarKeyboardNavigation({
    focusedDay,
    setFocusedDay,
    value,
    viewDates: [
      viewDate,
      secondViewDate
    ],
    setViewDate
  });
  const getNewValue = React231.useCallback((date) => {
    const isValueEmpty = !value || value[0] === null && value[1] === null;
    const isRangeSelected = value && !!value[0] && !!value[1];
    if (isValueEmpty || isRangeSelected) {
      return [
        date,
        null
      ];
    }
    const [start] = value;
    if (start && isSameDate(date, start)) {
      return [
        startOfDay(start),
        endOfDay(start)
      ];
    } else if (start && date < start) {
      return [
        startOfDay(date),
        endOfDay(start)
      ];
    } else if (start && date > start) {
      return [
        start,
        endOfDay(date)
      ];
    }
    return value;
  }, [
    value
  ]);
  const onDayChange = React231.useCallback((date) => {
    updateValue(getNewValue(date));
    setHintedDate(void 0);
  }, [
    updateValue,
    getNewValue
  ]);
  const isDaySelected = React231.useCallback((day) => getIsDaySelected(day, value), [
    value
  ]);
  const isDayActive = React231.useCallback((day) => Boolean((value === null || value === void 0 ? void 0 : value[0]) && isSameDate(day, value[0]) || (value === null || value === void 0 ? void 0 : value[1]) && isSameDate(day, value[1])), [
    value
  ]);
  const isDaySelectionEnd = React231.useCallback((day, dayOfWeek) => Boolean(isLastDay(day, dayOfWeek) || (value === null || value === void 0 ? void 0 : value[1]) && isSameDate(day, value[1])), [
    value
  ]);
  const isHintedDaySelectionEnd = React231.useCallback((day, dayOfWeek) => Boolean(isLastDay(day, dayOfWeek) || (hintedDate === null || hintedDate === void 0 ? void 0 : hintedDate[1]) && isSameDate(day, hintedDate[1])), [
    hintedDate
  ]);
  const isDaySelectionStart = React231.useCallback((day, dayOfWeek) => Boolean(isFirstDay(day, dayOfWeek) || (value === null || value === void 0 ? void 0 : value[0]) && isSameDate(day, value[0])), [
    value
  ]);
  const isHintedDaySelectionStart = React231.useCallback((day, dayOfWeek) => Boolean(isFirstDay(day, dayOfWeek) || (hintedDate === null || hintedDate === void 0 ? void 0 : hintedDate[0]) && isSameDate(day, hintedDate[0])), [
    hintedDate
  ]);
  const onDayEnter = React231.useCallback((date) => setHintedDate(getNewValue(date)), [
    setHintedDate,
    getNewValue
  ]);
  const onDayLeave = React231.useCallback(() => setHintedDate(void 0), [
    setHintedDate
  ]);
  const isDayHinted = React231.useCallback((day) => getIsDaySelected(day, hintedDate), [
    hintedDate
  ]);
  const onRightPartViewDateChange = React231.useCallback((newDate) => setViewDate(subMonths(newDate, 1)), [
    setViewDate
  ]);
  const isDayFocusableInFirstCalendar = useIsDayFocusable({
    value,
    focusableDayOnFirstCalendar,
    focusableDayOnSecondCalendar,
    viewDate,
    isDayActive
  });
  const isDayFocusableInSecondCalendar = useIsDayFocusable({
    value,
    focusableDayOnFirstCalendar,
    focusableDayOnSecondCalendar,
    viewDate: secondViewDate,
    isDayActive
  });
  const onDayFocus = React231.useCallback((date) => {
    if (focusedDay && isSameDate(focusedDay, date)) {
      return;
    }
    setFocusedDay(date);
    handleDayFocus(date);
  }, [
    focusedDay,
    handleDayFocus,
    setFocusedDay
  ]);
  return (0, import_jsx_runtime227.jsxs)(RootComponent, _object_spread_props(_object_spread({
    "aria-label": ariaLabel
  }, props), {
    baseClassName: "vkuiCalendarRange__host",
    getRootRef,
    children: [
      (0, import_jsx_runtime227.jsxs)("div", {
        className: "vkuiCalendarRange__inner",
        children: [
          (0, import_jsx_runtime227.jsx)(CalendarHeader, _object_spread({
            viewDate,
            onChange: setViewDate,
            nextMonthHidden: true,
            onPrevMonth: setPrevMonth,
            disablePickers,
            className: "vkuiCalendarRange__header",
            prevMonthLabel,
            nextMonthLabel,
            changeMonthLabel,
            changeYearLabel,
            prevMonthIcon,
            isMonthDisabled,
            isYearDisabled
          }, leftPartHeaderTestsData)),
          (0, import_jsx_runtime227.jsx)(CalendarDays, {
            viewDate,
            value,
            weekStartsOn,
            onKeyDown: handleFirstCalendarKeyDown,
            onDayFocus,
            isDayFocused,
            isDayFocusable: isDayFocusableInFirstCalendar,
            onDayChange,
            isDaySelected,
            isDayActive,
            isDaySelectionEnd,
            isDaySelectionStart,
            isDayHinted,
            onDayEnter,
            onDayLeave,
            isHintedDaySelectionEnd,
            isHintedDaySelectionStart,
            isDayDisabled,
            listenDayChangesForUpdate,
            renderDayContent,
            dayTestId
          })
        ]
      }),
      (0, import_jsx_runtime227.jsxs)("div", {
        className: "vkuiCalendarRange__inner",
        children: [
          (0, import_jsx_runtime227.jsx)(CalendarHeader, _object_spread({
            viewDate: secondViewDate,
            onChange: onRightPartViewDateChange,
            prevMonthHidden: true,
            onNextMonth: setNextMonth,
            disablePickers,
            className: "vkuiCalendarRange__header",
            prevMonthLabel,
            nextMonthLabel,
            changeMonthLabel,
            changeYearLabel,
            nextMonthIcon,
            isMonthDisabled,
            isYearDisabled
          }, rightPartHeaderTestsData)),
          (0, import_jsx_runtime227.jsx)(CalendarDays, {
            viewDate: secondViewDate,
            value,
            weekStartsOn,
            onKeyDown: handleSecondCalendarKeyDown,
            onDayFocus,
            isDayFocused,
            isDayFocusable: isDayFocusableInSecondCalendar,
            onDayChange,
            isDaySelected,
            isDayActive,
            isDaySelectionEnd,
            isDaySelectionStart,
            isDayHinted,
            onDayEnter,
            onDayLeave,
            isHintedDaySelectionEnd,
            isHintedDaySelectionStart,
            isDayDisabled,
            listenDayChangesForUpdate,
            renderDayContent,
            dayTestId
          })
        ]
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/DateInput/DateInput.js
var import_jsx_runtime231 = __toESM(require_jsx_runtime(), 1);
var React236 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useDateInput.js
var import_react27 = __toESM(require_react(), 1);
var React232 = __toESM(require_react(), 1);
function useDateInput({ maxElement, refs, autoFocus, disabled, elementsConfig: elementsConfig3, onClear, onInternalValueChange, getInternalValue: getInternalValue3, value, onCalendarOpenChanged, accessible }) {
  const { document: document2 } = useDOM();
  const { value: open, setTrue: openCalendar, setFalse: closeCalendar } = useBooleanState(false);
  const rootRef = React232.useRef(null);
  const calendarRef = React232.useRef(null);
  const [internalValue, setInternalValue] = React232.useState([]);
  const [focusedElement, setFocusedElement] = React232.useState(null);
  const isClickedOutsideRef = React232.useRef(false);
  const { window: window2 } = useDOM();
  const handleRestoreFocus = React232.useCallback(() => {
    return !isClickedOutsideRef.current;
  }, []);
  const _onCalendarClose = (0, import_react27.useCallback)(() => {
    if (open) {
      closeCalendar();
      onCalendarOpenChanged === null || onCalendarOpenChanged === void 0 ? void 0 : onCalendarOpenChanged(false);
    }
  }, [
    closeCalendar,
    onCalendarOpenChanged,
    open
  ]);
  const _onCalendarOpen = (0, import_react27.useCallback)(() => {
    if (!open) {
      openCalendar();
      onCalendarOpenChanged === null || onCalendarOpenChanged === void 0 ? void 0 : onCalendarOpenChanged(true);
      if (accessible) {
        setFocusedElement(null);
      }
      isClickedOutsideRef.current = false;
    }
  }, [
    onCalendarOpenChanged,
    open,
    openCalendar,
    accessible
  ]);
  const resetFocusedElement = React232.useCallback(() => {
    if (focusedElement !== null) {
      var _window_getSelection;
      setFocusedElement(null);
      (_window_getSelection = window2.getSelection()) === null || _window_getSelection === void 0 ? void 0 : _window_getSelection.removeAllRanges();
      setInternalValue(getInternalValue3(value));
    }
  }, [
    focusedElement,
    getInternalValue3,
    value,
    window2
  ]);
  const removeFocusFromField = React232.useCallback(() => {
    resetFocusedElement();
    _onCalendarClose();
  }, [
    resetFocusedElement,
    _onCalendarClose
  ]);
  const toggleCalendar = (0, import_react27.useCallback)(() => {
    resetFocusedElement();
    if (open) {
      _onCalendarClose();
    } else {
      _onCalendarOpen();
    }
  }, [
    resetFocusedElement,
    open,
    _onCalendarClose,
    _onCalendarOpen
  ]);
  const handleClickOutside = React232.useCallback((e) => {
    var _rootRef_current, _calendarRef_current;
    if (!((_rootRef_current = rootRef.current) === null || _rootRef_current === void 0 ? void 0 : _rootRef_current.contains(e.target)) && !((_calendarRef_current = calendarRef.current) === null || _calendarRef_current === void 0 ? void 0 : _calendarRef_current.contains(e.target))) {
      isClickedOutsideRef.current = true;
      removeFocusFromField();
    }
  }, [
    removeFocusFromField
  ]);
  const selectFirst = React232.useCallback(() => {
    if (focusedElement !== null) {
      return;
    }
    setFocusedElement(0);
  }, [
    focusedElement
  ]);
  useGlobalEventListener(document2, "click", handleClickOutside, {
    capture: true
  });
  React232.useEffect(() => {
    setInternalValue(getInternalValue3(value));
  }, [
    getInternalValue3,
    value
  ]);
  React232.useEffect(() => {
    if (autoFocus) {
      selectFirst();
    }
  }, [
    autoFocus,
    selectFirst
  ]);
  React232.useEffect(() => {
    if (disabled || focusedElement === null) {
      return;
    }
    const range2 = window2.document.createRange();
    let element = refs[focusedElement].current;
    let timerId;
    if (element) {
      element.focus();
      if (!accessible) {
        _onCalendarOpen();
      }
      range2.selectNodeContents(element);
      timerId = setTimeout(() => {
        const selection = window2.getSelection();
        selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();
        selection === null || selection === void 0 ? void 0 : selection.addRange(range2);
      }, 0);
    }
    return () => {
      clearTimeout(timerId);
    };
  }, [
    disabled,
    focusedElement,
    refs,
    window2,
    _onCalendarOpen,
    accessible
  ]);
  const clear = React232.useCallback(() => {
    onClear === null || onClear === void 0 ? void 0 : onClear();
    selectFirst();
  }, [
    onClear,
    selectFirst
  ]);
  const handleFieldEnter = React232.useCallback(() => {
    selectFirst();
  }, [
    selectFirst
  ]);
  const handleKeyDown = React232.useCallback((e) => {
    if (focusedElement === null) {
      return;
    }
    const _value = [
      ...internalValue
    ];
    const config = elementsConfig3(focusedElement);
    if (/^\d+$/.test(e.key)) {
      if (_value[focusedElement].length >= config.length) {
        _value[focusedElement] = e.key;
      } else {
        _value[focusedElement] += e.key;
        if (_value[focusedElement].length >= config.length && focusedElement < maxElement) {
          setFocusedElement(focusedElement + 1);
        }
      }
    } else if (e.key === "Backspace") {
      if (!_value[focusedElement]) {
        setFocusedElement(focusedElement <= 0 ? maxElement : focusedElement - 1);
      } else {
        _value[focusedElement] = _value[focusedElement].slice(0, -1);
      }
    } else if (e.key === "ArrowDown" || e.key === "Down") {
      let currentValue = Number(_value[focusedElement]);
      _value[focusedElement] = String(currentValue <= config.min ? config.max : currentValue - 1).padStart(config.length, "0");
    } else if (e.key === "ArrowUp" || e.key === "Up") {
      let currentValue = Number(_value[focusedElement]);
      _value[focusedElement] = String(currentValue >= config.max ? config.min : currentValue + 1).padStart(config.length, "0");
    } else if (e.key === "ArrowLeft" || e.key === "Left" || e.key === "Tab" && e.shiftKey) {
      if (focusedElement <= 0) {
        if (e.key === "Tab") {
          removeFocusFromField();
        }
        return;
      }
      setFocusedElement(focusedElement - 1);
    } else if (e.key === "ArrowRight" || e.key === "Right" || e.key === "Tab") {
      if (focusedElement >= maxElement) {
        if (e.key === "Tab") {
          removeFocusFromField();
        }
        return;
      }
      setFocusedElement(focusedElement + 1);
    } else if (e.key === "Delete" || e.key === "Del") {
      _value[focusedElement] = "";
    } else if (e.key === " ") {
      e.preventDefault();
      _onCalendarOpen();
      return;
    } else {
      return;
    }
    e.preventDefault();
    setInternalValue(_value);
    onInternalValueChange(_value);
  }, [
    _onCalendarOpen,
    removeFocusFromField,
    elementsConfig3,
    focusedElement,
    internalValue,
    maxElement,
    onInternalValueChange
  ]);
  return {
    rootRef,
    calendarRef,
    open,
    openCalendar: _onCalendarOpen,
    closeCalendar: _onCalendarClose,
    toggleCalendar,
    internalValue,
    focusedElement,
    setFocusedElement,
    handleKeyDown,
    clear,
    handleFieldEnter,
    removeFocusFromField,
    handleRestoreFocus
  };
}

// node_modules/@vkontakte/vkui/dist/components/InputLike/InputLikeDivider.js
var import_jsx_runtime228 = __toESM(require_jsx_runtime(), 1);
var React233 = __toESM(require_react(), 1);
var InputLikeDivider = (_param) => {
  var { children, className } = _param, props = _object_without_properties(_param, [
    "children",
    "className"
  ]);
  return (0, import_jsx_runtime228.jsx)("span", _object_spread_props(_object_spread({
    className: clsx("vkuiInputLike__divider", className)
  }, props), {
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/NumberInputLike/NumberInputLike.js
var import_jsx_runtime230 = __toESM(require_jsx_runtime(), 1);

// node_modules/@vkontakte/vkui/dist/components/InputLike/InputLike.js
var import_jsx_runtime229 = __toESM(require_jsx_runtime(), 1);
var React234 = __toESM(require_react(), 1);
var MASK_SYMBOL = String.fromCharCode(8199);
function getMaskElements(length) {
  const result = [];
  for (let index2 = 0; index2 < length; index2 += 1) {
    result.push((0, import_jsx_runtime229.jsx)("span", {
      className: "vkuiInputLike__mask",
      children: MASK_SYMBOL
    }, index2));
  }
  return result;
}
var InputLike = (_param) => {
  var { value, length, index: index2, onElementSelect, onFocus, label, readOnly, onKeyDown } = _param, restProps = _object_without_properties(_param, [
    "value",
    "length",
    "index",
    "onElementSelect",
    "onFocus",
    "label",
    "readOnly",
    "onKeyDown"
  ]);
  const handleElementSelect = React234.useCallback((event) => {
    stopPropagation(event);
    onElementSelect === null || onElementSelect === void 0 ? void 0 : onElementSelect(index2);
  }, [
    index2,
    onElementSelect
  ]);
  var _value_length;
  return (0, import_jsx_runtime229.jsxs)(RootComponent, _object_spread_props(_object_spread({
    Component: "span",
    baseClassName: (value === null || value === void 0 ? void 0 : value.length) === length ? "vkuiInputLike__host" : void 0,
    tabIndex: readOnly ? -1 : 0,
    onFocus: callMultiple(onFocus, handleElementSelect),
    onKeyDown: readOnly ? void 0 : onKeyDown
  }, restProps), {
    children: [
      label && (0, import_jsx_runtime229.jsx)(VisuallyHidden, {
        children: label
      }),
      value === null || value === void 0 ? void 0 : value.slice(0, length - 1),
      (value === null || value === void 0 ? void 0 : value.slice(length - 1)) && (0, import_jsx_runtime229.jsx)("span", {
        className: "vkuiInputLike__lastCharacter",
        children: value.slice(length - 1)
      }, index2),
      getMaskElements(length - ((_value_length = value === null || value === void 0 ? void 0 : value.length) !== null && _value_length !== void 0 ? _value_length : 0))
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/NumberInputLike/NumberInputLike.js
var stringifyValue = (value, length) => {
  if (value === void 0) {
    return void 0;
  }
  if (typeof value === "string") {
    return value;
  }
  return String(value).padStart(length, "0");
};
var NumberInputLike = (_param) => {
  var { value, length, minValue, maxValue, readOnly, disabled, label, onKeyDown, "aria-label": ariaLabel } = _param, restProps = _object_without_properties(_param, [
    "value",
    "length",
    "minValue",
    "maxValue",
    "readOnly",
    "disabled",
    "label",
    "onKeyDown",
    "aria-label"
  ]);
  const stringValue = stringifyValue(value, length);
  return (0, import_jsx_runtime230.jsx)(InputLike, _object_spread({
    role: "spinbutton",
    value: stringValue,
    length,
    "aria-valuemin": minValue,
    "aria-valuemax": maxValue,
    "aria-valuenow": value !== void 0 ? Number(value) : void 0,
    "aria-valuetext": stringValue,
    "aria-readonly": readOnly,
    "aria-disabled": disabled,
    "aria-label": label,
    label,
    tabIndex: readOnly ? -1 : 0,
    onKeyDown: readOnly ? void 0 : onKeyDown
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/DateInput/hooks.js
var React235 = __toESM(require_react(), 1);
var _convertDateToTimeZone = (date, timezone) => {
  return convertDateToTimeZone(date, timezone) || null;
};
var _convertDateFromTimeZone = (date, timezone) => {
  return convertDateFromTimeZone(date, timezone);
};
var getStateValue = (defaultStateValue, value, defaultValue, timezone) => {
  if (value !== void 0) {
    return _convertDateToTimeZone(value, timezone);
  }
  if (defaultValue !== void 0) {
    return _convertDateToTimeZone(defaultValue, timezone);
  }
  return _convertDateToTimeZone(defaultStateValue, timezone);
};
var useDateInputValue = ({ value, defaultValue, onChange, timezone }) => {
  const [internalValue, setInternalValue] = React235.useState(getStateValue(null, value, defaultValue, timezone));
  const lastUpdatedValueRef = React235.useRef(getStateValue(null, value, defaultValue, timezone));
  const isControlled = value !== void 0;
  React235.useEffect(() => {
    if (isControlled) {
      const newInternalValue = _convertDateToTimeZone(value, timezone);
      setInternalValue(newInternalValue);
      lastUpdatedValueRef.current = newInternalValue;
    }
  }, [
    isControlled,
    timezone,
    value
  ]);
  const getLastUpdatedValue = React235.useCallback(() => lastUpdatedValueRef.current, []);
  const updateValue = React235.useCallback((newValue) => {
    if (!isControlled) {
      setInternalValue(newValue);
      lastUpdatedValueRef.current = newValue;
    }
    const originalTimezoneValue = _convertDateFromTimeZone(newValue, timezone);
    onChange === null || onChange === void 0 ? void 0 : onChange(originalTimezoneValue);
    return originalTimezoneValue;
  }, [
    isControlled,
    onChange,
    timezone
  ]);
  const clearValue = () => {
    setInternalValue(null);
    lastUpdatedValueRef.current = null;
    onChange === null || onChange === void 0 ? void 0 : onChange(void 0);
  };
  return {
    value: internalValue,
    updateValue,
    setInternalValue,
    getLastUpdatedValue,
    clearValue
  };
};

// node_modules/@vkontakte/vkui/dist/components/DateInput/DateInput.js
var sizeYClassNames38 = {
  none: "vkuiDateInput__sizeYNone",
  compact: "vkuiDateInput__sizeYCompact"
};
var elementsConfig = (index2) => {
  let length = 2;
  let min2 = 1;
  let max2 = 0;
  switch (index2) {
    case 0:
      max2 = 31;
      break;
    case 1:
      max2 = 12;
      break;
    case 2:
      max2 = 2100;
      min2 = 1900;
      length = 4;
      break;
    case 3:
      max2 = 23;
      break;
    case 4:
      max2 = 59;
      break;
  }
  return {
    length,
    min: min2,
    max: max2
  };
};
var getInternalValue = (value) => {
  const newValue = [
    "",
    "",
    "",
    "",
    ""
  ];
  if (value) {
    newValue[0] = String(value.getDate()).padStart(2, "0");
    newValue[1] = String(value.getMonth() + 1).padStart(2, "0");
    newValue[2] = String(value.getFullYear()).padStart(4, "0");
    newValue[3] = String(value.getHours()).padStart(2, "0");
    newValue[4] = String(value.getMinutes()).padStart(2, "0");
  }
  return newValue;
};
var CALENDAR_MUTATION_OBSERVER_OPTIONS = {
  childList: true,
  subtree: true,
  attributes: true,
  attributeFilter: [
    "tabindex"
  ]
};
var DateInput = (_param) => {
  var { enableTime, shouldDisableDate, disableFuture, disablePast, minDateTime, maxDateTime, "value": valueProp, defaultValue, onChange, "calendarPlacement": calendarPlacementProp = "bottom-start", style, className, doneButtonText, DoneButton, closeOnChange = true, disablePickers, getRootRef, name, autoFocus, disabled, accessible, calendarLabel = "Календарь", prevMonthLabel = "Предыдущий месяц", nextMonthLabel = "Следующий месяц", changeDayLabel = "День", changeMonthLabel = "Месяц", changeYearLabel = "Год", changeHoursLabel = "Час", changeMinutesLabel = "Минута", clearFieldLabel = "Очистить поле", showCalendarLabel = "Показать календарь", showNeighboringMonth, size: size5, viewDate, onHeaderChange, onNextMonth, onPrevMonth, prevMonthIcon, nextMonthIcon, renderDayContent, onCalendarOpenChanged, calendarTestsProps, dayFieldTestId, monthFieldTestId, yearFieldTestId, hourFieldTestId, minuteFieldTestId, showCalendarButtonTestId, clearButtonTestId, id, onApply, renderCustomValue, timezone, restoreFocus, disableFocusTrap, readOnly, "disableCalendar": disableCalendarProp = false, "aria-label": ariaLabel = "", before } = _param, props = _object_without_properties(_param, [
    "enableTime",
    "shouldDisableDate",
    "disableFuture",
    "disablePast",
    "minDateTime",
    "maxDateTime",
    "value",
    "defaultValue",
    "onChange",
    "calendarPlacement",
    "style",
    "className",
    "doneButtonText",
    "DoneButton",
    "closeOnChange",
    "disablePickers",
    "getRootRef",
    "name",
    "autoFocus",
    "disabled",
    "accessible",
    "calendarLabel",
    "prevMonthLabel",
    "nextMonthLabel",
    "changeDayLabel",
    "changeMonthLabel",
    "changeYearLabel",
    "changeHoursLabel",
    "changeMinutesLabel",
    "clearFieldLabel",
    "showCalendarLabel",
    "showNeighboringMonth",
    "size",
    "viewDate",
    "onHeaderChange",
    "onNextMonth",
    "onPrevMonth",
    "prevMonthIcon",
    "nextMonthIcon",
    "renderDayContent",
    "onCalendarOpenChanged",
    "calendarTestsProps",
    "dayFieldTestId",
    "monthFieldTestId",
    "yearFieldTestId",
    "hourFieldTestId",
    "minuteFieldTestId",
    "showCalendarButtonTestId",
    "clearButtonTestId",
    "id",
    "onApply",
    "renderCustomValue",
    "timezone",
    "restoreFocus",
    "disableFocusTrap",
    "readOnly",
    "disableCalendar",
    "aria-label",
    "before"
  ]);
  const daysRef = React236.useRef(null);
  const monthsRef = React236.useRef(null);
  const yearsRef = React236.useRef(null);
  const hoursRef = React236.useRef(null);
  const minutesRef = React236.useRef(null);
  const disableCalendar = readOnly ? true : disableCalendarProp;
  const { value, updateValue, setInternalValue, getLastUpdatedValue, clearValue } = useDateInputValue({
    value: valueProp,
    defaultValue,
    onChange,
    timezone
  });
  const maxElement = enableTime ? 4 : 2;
  const onInternalValueChange = React236.useCallback((internalValue2) => {
    for (let i = 0; i <= maxElement; i += 1) {
      if (internalValue2[i].length < elementsConfig(i).length) {
        return;
      }
    }
    let formattedValue = `${internalValue2[0]}.${internalValue2[1]}.${internalValue2[2]}`;
    let mask = "dd.MM.yyyy";
    if (enableTime) {
      formattedValue += ` ${internalValue2[3]}:${internalValue2[4]}`;
      mask += " HH:mm";
    }
    if (isMatch(formattedValue, mask)) {
      const now2 = /* @__PURE__ */ new Date();
      updateValue(parse(formattedValue, mask, value !== null && value !== void 0 ? value : enableTime ? startOfMinute(now2) : startOfDay(now2)));
    }
  }, [
    enableTime,
    maxElement,
    updateValue,
    value
  ]);
  const refs = React236.useMemo(() => [
    daysRef,
    monthsRef,
    yearsRef,
    hoursRef,
    minutesRef
  ], [
    daysRef,
    monthsRef,
    yearsRef,
    hoursRef,
    minutesRef
  ]);
  const { rootRef, calendarRef, open, internalValue, handleKeyDown, setFocusedElement, handleFieldEnter, clear, removeFocusFromField, closeCalendar, toggleCalendar, openCalendar, handleRestoreFocus } = useDateInput({
    maxElement,
    refs,
    autoFocus,
    disabled: disabled || readOnly,
    elementsConfig,
    onClear: clearValue,
    onInternalValueChange,
    getInternalValue,
    value,
    onCalendarOpenChanged,
    accessible
  });
  const { sizeY = "none" } = useAdaptivity();
  const handleRootRef = useExternRef(rootRef, getRootRef);
  useIsomorphicLayoutEffect(function resetValueOnCloseCalendar() {
    if (!open) {
      setInternalValue(getLastUpdatedValue());
    }
  }, [
    open,
    getLastUpdatedValue
  ]);
  const onCalendarChange = React236.useCallback((value2) => {
    if (!value2) {
      return;
    }
    if (enableTime) {
      setInternalValue(value2);
      return;
    }
    updateValue(value2);
    if (closeOnChange) {
      removeFocusFromField();
    }
  }, [
    enableTime,
    updateValue,
    closeOnChange,
    setInternalValue,
    removeFocusFromField
  ]);
  const onDoneButtonClick = React236.useCallback(() => {
    if (!value) {
      return;
    }
    const newValue = updateValue(value);
    onApply === null || onApply === void 0 ? void 0 : onApply(newValue);
    removeFocusFromField();
  }, [
    onApply,
    removeFocusFromField,
    updateValue,
    value
  ]);
  const customValue = React236.useMemo(() => !open && (renderCustomValue === null || renderCustomValue === void 0 ? void 0 : renderCustomValue(value || void 0)), [
    open,
    renderCustomValue,
    value
  ]);
  const [calendarPlacement, setCalendarPlacement] = React236.useState(calendarPlacementProp);
  const { locale } = useConfigProvider();
  const currentDateLabel = value ? new Intl.DateTimeFormat(locale, {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric"
  }).format(value) : null;
  const currentDateLabelId = React236.useId();
  const ariaLabelId = React236.useId();
  const showCalendarOnInputAreaClick = React236.useCallback(() => {
    handleFieldEnter();
    if (accessible) {
      openCalendar();
    }
  }, [
    handleFieldEnter,
    openCalendar,
    accessible
  ]);
  const showCalendarButton = !disableCalendar && (accessible || !accessible && !value);
  const showClearButton = value && !readOnly;
  return (0, import_jsx_runtime231.jsxs)(FormField, _object_spread_props(_object_spread({
    style,
    className: clsx(sizeY !== "regular" && sizeYClassNames38[sizeY], !!before && "vkuiDateInput__hasBefore", (showCalendarButton || showClearButton) && "vkuiDateInput__hasAfter", className),
    getRootRef: handleRootRef,
    role: "group",
    "aria-labelledby": `${ariaLabelId} ${currentDateLabelId}`,
    before,
    after: (0, import_jsx_runtime231.jsxs)(React236.Fragment, {
      children: [
        showCalendarButton ? (0, import_jsx_runtime231.jsx)(IconButton, {
          hoverMode: "opacity",
          label: showCalendarLabel,
          onClick: toggleCalendar,
          "data-testid": showCalendarButtonTestId,
          children: (0, import_jsx_runtime231.jsx)(Icon20CalendarOutline, {})
        }) : null,
        showClearButton ? (0, import_jsx_runtime231.jsx)(IconButton, {
          hoverMode: "opacity",
          label: clearFieldLabel,
          onClick: clear,
          "data-testid": clearButtonTestId,
          children: (0, import_jsx_runtime231.jsx)(Icon16Clear, {})
        }) : null
      ]
    }),
    disabled
  }, props), {
    children: [
      (0, import_jsx_runtime231.jsxs)("div", {
        className: "vkuiDateInput__wrapper",
        children: [
          ariaLabel && (0, import_jsx_runtime231.jsx)(VisuallyHidden, {
            id: ariaLabelId,
            children: ariaLabel
          }),
          currentDateLabel && (0, import_jsx_runtime231.jsx)(VisuallyHidden, {
            id: currentDateLabelId,
            children: currentDateLabel
          }),
          (0, import_jsx_runtime231.jsx)(VisuallyHidden, {
            id,
            Component: "input",
            readOnly: true,
            "aria-hidden": true,
            tabIndex: readOnly ? 0 : -1,
            name,
            value: value ? enableTime ? dateTimeFormatter.format(value) : dateFormatter.format(value) : "",
            onFocus: handleFieldEnter
          }),
          (0, import_jsx_runtime231.jsxs)(Text, {
            className: clsx("vkuiDateInput__input", customValue && "vkuiDateInput__hidden"),
            // Инцидент: в PR https://github.com/VKCOM/VKUI/pull/6649 стабильно ломается порядок стилей
            // из-за чего `.Typography--normalize` перебивает стили.
            normalize: false,
            Component: "span",
            onClick: showCalendarOnInputAreaClick,
            children: [
              (0, import_jsx_runtime231.jsx)(NumberInputLike, {
                value: internalValue[0],
                minValue: 1,
                maxValue: 31,
                length: 2,
                getRootRef: daysRef,
                index: 0,
                onKeyDown: handleKeyDown,
                onElementSelect: setFocusedElement,
                label: changeDayLabel,
                readOnly,
                "data-testid": dayFieldTestId
              }),
              (0, import_jsx_runtime231.jsx)(InputLikeDivider, {
                children: "."
              }),
              (0, import_jsx_runtime231.jsx)(NumberInputLike, {
                value: internalValue[1],
                minValue: 1,
                maxValue: 12,
                length: 2,
                getRootRef: monthsRef,
                index: 1,
                onElementSelect: setFocusedElement,
                onKeyDown: handleKeyDown,
                readOnly,
                label: changeMonthLabel,
                "data-testid": monthFieldTestId
              }),
              (0, import_jsx_runtime231.jsx)(InputLikeDivider, {
                children: "."
              }),
              (0, import_jsx_runtime231.jsx)(NumberInputLike, {
                value: internalValue[2],
                minValue: 1,
                maxValue: 275750,
                length: 4,
                getRootRef: yearsRef,
                index: 2,
                onElementSelect: setFocusedElement,
                readOnly,
                label: changeYearLabel,
                onKeyDown: handleKeyDown,
                "data-testid": yearFieldTestId
              }),
              enableTime && (0, import_jsx_runtime231.jsxs)(React236.Fragment, {
                children: [
                  (0, import_jsx_runtime231.jsx)(InputLikeDivider, {
                    className: "vkuiDateInput__inputTimeDivider",
                    children: " "
                  }),
                  (0, import_jsx_runtime231.jsx)(NumberInputLike, {
                    value: internalValue[3],
                    minValue: 1,
                    maxValue: 24,
                    length: 2,
                    getRootRef: hoursRef,
                    index: 3,
                    onElementSelect: setFocusedElement,
                    readOnly,
                    label: changeHoursLabel,
                    onKeyDown: handleKeyDown,
                    "data-testid": hourFieldTestId
                  }),
                  (0, import_jsx_runtime231.jsx)(InputLikeDivider, {
                    children: ":"
                  }),
                  (0, import_jsx_runtime231.jsx)(NumberInputLike, {
                    value: internalValue[4],
                    minValue: 1,
                    maxValue: 59,
                    length: 2,
                    getRootRef: minutesRef,
                    index: 4,
                    onElementSelect: setFocusedElement,
                    readOnly,
                    label: changeMinutesLabel,
                    onKeyDown: handleKeyDown,
                    "data-testid": minuteFieldTestId
                  })
                ]
              })
            ]
          }),
          customValue && (0, import_jsx_runtime231.jsx)(Text, {
            className: "vkuiDateInput__customValue",
            "aria-hidden": true,
            normalize: false,
            children: customValue
          })
        ]
      }),
      open && !disableCalendar && (0, import_jsx_runtime231.jsx)(Popper, {
        targetRef: rootRef,
        offsetByMainAxis: 8,
        placement: calendarPlacement,
        onPlacementChange: setCalendarPlacement,
        autoUpdateOnTargetResize: true,
        children: (0, import_jsx_runtime231.jsx)(FocusTrap, {
          onClose: closeCalendar,
          disabled: disableFocusTrap !== null && disableFocusTrap !== void 0 ? disableFocusTrap : !accessible,
          restoreFocus: restoreFocus !== null && restoreFocus !== void 0 ? restoreFocus : Boolean(accessible) && handleRestoreFocus,
          captureEscapeKeyboardEvent: false,
          mutationObserverOptions: CALENDAR_MUTATION_OBSERVER_OPTIONS,
          children: (0, import_jsx_runtime231.jsx)(Calendar, _object_spread({
            "aria-label": calendarLabel,
            role: "dialog",
            value,
            onChange: onCalendarChange,
            enableTime,
            disablePast,
            disableFuture,
            shouldDisableDate,
            onDoneButtonClick,
            getRootRef: calendarRef,
            doneButtonText,
            DoneButton,
            disablePickers,
            changeHoursLabel,
            changeMinutesLabel,
            prevMonthLabel,
            nextMonthLabel,
            changeMonthLabel,
            changeYearLabel,
            showNeighboringMonth,
            renderDayContent,
            size: size5,
            viewDate,
            onHeaderChange,
            onNextMonth,
            onPrevMonth,
            prevMonthIcon,
            nextMonthIcon,
            minDateTime,
            maxDateTime
          }, calendarTestsProps))
        })
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/DateRangeInput/DateRangeInput.js
var import_jsx_runtime232 = __toESM(require_jsx_runtime(), 1);
var React237 = __toESM(require_react(), 1);
var sizeYClassNames39 = {
  none: "vkuiDateInput__sizeYNone",
  compact: "vkuiDateInput__sizeYCompact"
};
var elementsConfig2 = (index2) => {
  let length = 2;
  let min2 = 1;
  let max2 = 0;
  switch (index2) {
    case 0:
    case 3:
      max2 = 31;
      break;
    case 1:
    case 4:
      max2 = 12;
      break;
    case 2:
    case 5:
      max2 = 2100;
      min2 = 1900;
      length = 4;
      break;
  }
  return {
    length,
    min: min2,
    max: max2
  };
};
var getInternalValue2 = (value) => {
  const newValue = [
    "",
    "",
    "",
    "",
    "",
    ""
  ];
  if (value === null || value === void 0 ? void 0 : value[0]) {
    newValue[0] = String(value[0].getDate()).padStart(2, "0");
    newValue[1] = String(value[0].getMonth() + 1).padStart(2, "0");
    newValue[2] = String(value[0].getFullYear()).padStart(4, "0");
  }
  if (value === null || value === void 0 ? void 0 : value[1]) {
    newValue[3] = String(value[1].getDate()).padStart(2, "0");
    newValue[4] = String(value[1].getMonth() + 1).padStart(2, "0");
    newValue[5] = String(value[1].getFullYear()).padStart(4, "0");
  }
  return newValue;
};
var CALENDAR_MUTATION_OBSERVER_OPTIONS2 = {
  childList: true,
  subtree: true,
  attributes: true,
  attributeFilter: [
    "tabindex"
  ]
};
var DateRangeInput = (_param) => {
  var { shouldDisableDate, disableFuture, disablePast, "value": valueProp, defaultValue, onChange, "calendarPlacement": calendarPlacementProp = "bottom-start", style, className, closeOnChange = true, disablePickers, getRootRef, name, autoFocus, disabled, disableFocusTrap, restoreFocus, calendarLabel = "Календарь", prevMonthLabel = "Предыдущий месяц", nextMonthLabel = "Следующий месяц", changeMonthLabel = "Месяц", changeYearLabel = "Год", changeStartDayLabel = "День начала", changeStartMonthLabel = "Месяц начала", changeStartYearLabel = "Год начала", changeEndDayLabel = "День окончания", changeEndMonthLabel = "Месяц окончания", changeEndYearLabel = "Год окончания", clearFieldLabel = "Очистить поле", showCalendarLabel = "Показать календарь", "aria-label": ariaLabel = "", prevMonthIcon, nextMonthIcon, onCalendarOpenChanged, renderDayContent, calendarTestsProps, startDateTestsProps, endDateTestsProps, clearButtonTestId, showCalendarButtonTestId, id, accessible, readOnly, "disableCalendar": disableCalendarProp = false, before } = _param, props = _object_without_properties(_param, [
    "shouldDisableDate",
    "disableFuture",
    "disablePast",
    "value",
    "defaultValue",
    "onChange",
    "calendarPlacement",
    "style",
    "className",
    "closeOnChange",
    "disablePickers",
    "getRootRef",
    "name",
    "autoFocus",
    "disabled",
    "disableFocusTrap",
    "restoreFocus",
    "calendarLabel",
    "prevMonthLabel",
    "nextMonthLabel",
    "changeMonthLabel",
    "changeYearLabel",
    "changeStartDayLabel",
    "changeStartMonthLabel",
    "changeStartYearLabel",
    "changeEndDayLabel",
    "changeEndMonthLabel",
    "changeEndYearLabel",
    "clearFieldLabel",
    "showCalendarLabel",
    "aria-label",
    "prevMonthIcon",
    "nextMonthIcon",
    "onCalendarOpenChanged",
    "renderDayContent",
    "calendarTestsProps",
    "startDateTestsProps",
    "endDateTestsProps",
    "clearButtonTestId",
    "showCalendarButtonTestId",
    "id",
    "accessible",
    "readOnly",
    "disableCalendar",
    "before"
  ]);
  const daysStartRef = React237.useRef(null);
  const monthsStartRef = React237.useRef(null);
  const yearsStartRef = React237.useRef(null);
  const daysEndRef = React237.useRef(null);
  const monthsEndRef = React237.useRef(null);
  const yearsEndRef = React237.useRef(null);
  const disableCalendar = readOnly ? true : disableCalendarProp;
  const _onChange = React237.useCallback((newValue) => onChange === null || onChange === void 0 ? void 0 : onChange(newValue || void 0), [
    onChange
  ]);
  const [value, updateValue] = useCustomEnsuredControl({
    value: valueProp,
    defaultValue,
    onChange: _onChange
  });
  const onInternalValueChange = React237.useCallback((internalValue2) => {
    let isStartValid = true;
    let isEndValid = true;
    for (let i = 0; i <= 2; i += 1) {
      if (internalValue2[i].length < elementsConfig2(i).length) {
        isStartValid = false;
      }
    }
    for (let i = 3; i <= 5; i += 1) {
      if (internalValue2[i].length < elementsConfig2(i).length) {
        isEndValid = false;
      }
    }
    const formattedStartValue = `${internalValue2[0]}.${internalValue2[1]}.${internalValue2[2]}`;
    const formattedEndValue = `${internalValue2[3]}.${internalValue2[4]}.${internalValue2[5]}`;
    const mask = "dd.MM.yyyy";
    if (!isMatch(formattedStartValue, mask)) {
      isStartValid = false;
    }
    if (!isMatch(formattedEndValue, mask)) {
      isEndValid = false;
    }
    if (!isStartValid && !isEndValid) {
      return;
    }
    const valueExists = Array.isArray(value);
    const now2 = /* @__PURE__ */ new Date();
    const start = isStartValid ? parse(formattedStartValue, mask, valueExists && (value === null || value === void 0 ? void 0 : value[0]) || now2) : null;
    const end = isEndValid ? parse(formattedEndValue, mask, valueExists && (value === null || value === void 0 ? void 0 : value[1]) || now2) : null;
    if (start && end && end > start) {
      updateValue([
        start,
        end
      ]);
    }
  }, [
    updateValue,
    value
  ]);
  const refs = React237.useMemo(() => [
    daysStartRef,
    monthsStartRef,
    yearsStartRef,
    daysEndRef,
    monthsEndRef,
    yearsEndRef
  ], [
    daysStartRef,
    monthsStartRef,
    yearsStartRef,
    daysEndRef,
    monthsEndRef,
    yearsEndRef
  ]);
  const onClear = React237.useCallback(() => updateValue(void 0), [
    updateValue
  ]);
  const { rootRef, calendarRef, open, openCalendar, closeCalendar, toggleCalendar, internalValue, handleKeyDown, setFocusedElement, handleFieldEnter, clear, removeFocusFromField } = useDateInput({
    maxElement: 5,
    refs,
    autoFocus,
    disabled: disabled || readOnly,
    elementsConfig: elementsConfig2,
    onClear,
    onInternalValueChange,
    getInternalValue: getInternalValue2,
    value,
    onCalendarOpenChanged,
    accessible
  });
  const { sizeY = "none" } = useAdaptivity();
  const handleRootRef = useExternRef(rootRef, getRootRef);
  const onCalendarChange = React237.useCallback((newValue) => {
    updateValue(newValue);
    if (closeOnChange && (newValue === null || newValue === void 0 ? void 0 : newValue[1]) && newValue[1] !== (value === null || value === void 0 ? void 0 : value[1])) {
      removeFocusFromField();
    }
  }, [
    updateValue,
    closeOnChange,
    value,
    removeFocusFromField
  ]);
  const [calendarPlacement, setCalendarPlacement] = React237.useState(calendarPlacementProp);
  const { locale } = useConfigProvider();
  const currentDateLabel = React237.useMemo(() => {
    if (!value) {
      return null;
    }
    const [startDate, endDate] = value;
    if (!startDate || !endDate) {
      return null;
    }
    return [
      new Intl.DateTimeFormat(locale, {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric"
      }).format(startDate),
      new Intl.DateTimeFormat(locale, {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric"
      }).format(endDate)
    ].join(" - ");
  }, [
    locale,
    value
  ]);
  const currentDateLabelId = React237.useId();
  const ariaLabelId = React237.useId();
  const showCalendarOnInputAreaClick = React237.useCallback(() => {
    handleFieldEnter();
    if (accessible) {
      openCalendar();
    }
  }, [
    handleFieldEnter,
    openCalendar,
    accessible
  ]);
  const showCalendarButton = !disableCalendar && (accessible || !accessible && !value);
  const showClearButton = value && !readOnly;
  return (0, import_jsx_runtime232.jsxs)(FormField, _object_spread_props(_object_spread({
    style,
    className: clsx(sizeY !== "regular" && sizeYClassNames39[sizeY], !!before && "vkuiDateInput__hasBefore", (showCalendarButton || showClearButton) && "vkuiDateInput__hasAfter", className),
    getRootRef: handleRootRef,
    role: "group",
    "aria-labelledby": `${ariaLabelId} ${currentDateLabelId}`,
    before,
    after: (0, import_jsx_runtime232.jsxs)(import_jsx_runtime232.Fragment, {
      children: [
        showCalendarButton ? (0, import_jsx_runtime232.jsx)(IconButton, {
          hoverMode: "opacity",
          label: showCalendarLabel,
          onClick: toggleCalendar,
          "data-testid": showCalendarButtonTestId,
          children: (0, import_jsx_runtime232.jsx)(Icon20CalendarOutline, {})
        }) : null,
        showClearButton ? (0, import_jsx_runtime232.jsx)(IconButton, {
          hoverMode: "opacity",
          label: clearFieldLabel,
          onClick: clear,
          "data-testid": clearButtonTestId,
          children: (0, import_jsx_runtime232.jsx)(Icon16Clear, {})
        }) : null
      ]
    }),
    disabled
  }, props), {
    children: [
      (0, import_jsx_runtime232.jsxs)("div", {
        className: "vkuiDateInput__wrapper",
        children: [
          ariaLabel && (0, import_jsx_runtime232.jsx)(VisuallyHidden, {
            id: ariaLabelId,
            children: ariaLabel
          }),
          currentDateLabel && (0, import_jsx_runtime232.jsx)(VisuallyHidden, {
            id: currentDateLabelId,
            children: currentDateLabel
          }),
          (0, import_jsx_runtime232.jsx)(VisuallyHidden, {
            id,
            Component: "input",
            readOnly: true,
            "aria-hidden": true,
            name,
            tabIndex: readOnly ? 0 : -1,
            value: value ? `${value[0] ? dateFormatter.format(value[0]) : ""} - ${value[1] ? dateFormatter.format(value[1]) : ""}` : "",
            onFocus: handleFieldEnter
          }),
          (0, import_jsx_runtime232.jsxs)(Text, {
            className: "vkuiDateInput__input",
            onClick: showCalendarOnInputAreaClick,
            normalize: false,
            children: [
              (0, import_jsx_runtime232.jsx)(NumberInputLike, {
                value: internalValue[0],
                minValue: 1,
                maxValue: 31,
                onKeyDown: readOnly ? void 0 : handleKeyDown,
                length: 2,
                getRootRef: daysStartRef,
                index: 0,
                readOnly,
                onElementSelect: setFocusedElement,
                label: changeStartDayLabel,
                "data-testid": startDateTestsProps === null || startDateTestsProps === void 0 ? void 0 : startDateTestsProps.day
              }),
              (0, import_jsx_runtime232.jsx)(InputLikeDivider, {
                children: "."
              }),
              (0, import_jsx_runtime232.jsx)(NumberInputLike, {
                value: internalValue[1],
                minValue: 1,
                maxValue: 12,
                onKeyDown: handleKeyDown,
                length: 2,
                getRootRef: monthsStartRef,
                index: 1,
                onElementSelect: setFocusedElement,
                readOnly,
                label: changeStartMonthLabel,
                "data-testid": startDateTestsProps === null || startDateTestsProps === void 0 ? void 0 : startDateTestsProps.month
              }),
              (0, import_jsx_runtime232.jsx)(InputLikeDivider, {
                children: "."
              }),
              (0, import_jsx_runtime232.jsx)(NumberInputLike, {
                value: internalValue[2],
                minValue: 1,
                maxValue: 275750,
                onKeyDown: handleKeyDown,
                length: 4,
                getRootRef: yearsStartRef,
                index: 2,
                onElementSelect: setFocusedElement,
                readOnly,
                label: changeStartYearLabel,
                "data-testid": startDateTestsProps === null || startDateTestsProps === void 0 ? void 0 : startDateTestsProps.year
              }),
              (0, import_jsx_runtime232.jsx)(InputLikeDivider, {
                children: " — "
              }),
              (0, import_jsx_runtime232.jsx)(NumberInputLike, {
                value: internalValue[3],
                minValue: 1,
                maxValue: 31,
                onKeyDown: handleKeyDown,
                length: 2,
                getRootRef: daysEndRef,
                index: 3,
                onElementSelect: setFocusedElement,
                readOnly,
                label: changeEndDayLabel,
                "data-testid": endDateTestsProps === null || endDateTestsProps === void 0 ? void 0 : endDateTestsProps.day
              }),
              (0, import_jsx_runtime232.jsx)(InputLikeDivider, {
                children: "."
              }),
              (0, import_jsx_runtime232.jsx)(NumberInputLike, {
                value: internalValue[4],
                minValue: 1,
                maxValue: 12,
                onKeyDown: handleKeyDown,
                length: 2,
                getRootRef: monthsEndRef,
                index: 4,
                onElementSelect: setFocusedElement,
                readOnly,
                label: changeEndMonthLabel,
                "data-testid": endDateTestsProps === null || endDateTestsProps === void 0 ? void 0 : endDateTestsProps.month
              }),
              (0, import_jsx_runtime232.jsx)(InputLikeDivider, {
                children: "."
              }),
              (0, import_jsx_runtime232.jsx)(NumberInputLike, {
                value: internalValue[5],
                minValue: 1,
                maxValue: 275750,
                onKeyDown: handleKeyDown,
                length: 4,
                getRootRef: yearsEndRef,
                index: 5,
                onElementSelect: setFocusedElement,
                readOnly,
                label: changeEndYearLabel,
                "data-testid": endDateTestsProps === null || endDateTestsProps === void 0 ? void 0 : endDateTestsProps.year
              })
            ]
          })
        ]
      }),
      open && !disableCalendar && (0, import_jsx_runtime232.jsx)(Popper, {
        targetRef: rootRef,
        offsetByMainAxis: 8,
        placement: calendarPlacement,
        onPlacementChange: setCalendarPlacement,
        children: (0, import_jsx_runtime232.jsx)(FocusTrap, {
          onClose: closeCalendar,
          disabled: disableFocusTrap !== null && disableFocusTrap !== void 0 ? disableFocusTrap : !accessible,
          restoreFocus: restoreFocus !== null && restoreFocus !== void 0 ? restoreFocus : Boolean(accessible),
          captureEscapeKeyboardEvent: false,
          mutationObserverOptions: CALENDAR_MUTATION_OBSERVER_OPTIONS2,
          children: (0, import_jsx_runtime232.jsx)(CalendarRange, _object_spread({
            value,
            role: "dialog",
            onChange: onCalendarChange,
            "aria-label": calendarLabel,
            disablePast,
            disableFuture,
            shouldDisableDate,
            getRootRef: calendarRef,
            disablePickers,
            prevMonthLabel,
            nextMonthLabel,
            changeMonthLabel,
            changeYearLabel,
            prevMonthIcon,
            nextMonthIcon,
            renderDayContent
          }, calendarTestsProps))
        })
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Skeleton/Skeleton.js
var import_jsx_runtime233 = __toESM(require_jsx_runtime(), 1);
var React238 = __toESM(require_react(), 1);
var CUSTOM_PROPERTY_GRADIENT_LEFT = "--vkui_internal--skeleton_gradient_left";
function useSkeletonSyncAnimation(disableAnimation, duration = 1.5) {
  const [isAnimationStarted, setIsAnimationStarted] = React238.useState(false);
  const timer = React238.useRef(void 0);
  const syncAnimation = React238.useCallback(() => {
    clearTimeout(timer.current);
    setIsAnimationStarted(false);
    const durationInMilliseconds = duration * millisecondsInSecond;
    const delay = durationInMilliseconds - performance.now() % durationInMilliseconds;
    timer.current = setTimeout(() => setIsAnimationStarted(true), delay);
    return () => clearTimeout(timer.current);
  }, [
    duration
  ]);
  React238.useEffect(() => {
    if (disableAnimation) {
      setIsAnimationStarted(false);
      return;
    }
    if (isAnimationStarted) {
      return;
    }
    return syncAnimation();
  }, [
    disableAnimation,
    isAnimationStarted,
    syncAnimation
  ]);
  return isAnimationStarted;
}
function useSkeletonPosition(rootRef) {
  const { document: document2, window: window2 } = useDOM();
  const [[skeletonGradientLeft, prevSkeletonGradientLeft], setSkeletonGradientLeft] = useStateWithPrev("0");
  const updatePosition = React238.useCallback(() => {
    const el = rootRef.current;
    if (!el || !document2) {
      return;
    }
    const value = -(el.getBoundingClientRect().left - document2.body.getBoundingClientRect().left);
    const gradientValue = value === 0 ? "0" : `${value}px`;
    if (prevSkeletonGradientLeft !== gradientValue) {
      setSkeletonGradientLeft(gradientValue);
    }
  }, [
    document2,
    prevSkeletonGradientLeft,
    rootRef,
    setSkeletonGradientLeft
  ]);
  React238.useEffect(updatePosition, [
    updatePosition
  ]);
  useResizeObserver(window2, updatePosition);
  return skeletonGradientLeft;
}
var Skeleton = (_param) => {
  var { width, height, inlineSize, blockSize, maxWidth, maxInlineSize, borderRadius, children, colorFrom, colorTo, noAnimation = false, duration, margin, getRootRef, visibilityDelay } = _param, restProps = _object_without_properties(_param, [
    "width",
    "height",
    "inlineSize",
    "blockSize",
    "maxWidth",
    "maxInlineSize",
    "borderRadius",
    "children",
    "colorFrom",
    "colorTo",
    "noAnimation",
    "duration",
    "margin",
    "getRootRef",
    "visibilityDelay"
  ]);
  const rootRef = useExternRef(getRootRef);
  const disableAnimation = !useSkeletonSyncAnimation(noAnimation, duration);
  const skeletonGradientLeft = useSkeletonPosition(rootRef);
  const skeletonStyle = {
    width,
    height,
    inlineSize,
    blockSize,
    maxWidth,
    maxInlineSize,
    borderRadius,
    margin,
    [CUSTOM_PROPERTY_GRADIENT_LEFT]: skeletonGradientLeft
  };
  if (colorFrom) {
    skeletonStyle["--vkui_internal--skeleton_color_from"] = colorFrom;
  }
  if (colorTo) {
    skeletonStyle["--vkui_internal--skeleton_color_to"] = colorTo;
  }
  if (Number.isFinite(duration)) {
    skeletonStyle["--vkui_internal--skeleton_animation_duration"] = `${duration}s`;
  }
  return (0, import_jsx_runtime233.jsx)(RootComponent, _object_spread_props(_object_spread({
    getRootRef: rootRef,
    Component: "span",
    baseClassName: clsx("vkuiSkeleton__host", disableAnimation && "vkuiSkeleton__disableAnimation", visibilityDelay && "vkuistyles__visibilityDelay"),
    baseStyle: mergeStyle(skeletonStyle, animationVisibilityDelayStyles(visibilityDelay))
  }, restProps), {
    children: children || (0, import_jsx_runtime233.jsx)(import_jsx_runtime233.Fragment, {
      children: "‌"
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Div/Div.js
var import_jsx_runtime234 = __toESM(require_jsx_runtime(), 1);
var React239 = __toESM(require_react(), 1);
var warn38 = warnOnce("Div");
var Div = (props) => {
  if (true) {
    warn38("Компонент Div устарел, используйте компонент Box в качестве альтернативы.");
  }
  return (0, import_jsx_runtime234.jsx)(RootComponent, _object_spread({
    baseClassName: "vkuiDiv__host"
  }, props));
};

// node_modules/@vkontakte/vkui/dist/components/PanelSpinner/PanelSpinner.js
var import_jsx_runtime235 = __toESM(require_jsx_runtime(), 1);
var React240 = __toESM(require_react(), 1);
var PanelSpinner = React240.memo((_param) => {
  var { height = 96, style } = _param, restProps = _object_without_properties(_param, [
    "height",
    "style"
  ]);
  return (0, import_jsx_runtime235.jsx)(Spinner, _object_spread_props(_object_spread({
    size: "m"
  }, restProps), {
    style: _object_spread({
      height
    }, style)
  }));
});
if (true) {
  defineComponentDisplayNames(PanelSpinner, "PanelSpinner");
}

// node_modules/@vkontakte/vkui/dist/components/PanelHeaderClose/PanelHeaderClose.js
var import_jsx_runtime236 = __toESM(require_jsx_runtime(), 1);
var PanelHeaderClose = (_param) => {
  var { label = "Отмена" } = _param, restProps = _object_without_properties(_param, [
    "label"
  ]);
  const platform3 = usePlatform();
  return (0, import_jsx_runtime236.jsx)(PanelHeaderButton, _object_spread_props(_object_spread({}, restProps), {
    label: platform3 === "ios" ? label : label && (0, import_jsx_runtime236.jsx)(VisuallyHidden, {
      children: label
    }),
    children: platform3 !== "ios" && (0, import_jsx_runtime236.jsx)(AdaptiveIconRenderer, {
      IconCompact: Icon24CancelOutline,
      IconRegular: Icon28CancelOutline
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeaderBack/PanelHeaderBack.js
var import_jsx_runtime237 = __toESM(require_jsx_runtime(), 1);
var React241 = __toESM(require_react(), 1);
var sizeXClassNames7 = {
  none: "vkuiPanelHeaderButton__backSizeXNone",
  compact: "vkuiPanelHeaderButton__backSizeXCompact"
};
var getBackIcon = (platform3) => {
  switch (platform3) {
    case "ios":
      return (0, import_jsx_runtime237.jsx)(Icon28ChevronBack, {});
    case "vkcom":
      return (0, import_jsx_runtime237.jsx)(AdaptiveIconRenderer, {
        IconCompact: Icon20ChevronLeftOutline,
        IconRegular: Icon28ChevronLeftOutline
      });
    default:
      return (0, import_jsx_runtime237.jsx)(AdaptiveIconRenderer, {
        IconCompact: Icon24ArrowLeftOutline,
        IconRegular: Icon28ArrowLeftOutline
      });
  }
};
var PanelHeaderBack = (_param) => {
  var { label = "Назад", className, hideLabelOnVKCom = false, hideLabelOnIOS = false } = _param, restProps = _object_without_properties(_param, [
    "label",
    "className",
    "hideLabelOnVKCom",
    "hideLabelOnIOS"
  ]);
  const platform3 = usePlatform();
  const direction = useConfigDirection();
  const { sizeX = "none" } = useAdaptivity();
  const showLabel = platform3 === "vkcom" && !hideLabelOnVKCom || platform3 === "ios" && !hideLabelOnIOS;
  return (0, import_jsx_runtime237.jsx)(PanelHeaderButton, _object_spread_props(_object_spread({}, restProps), {
    className: clsx(sizeX !== "regular" && sizeXClassNames7[sizeX], platform3 === "ios" && "vkuiPanelHeaderButton__backIos", platform3 === "vkcom" && "vkuiPanelHeaderButton__backVkcom", showLabel && !!label && "vkuiPanelHeaderButton__backHasLabel", direction === "rtl" && "vkuiPanelHeaderButton__rtl", className),
    label: showLabel ? label : label && (0, import_jsx_runtime237.jsx)(VisuallyHidden, {
      children: label
    }),
    children: getBackIcon(platform3)
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeaderSubmit/PanelHeaderSubmit.js
var import_jsx_runtime238 = __toESM(require_jsx_runtime(), 1);
var PanelHeaderSubmit = (_param) => {
  var { label = "Готово" } = _param, restProps = _object_without_properties(_param, [
    "label"
  ]);
  const platform3 = usePlatform();
  return (0, import_jsx_runtime238.jsx)(PanelHeaderButton, _object_spread_props(_object_spread({
    primary: true,
    label: platform3 === "ios" ? label : label && (0, import_jsx_runtime238.jsx)(VisuallyHidden, {
      children: label
    })
  }, restProps), {
    children: platform3 !== "ios" && (0, import_jsx_runtime238.jsx)(AdaptiveIconRenderer, {
      IconCompact: Icon24DoneOutline,
      IconRegular: Icon28DoneOutline
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeaderEdit/PanelHeaderEdit.js
var import_jsx_runtime239 = __toESM(require_jsx_runtime(), 1);
var React242 = __toESM(require_react(), 1);
var PanelHeaderEdit = (_param) => {
  var { isActive = false, editLabel = "Редактировать", doneLabel = "Готово" } = _param, restProps = _object_without_properties(_param, [
    "isActive",
    "editLabel",
    "doneLabel"
  ]);
  const platform3 = usePlatform();
  const label = isActive ? doneLabel : editLabel;
  return (0, import_jsx_runtime239.jsx)(PanelHeaderButton, _object_spread_props(_object_spread({}, restProps), {
    label: platform3 === "ios" ? label : label && (0, import_jsx_runtime239.jsx)(VisuallyHidden, {
      children: label
    }),
    children: platform3 !== "ios" && (0, import_jsx_runtime239.jsx)(AdaptiveIconRenderer, {
      IconCompact: isActive ? Icon24DoneOutline : Icon24PenOutline,
      IconRegular: isActive ? Icon28DoneOutline : Icon28EditOutline
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ConfigProvider/ConfigProvider.js
var import_jsx_runtime240 = __toESM(require_jsx_runtime(), 1);
var React245 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hooks/useAutoDetectColorScheme.js
var React243 = __toESM(require_react(), 1);
var useAutoDetectColorScheme = (colorSchemeProp) => {
  const { window: window2 } = useDOM();
  const [colorScheme, setColorScheme] = React243.useState(colorSchemeProp || ColorScheme.LIGHT);
  useIsomorphicLayoutEffect(() => {
    if (colorSchemeProp) {
      setColorScheme(colorSchemeProp);
      return noop;
    }
    const mediaQuery = window2 ? window2.matchMedia("(prefers-color-scheme: dark)") : void 0;
    if (!mediaQuery) {
      return noop;
    }
    const check = (event) => {
      setColorScheme(event.matches ? ColorScheme.DARK : ColorScheme.LIGHT);
    };
    check(mediaQuery);
    matchMediaListAddListener(mediaQuery, check);
    return () => matchMediaListRemoveListener(mediaQuery, check);
  }, [
    window2,
    colorSchemeProp
  ]);
  return colorScheme;
};

// node_modules/@vkontakte/vkui/dist/hooks/useAutoDetectDirection.js
var React244 = __toESM(require_react(), 1);
var useAutoDetectDirection = (directionProp) => {
  const { window: window2, document: document2 } = useDOM();
  return React244.useMemo(() => {
    if (directionProp) {
      return directionProp;
    }
    if (!window2 || !document2) {
      return "ltr";
    }
    const styleDeclaration = window2.getComputedStyle(document2.body);
    return styleDeclaration.direction || "ltr";
  }, [
    directionProp,
    document2,
    window2
  ]);
};

// node_modules/@vkontakte/vkui/dist/components/ConfigProvider/ConfigProvider.js
var ConfigProvider = (propsRaw) => {
  const props = excludeKeysWithUndefined(propsRaw);
  const parentConfig = useConfigProvider();
  const mergeProps = _object_spread({}, parentConfig, props);
  const colorScheme = useAutoDetectColorScheme(mergeProps.colorScheme);
  const direction = useAutoDetectDirection(mergeProps.direction);
  const configContext = useConfigProviderContextMemo(_object_spread_props(_object_spread({}, mergeProps), {
    colorScheme,
    direction
  }));
  return (0, import_jsx_runtime240.jsx)(ConfigProviderContext.Provider, {
    value: configContext,
    children: (0, import_jsx_runtime240.jsx)(IconAppearanceProvider, {
      value: colorScheme,
      children: (0, import_jsx_runtime240.jsx)(TokensClassProvider, {
        children: mergeProps.children
      })
    })
  });
};

// node_modules/@vkontakte/vkui/dist/components/LocaleProvider/LocaleProvider.js
var import_jsx_runtime241 = __toESM(require_jsx_runtime(), 1);
var React246 = __toESM(require_react(), 1);
function LocaleProvider({ value, children }) {
  return (0, import_jsx_runtime241.jsx)(ConfigProviderOverride, {
    locale: value,
    children
  });
}

// node_modules/@vkontakte/vkui/dist/components/DirectionProvider/DirectionProvider.js
var import_jsx_runtime242 = __toESM(require_jsx_runtime(), 1);
var React247 = __toESM(require_react(), 1);
function DirectionProvider({ value, children }) {
  return (0, import_jsx_runtime242.jsx)(ConfigProviderOverride, {
    direction: value,
    children
  });
}

// node_modules/@vkontakte/vkui/dist/components/PlatformProvider/PlatformProvider.js
var import_jsx_runtime243 = __toESM(require_jsx_runtime(), 1);
var React248 = __toESM(require_react(), 1);
function PlatformProvider({ value, children }) {
  return (0, import_jsx_runtime243.jsx)(ConfigProviderOverride, {
    platform: value,
    children: (0, import_jsx_runtime243.jsx)(TokensClassProvider, {
      children
    })
  });
}

// node_modules/@vkontakte/vkui/dist/components/Popover/Popover.js
var import_jsx_runtime245 = __toESM(require_jsx_runtime(), 1);
var React250 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/components/Popover/usePopover.js
var import_jsx_runtime244 = __toESM(require_jsx_runtime(), 1);
var import_react28 = __toESM(require_react(), 1);
var React249 = __toESM(require_react(), 1);
var usePopover = (_param) => {
  var {
    // UsePopoverProps
    arrow: withArrow,
    arrowHeight = DEFAULT_ARROW_HEIGHT,
    arrowPadding = DEFAULT_ARROW_PADDING,
    placement = "bottom-start",
    onPlacementChange,
    disableFlipMiddleware = false,
    disableShiftMiddleware = false,
    trigger = "click",
    strategy,
    content,
    hoverDelay = 150,
    closeAfterClick,
    offsetByMainAxis = 8,
    offsetByCrossAxis = 0,
    sameWidth,
    hideWhenReferenceHidden,
    onReferenceHiddenChange,
    disabled,
    disableInteractive,
    disableCloseOnClickOutside,
    disableCloseOnEscKey,
    keepMounted = false,
    customMiddlewares,
    // uncontrolled
    defaultShown = false,
    // controlled
    shown: shownProp,
    onShownChange,
    onShownChanged,
    // Для AppRootPortal
    usePortal = true,
    // Для FloatingArrow
    arrowProps,
    ArrowIcon: ArrowIcon2 = DefaultIcon,
    // FocusTrapProps
    autoFocus = true,
    restoreFocus = true,
    className,
    noStyling = false,
    zIndex = "var(--vkui--z_index_popout)",
    disableFocusTrap,
    // a11y
    role = "dialog"
  } = _param, restPopoverProps = _object_without_properties(_param, [
    "arrow",
    "arrowHeight",
    "arrowPadding",
    "placement",
    "onPlacementChange",
    "disableFlipMiddleware",
    "disableShiftMiddleware",
    "trigger",
    "strategy",
    "content",
    "hoverDelay",
    "closeAfterClick",
    "offsetByMainAxis",
    "offsetByCrossAxis",
    "sameWidth",
    "hideWhenReferenceHidden",
    "onReferenceHiddenChange",
    "disabled",
    "disableInteractive",
    "disableCloseOnClickOutside",
    "disableCloseOnEscKey",
    "keepMounted",
    "customMiddlewares",
    "defaultShown",
    "shown",
    "onShownChange",
    "onShownChanged",
    "usePortal",
    "arrowProps",
    "ArrowIcon",
    "autoFocus",
    "restoreFocus",
    "className",
    "noStyling",
    "zIndex",
    "disableFocusTrap",
    "role"
  ]);
  const renderFloatingComponent = React249.useCallback(({ shown, middlewareData, placement: resolvedPlacement, setArrowRef, floatingRef, floatingProps, willBeHide, onRestoreFocus, onClose }) => {
    if (!shown && !keepMounted) {
      return null;
    }
    const hidden = keepMounted && !shown;
    let arrow5 = null;
    if (withArrow) {
      const { arrow: arrowCoords } = middlewareData;
      arrow5 = (0, import_jsx_runtime244.jsx)(FloatingArrow, _object_spread_props(_object_spread({
        iconClassName: noStyling ? void 0 : "vkuiPopover__arrow"
      }, arrowProps), {
        coords: arrowCoords,
        placement: resolvedPlacement,
        getRootRef: setArrowRef,
        Icon: ArrowIcon2
      }));
    }
    return (0, import_jsx_runtime244.jsx)(AppRootPortal, {
      usePortal,
      children: (0, import_jsx_runtime244.jsx)("div", _object_spread_props(_object_spread({
        ref: floatingRef,
        className: clsx("vkuiPopover__host", hidden && "vkuiPopover__hidden")
      }, floatingProps), {
        style: _object_spread({
          zIndex: !hidden ? zIndex : void 0
        }, floatingProps.style),
        children: (0, import_jsx_runtime244.jsxs)(FocusTrap, _object_spread_props(_object_spread({}, restPopoverProps), {
          role,
          className: clsx("vkuiPopover__in", noStyling ? void 0 : "vkuiPopover__inWithStyling", willBeHide ? animationFadeClassNames.out : animationFadeClassNames.in, transformOriginClassNames[resolvedPlacement], className),
          mount: !hidden,
          disabled: hidden || disableFocusTrap,
          autoFocus: disableInteractive ? false : autoFocus,
          restoreFocus: restoreFocus ? () => onRestoreFocus(restoreFocus) : false,
          children: [
            arrow5,
            typeof content === "function" ? content({
              onClose
            }) : content
          ]
        }))
      }))
    });
  }, [
    ArrowIcon2,
    arrowProps,
    autoFocus,
    className,
    content,
    disableFocusTrap,
    disableInteractive,
    keepMounted,
    noStyling,
    restPopoverProps,
    restoreFocus,
    role,
    usePortal,
    withArrow,
    zIndex
  ]);
  const remapReferenceProps = (0, import_react28.useCallback)((_param2) => {
    var { shown } = _param2, referenceProps = _object_without_properties(_param2, [
      "shown"
    ]);
    return injectAriaExpandedPropByRole(referenceProps, shown, role);
  }, [
    role
  ]);
  const { anchorRef, anchorProps, component: component2 } = useFloatingElement({
    arrow: withArrow,
    arrowHeight,
    arrowPadding,
    placement,
    offsetByMainAxis,
    offsetByCrossAxis,
    sameWidth,
    hideWhenReferenceHidden,
    disableFlipMiddleware,
    disableShiftMiddleware,
    customMiddlewares,
    trigger,
    strategy,
    hoverDelay,
    onReferenceHiddenChange,
    closeAfterClick,
    disabled,
    disableInteractive,
    disableCloseOnClickOutside,
    disableCloseOnEscKey,
    defaultShown,
    shown: shownProp,
    onShownChange,
    onShownChanged,
    onPlacementChange,
    renderFloatingComponent,
    remapReferenceProps
  });
  return {
    anchorRef,
    anchorProps,
    popover: component2
  };
};

// node_modules/@vkontakte/vkui/dist/components/Popover/Popover.js
var Popover = (_param) => {
  var { children } = _param, restProps = _object_without_properties(_param, [
    "children"
  ]);
  const { anchorRef, anchorProps, popover } = usePopover(restProps);
  const reference = useReferenceElement(children, anchorProps, anchorRef);
  return (0, import_jsx_runtime245.jsxs)(React250.Fragment, {
    children: [
      reference,
      popover
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/hoc/withPlatform.js
var import_jsx_runtime246 = __toESM(require_jsx_runtime(), 1);
var React251 = __toESM(require_react(), 1);
function withPlatform(Component2) {
  function WithPlatform(props) {
    const { platform: platform3 } = useConfigProvider();
    return (0, import_jsx_runtime246.jsx)(Component2, _object_spread_props(_object_spread({}, props), {
      platform: platform3
    }));
  }
  return WithPlatform;
}

// node_modules/@vkontakte/vkui/dist/hooks/useLocale.js
function useLocale() {
  const { locale } = useConfigProvider();
  return locale;
}

// node_modules/@vkontakte/vkui/dist/hooks/useOrientationChange.js
var import_react29 = __toESM(require_react(), 1);
function getOrientation(window2) {
  var _window_screen_orientation, _window_screen;
  var _window_screen_orientation_angle;
  const angle = Math.abs((_window_screen_orientation_angle = (_window_screen = window2.screen) === null || _window_screen === void 0 ? void 0 : (_window_screen_orientation = _window_screen.orientation) === null || _window_screen_orientation === void 0 ? void 0 : _window_screen_orientation.angle) !== null && _window_screen_orientation_angle !== void 0 ? _window_screen_orientation_angle : Number(window2.orientation));
  return angle === 90 ? "landscape" : "portrait";
}
function useOrientationChange() {
  const { window: window2 } = useDOM();
  const [orientation, setOrientation] = (0, import_react29.useState)("portrait");
  (0, import_react29.useEffect)(function mount() {
    if (!window2) {
      return;
    }
    const handleChange = () => {
      setOrientation(getOrientation(window2));
    };
    handleChange();
    window2.addEventListener("orientationchange", handleChange);
    return function unmount() {
      window2.removeEventListener("orientationchange", handleChange);
    };
  }, [
    window2
  ]);
  return orientation;
}

// node_modules/@vkontakte/vkui/dist/components/NavIdContext/useNavId.js
var React252 = __toESM(require_react(), 1);
var useNavId = () => ({
  view: React252.useContext(NavViewIdContext),
  panel: React252.useContext(NavPanelIdContext)
});

// node_modules/@vkontakte/vkui/dist/lib/removeObjectKeys.js
function removeObjectKeys(obj, keys = []) {
  let newObj = _object_spread({}, obj);
  keys.forEach((key) => delete newObj[key]);
  return newObj;
}

// node_modules/@vkontakte/vkui/dist/lib/SSR.js
var import_jsx_runtime247 = __toESM(require_jsx_runtime(), 1);
var React253 = __toESM(require_react(), 1);
var SSRWrapper = ({ userAgent, browserInfo, direction = "ltr", children }) => {
  if (!browserInfo && userAgent) {
    browserInfo = computeBrowserInfo(userAgent);
  }
  return (0, import_jsx_runtime247.jsx)(ConfigProviderOverride, {
    direction,
    platform: platform(browserInfo),
    children
  });
};

// node_modules/@vkontakte/vkui/dist/helpers/avatar.js
function calcInitialsAvatarColor(objectId) {
  return objectId % 6 + 1;
}

// node_modules/@vkontakte/vkui/dist/components/View/ViewInfinite.js
var import_jsx_runtime249 = __toESM(require_jsx_runtime(), 1);
var React255 = __toESM(require_react(), 1);

// node_modules/@vkontakte/vkui/dist/hoc/withContext.js
var import_jsx_runtime248 = __toESM(require_jsx_runtime(), 1);
var React254 = __toESM(require_react(), 1);
function withContext(Component2, Ctx, prop) {
  function WithContext(props) {
    const context = React254.useContext(Ctx);
    return (0, import_jsx_runtime248.jsx)(Component2, _object_spread_props(_object_spread({}, props), {
      [prop]: context
    }));
  }
  return WithContext;
}

// node_modules/@vkontakte/vkui/dist/components/View/ViewInfinite.js
var warn39 = warnOnce("ViewInfinite");
var scrollsCache2 = {};
var _React_Component;
var ViewInfiniteComponent = class extends (_React_Component = React255.Component) {
  get document() {
    return this.props.document;
  }
  get window() {
    return this.props.window;
  }
  get panels() {
    return React255.Children.toArray(this.props.children);
  }
  componentWillUnmount() {
    const id = getNavId(this.props);
    if (id) {
      scrollsCache2[id] = this.scrolls;
    }
    if (this.animationFinishTimeout) {
      clearTimeout(this.animationFinishTimeout);
    }
  }
  componentDidUpdate(prevProps, prevState) {
    if (prevProps.activePanel !== this.props.activePanel && !prevState.swipingBack && !prevState.browserSwipe) {
      var _this_props_scroll;
      let isBack = false;
      if (this.props.isBackCheck) {
        isBack = this.props.isBackCheck({
          from: prevProps.activePanel,
          to: this.props.activePanel
        });
      } else {
        const firstLayerId = this.panels.map((panel) => getNavId(panel.props, warn39)).find((id) => id === prevProps.activePanel || id === this.props.activePanel);
        isBack = firstLayerId === this.props.activePanel;
      }
      this.blurActiveElement();
      const prevScrolls = this.scrolls[prevProps.activePanel] || [];
      const scrolls = _object_spread_props(_object_spread({}, this.scrolls), {
        [prevProps.activePanel]: [
          ...prevScrolls,
          (_this_props_scroll = this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.getScroll({
            compensateKeyboardHeight: false
          }).y
        ]
      });
      this.scrolls = scrolls;
      if (this.shouldDisableTransitionMotion()) {
        this.flushTransition(prevProps.activePanel, isBack);
      } else {
        this.setState({
          visiblePanels: [
            prevProps.activePanel,
            this.props.activePanel
          ],
          prevPanel: prevProps.activePanel,
          nextPanel: this.props.activePanel,
          activePanel: null,
          animated: true,
          isBack
        });
      }
    }
    if (prevProps.activePanel !== this.props.activePanel && prevState.swipingBack) {
      const nextPanel = this.state.swipeBackNextPanel;
      const prevPanel = this.state.swipeBackPrevPanel;
      let scrollPosition = void 0;
      this.scrolls = _object_spread({}, this.scrolls);
      if (prevPanel !== null) {
        const prevPanelScrolls = [
          ...this.scrolls[prevPanel] || []
        ].slice(0, -1);
        this.scrolls[prevPanel] = prevPanelScrolls;
      }
      if (nextPanel !== null) {
        const newPanelScrolls = [
          ...this.scrolls[nextPanel] || []
        ];
        scrollPosition = newPanelScrolls.pop();
        this.scrolls[nextPanel] = newPanelScrolls;
      }
      this.setState({
        swipeBackPrevPanel: null,
        swipeBackNextPanel: null,
        swipingBack: false,
        swipeBackResult: null,
        swipeBackStartX: 0,
        swipeBackShift: 0,
        activePanel: nextPanel,
        visiblePanels: [
          nextPanel
        ]
      }, () => {
        var _this_props_scroll2;
        (_this_props_scroll2 = this.props.scroll) === null || _this_props_scroll2 === void 0 ? void 0 : _this_props_scroll2.scrollTo(0, scrollPosition);
        prevProps.onTransition && prevProps.onTransition({
          isBack: true,
          from: prevPanel,
          to: nextPanel
        });
      });
    }
    if (!prevState.swipeBackResult && this.state.swipeBackResult) {
      this.waitTransitionFinish(this.pickPanel(this.state.swipeBackNextPanel), this.swipingBackTransitionEndHandler);
    }
    if (prevState.swipeBackResult === "fail" && !this.state.swipeBackResult && this.state.activePanel !== null) {
      var _this_props_scroll1;
      const newPanelScrolls = [
        ...this.scrolls[this.state.activePanel] || []
      ];
      const scrollPosition = newPanelScrolls.pop();
      this.scrolls = _object_spread_props(_object_spread({}, this.scrolls), {
        [this.state.activePanel]: newPanelScrolls
      });
      (_this_props_scroll1 = this.props.scroll) === null || _this_props_scroll1 === void 0 ? void 0 : _this_props_scroll1.scrollTo(0, scrollPosition);
    }
    if (prevProps.activePanel !== this.props.activePanel && this.state.browserSwipe) {
      this.setState({
        browserSwipe: false,
        nextPanel: null,
        prevPanel: null,
        animated: false,
        visiblePanels: [
          this.props.activePanel
        ],
        activePanel: this.props.activePanel
      });
    }
  }
  shouldDisableTransitionMotion() {
    var _this_props_configProvider, _this_props_splitCol;
    return ((_this_props_configProvider = this.props.configProvider) === null || _this_props_configProvider === void 0 ? void 0 : _this_props_configProvider.transitionMotionEnabled) === false || !((_this_props_splitCol = this.props.splitCol) === null || _this_props_splitCol === void 0 ? void 0 : _this_props_splitCol.animate) || this.props.platform === "vkcom";
  }
  disposeTransition() {
    this.transitionDisposer();
    this.transitionDisposer = noop;
  }
  waitTransitionFinish(elem, eventHandler) {
    if (this.shouldDisableTransitionMotion()) {
      this.disposeTransition();
      this.transitionFinishTimeout = setTimeout(eventHandler);
    } else if (elem) {
      this.disposeTransition();
      elem.addEventListener("transitionend", eventHandler);
      this.transitionDisposer = () => {
        elem.removeEventListener("transitionend", eventHandler);
      };
    } else {
      if (this.transitionFinishTimeout) {
        clearTimeout(this.transitionFinishTimeout);
      }
      this.transitionFinishTimeout = setTimeout(eventHandler, this.props.platform === "android" || this.props.platform === "vkcom" ? 300 : 600);
    }
  }
  blurActiveElement() {
    var _this_document;
    if (typeof this.window !== "undefined" && ((_this_document = this.document) === null || _this_document === void 0 ? void 0 : _this_document.activeElement)) {
      this.document.activeElement.blur();
    }
  }
  pickPanel(id) {
    if (id === null) {
      return void 0;
    }
    return this.panelNodes[id];
  }
  flushTransition(prevPanel, isBack) {
    const activePanel = this.props.activePanel;
    const prevPanelScrolls = [
      ...this.scrolls[prevPanel] || []
    ].slice(0, -1);
    const newPanelScrolls = [
      ...this.scrolls[activePanel] || []
    ];
    const scrollPosition = isBack ? newPanelScrolls.pop() : 0;
    if (isBack) {
      this.scrolls = _object_spread_props(_object_spread({}, this.scrolls), {
        [prevPanel]: prevPanelScrolls,
        [activePanel]: newPanelScrolls
      });
    }
    this.setState({
      prevPanel: null,
      nextPanel: null,
      visiblePanels: [
        activePanel
      ],
      activePanel,
      animated: false,
      isBack
    }, () => {
      var _this_props_scroll;
      (_this_props_scroll = this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.scrollTo(0, isBack ? scrollPosition : 0);
      this.props.onTransition && this.props.onTransition({
        isBack,
        from: prevPanel,
        to: activePanel
      });
    });
  }
  onSwipeBackSuccess() {
    this.props.onSwipeBack && this.props.onSwipeBack();
  }
  onSwipeBackCancel() {
    this.props.onSwipeBackCancel && this.props.onSwipeBackCancel();
    this.setState({
      swipeBackPrevPanel: null,
      swipeBackNextPanel: null,
      swipingBack: false,
      swipeBackResult: null,
      swipeBackStartX: 0,
      swipeBackShift: 0
    });
  }
  calcPanelSwipeStyles(panelId) {
    if (!canUseDOM || !this.window) {
      return {};
    }
    const isPrev = panelId === this.state.swipeBackPrevPanel;
    const isNext = panelId === this.state.swipeBackNextPanel;
    if (!isPrev && !isNext || this.state.swipeBackResult) {
      return {};
    }
    let prevPanelTranslate = `${this.state.swipeBackShift}px`;
    let nextPanelTranslate = `${-50 + this.state.swipeBackShift * 100 / this.window.innerWidth / 2}%`;
    let prevPanelShadow = 0.3 * (this.window.innerWidth - this.state.swipeBackShift) / this.window.innerWidth;
    if (this.state.swipeBackResult) {
      return isPrev ? {
        boxShadow: `-2px 0 12px rgba(0, 0, 0, ${prevPanelShadow})`
      } : {};
    }
    if (isNext) {
      return {
        transform: `translate3d(${nextPanelTranslate}, 0, 0)`
      };
    }
    if (isPrev) {
      return {
        transform: `translate3d(${prevPanelTranslate}, 0, 0)`,
        boxShadow: `-2px 0 12px rgba(0, 0, 0, ${prevPanelShadow})`
      };
    }
    return {};
  }
  render() {
    const _this_props = this.props, { platform: platform3, activePanel: _1, splitCol, configProvider, history, id, nav, onTransition, onSwipeBack, onSwipeBackStart, onSwipeBackCancel, window: window2, document: document2, scroll, isBackCheck, className } = _this_props, restProps = _object_without_properties(_this_props, [
      "platform",
      "activePanel",
      "splitCol",
      "configProvider",
      "history",
      "id",
      "nav",
      "onTransition",
      "onSwipeBack",
      "onSwipeBackStart",
      "onSwipeBackCancel",
      "window",
      "document",
      "scroll",
      "isBackCheck",
      "className"
    ]);
    const { prevPanel, nextPanel, activePanel, isBack, animated, swipeBackPrevPanel, swipeBackNextPanel, swipeBackResult, swipingBack } = this.state;
    const panels = this.panels.filter((panel) => {
      const panelId = getNavId(panel.props, warn39);
      return panelId !== void 0 && this.state.visiblePanels.includes(panelId) || panelId === swipeBackPrevPanel || panelId === swipeBackNextPanel;
    }).sort((panel) => {
      const panelId = getNavId(panel.props, warn39);
      const isPrevPanel = panelId === prevPanel || panelId === swipeBackPrevPanel;
      const isNextPanel = panelId === nextPanel || panelId === swipeBackNextPanel;
      if (isNextPanel) {
        return swipingBack || this.state.isBack ? -1 : 1;
      }
      if (isPrevPanel) {
        return swipingBack || this.state.isBack ? 1 : -1;
      }
      return 0;
    });
    const disableAnimation = this.shouldDisableTransitionMotion();
    const iOSSwipeBackSimulationEnabled = !disableAnimation && platform3 === "ios" && (configProvider === null || configProvider === void 0 ? void 0 : configProvider.isWebView) && Boolean(onSwipeBack);
    return (0, import_jsx_runtime249.jsx)(NavViewIdContext.Provider, {
      value: id || nav,
      children: (0, import_jsx_runtime249.jsx)(Touch, _object_spread_props(_object_spread({
        Component: "section"
      }, restProps), {
        className: clsx("vkuiView__host", platform3 === "ios" && clsx("vkuiView__ios", "vkuiInternalView--ios"), !disableAnimation && this.state.animated && "vkuiView__animated", !disableAnimation && this.state.swipingBack && "vkuiView__swipingBack", disableAnimation && "vkuiView__noMotion", className),
        onMoveX: iOSSwipeBackSimulationEnabled ? this.handleTouchMoveXForIOSSwipeBackSimulation : platform3 === "ios" ? this.handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext : void 0,
        onEnd: iOSSwipeBackSimulationEnabled ? this.handleTouchEndForIOSSwipeBackSimulation : void 0,
        children: (0, import_jsx_runtime249.jsx)("div", {
          className: "vkuiView__panels",
          children: panels.map((panel) => {
            const panelId = getNavId(panel.props, warn39);
            const isPrev = panelId === prevPanel || panelId === swipeBackPrevPanel;
            const compensateScroll = isPrev || panelId === swipeBackNextPanel || panelId === nextPanel && isBack;
            const isTransitionTarget = animated && panelId === (isBack ? prevPanel : nextPanel);
            const scrollList = panelId && this.scrolls[panelId] || [];
            const scroll2 = scrollList[scrollList.length - 1] || 0;
            return (0, import_jsx_runtime249.jsx)("div", {
              className: clsx("vkuiView__panel", panelId === activePanel && "vkuiView__panelActive", panelId === prevPanel && "vkuiView__panelPrev", panelId === nextPanel && "vkuiView__panelNext", panelId === swipeBackPrevPanel && "vkuiView__panelSwipeBackPrev", panelId === swipeBackNextPanel && "vkuiView__panelSwipeBackNext", swipeBackResult === "success" && "vkuiView__panelSwipeBackSuccess", swipeBackResult === "fail" && "vkuiView__panelSwipeBackFailed"),
              onAnimationEnd: isTransitionTarget ? this.transitionEndHandler : void 0,
              ref: (el) => {
                panelId !== void 0 && (this.panelNodes[panelId] = el);
              },
              style: this.calcPanelSwipeStyles(panelId),
              children: (0, import_jsx_runtime249.jsx)("div", {
                className: "vkuiView__panelIn",
                style: {
                  marginTop: compensateScroll ? -scroll2 : void 0
                },
                children: (0, import_jsx_runtime249.jsx)(NavTransitionDirectionProvider, {
                  isBack: swipingBack || isBack,
                  children: (0, import_jsx_runtime249.jsx)(NavTransitionProvider, {
                    entering: panelId === nextPanel || panelId === swipeBackNextPanel,
                    children: panel
                  })
                })
              })
            }, panelId);
          })
        })
      }))
    });
  }
  constructor(props) {
    super(props), _define_property(this, "swipeBackPrevented", false), _define_property(this, "scrolls", scrollsCache2[getNavId(this.props, warn39)] || {}), _define_property(this, "transitionFinishTimeout", void 0), _define_property(this, "animationFinishTimeout", void 0), _define_property(this, "panelNodes", {}), _define_property(this, "transitionDisposer", noop), _define_property(this, "transitionEndHandler", () => {
      if (this.state.prevPanel !== null) {
        this.flushTransition(this.state.prevPanel, Boolean(this.state.isBack));
      }
    }), _define_property(this, "swipingBackTransitionEndHandler", (e) => {
      if (!e || e.propertyName.includes("transform") && e.target === this.pickPanel(this.state.swipeBackNextPanel)) {
        switch (this.state.swipeBackResult) {
          case "fail":
            this.onSwipeBackCancel();
            break;
          case "success":
            this.onSwipeBackSuccess();
        }
      }
    }), _define_property(this, "handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext", (event) => {
      if (this.state.browserSwipe) {
        return;
      }
      const { swipeBackTriggered, viewportStartEdgeTouched, viewportEndEdgeTouched } = getSwipeBackPredicates(event.startX, event.shiftX, this.window.innerWidth);
      if ((viewportStartEdgeTouched || viewportEndEdgeTouched) && swipeBackTriggered) {
        this.setState({
          browserSwipe: true
        });
      }
    }), _define_property(this, "handleTouchMoveXForIOSSwipeBackSimulation", (event) => {
      if (this.swipeBackPrevented || swipeBackExcluded(event)) {
        return;
      }
      const { swipedToOpposite, swipeBackTriggered, viewportStartEdgeTouched } = getSwipeBackPredicates(event.startX, event.shiftX, this.window.innerWidth);
      if (this.state.animated && swipeBackTriggered) {
        return;
      }
      if (!this.state.swipingBack && this.props.history && this.props.history.length > 1) {
        if (swipedToOpposite) {
          this.swipeBackPrevented = true;
          return;
        }
        if (!swipeBackTriggered) {
          return;
        }
        if (!viewportStartEdgeTouched && hasHorizontalScrollableElementWithScrolledToLeft(event.originalEvent.target)) {
          this.swipeBackPrevented = true;
          return;
        }
        if (this.props.onSwipeBackStart) {
          const payload = this.props.onSwipeBackStart(this.state.activePanel);
          if (payload === "prevent") {
            this.swipeBackPrevented = true;
            return;
          }
        }
        if (this.state.activePanel !== null) {
          var _this_props_scroll;
          this.blurActiveElement();
          const prevScrolls = this.scrolls[this.state.activePanel] || [];
          this.scrolls = _object_spread_props(_object_spread({}, this.scrolls), {
            [this.state.activePanel]: [
              ...prevScrolls,
              (_this_props_scroll = this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.getScroll().y
            ]
          });
        }
        this.setState({
          swipingBack: true,
          swipeBackStartX: event.startX,
          swipeBackPrevPanel: this.state.activePanel,
          swipeBackNextPanel: this.props.history.slice(-2)[0]
        });
      }
      if (this.state.swipingBack) {
        if (event.shiftX < 0) {
          this.setState({
            swipeBackShift: 0
          });
        } else if (event.shiftX > this.window.innerWidth - this.state.swipeBackStartX) {
          this.setState({
            swipeBackShift: this.window.innerWidth
          });
        } else {
          this.setState({
            swipeBackShift: event.shiftX
          });
        }
      }
    }), _define_property(this, "handleTouchEndForIOSSwipeBackSimulation", (event) => {
      this.swipeBackPrevented = false;
      if (this.state.swipingBack && this.window) {
        const speed = this.state.swipeBackShift / event.duration * millisecondsInSecond;
        if (this.state.swipeBackShift === 0) {
          this.onSwipeBackCancel();
        } else if (this.state.swipeBackShift >= this.window.innerWidth) {
          this.onSwipeBackSuccess();
        } else if (speed > 250 || this.state.swipeBackShift >= this.window.innerWidth / 2) {
          this.setState({
            swipeBackResult: "success"
          });
        } else {
          this.setState({
            swipeBackResult: "fail"
          });
        }
      }
    });
    this.state = {
      animated: false,
      visiblePanels: [
        props.activePanel
      ],
      activePanel: props.activePanel,
      isBack: void 0,
      prevPanel: null,
      nextPanel: null,
      swipingBack: void 0,
      swipeBackStartX: 0,
      swipeBackShift: 0,
      swipeBackNextPanel: null,
      swipeBackPrevPanel: null,
      swipeBackResult: null,
      browserSwipe: false
    };
  }
};
_define_property(ViewInfiniteComponent, "defaultProps", {
  history: []
});
var ViewInfinite = withContext(withContext(withContext(withPlatform(withDOM(ViewInfiniteComponent)), SplitColContext, "splitCol"), ConfigProviderContext, "configProvider"), ScrollContext, "scroll");

// node_modules/@vkontakte/vkui/dist/components/ModalPageFooter/ModalPageFooter.js
var import_jsx_runtime250 = __toESM(require_jsx_runtime(), 1);
var ModalPageFooter = (_param) => {
  var { noSeparator = false, noPadding = false, children } = _param, restProps = _object_without_properties(_param, [
    "noSeparator",
    "noPadding",
    "children"
  ]);
  const { sizeX, isDesktop } = useAdaptivityWithJSMediaQueries();
  return (0, import_jsx_runtime250.jsxs)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: clsx("vkuiModalPageFooter__host", !noPadding && "vkuiModalPageFooter__padded", isDesktop ? "vkuiModalPageFooter__hostDesktop" : "vkuiModalPageFooter__hostMobile")
  }, restProps), {
    children: [
      !noSeparator && (0, import_jsx_runtime250.jsx)(Separator, {
        className: "vkuiModalPageFooter__Separator",
        padding: sizeX !== "regular"
      }),
      children
    ]
  }));
};

export {
  clsx,
  DOMContext,
  Platform,
  platform,
  ConfigProviderContext,
  useConfigProvider,
  ColorScheme,
  useAdaptivity,
  useManualScroll,
  useScrollLock,
  AppRoot,
  useColorScheme,
  ColorSchemeProvider,
  AppRootPortal,
  DisplayTitle,
  Title,
  Headline,
  Text,
  Paragraph,
  Subhead,
  Footnote,
  Caption,
  EllipsisText,
  UnstyledTextField,
  ViewWidth,
  ViewHeight,
  SizeType,
  getViewWidthByViewportWidth,
  getViewHeightByViewportHeight,
  useFocusVisible,
  usePlatform,
  Tappable,
  OnboardingTooltipContainer,
  FixedLayout,
  ImageBaseContext,
  getFallbackIconSizeByImageBaseSize,
  getBadgeIconSizeByImageBaseSize,
  getOverlayIconSizeByImageBaseSize,
  ImageBase,
  VisuallyHidden,
  useCSSKeyframesAnimationController,
  useReducedMotion,
  Spinner,
  Button,
  IconButton,
  useAdaptivityConditionalRender,
  AdaptiveIconRenderer,
  ToolButton,
  useNavTransition,
  useNavDirection,
  Root,
  Touch,
  View,
  Panel,
  PanelHeaderButton,
  Separator,
  Spacing,
  PanelHeader,
  PanelHeaderContent,
  PanelHeaderContext,
  SplitLayout,
  SplitCol,
  Epic,
  Tabbar,
  TabbarItem,
  useConfigDirection,
  ScrollArrow,
  HorizontalScroll,
  AspectRatio,
  Flex,
  SimpleGrid,
  PopoutWrapper,
  useAdaptivityWithJSMediaQueries,
  ModalOutsideButton,
  ModalDismissButton,
  Alert,
  ActionSheetItem,
  ActionSheetDefaultIosCloseItem,
  DEFAULT_ARROW_WIDTH,
  DEFAULT_ARROW_HEIGHT,
  DEFAULT_ARROW_PADDING,
  DefaultIcon,
  FloatingArrow,
  Popper,
  ActionSheet,
  ScreenSpinnerContext,
  ScreenSpinner,
  Snackbar,
  usePatchChildren,
  useTooltip,
  Tooltip,
  ModalRootContext,
  ModalRoot,
  withModalRootContext,
  useModalRootContext,
  CustomScrollView,
  ModalPageContent,
  ModalPage,
  ModalPageHeader,
  ModalCardBase,
  ModalCard,
  Badge,
  ContentBadge,
  ButtonGroup,
  Card,
  CardGrid,
  CardScroll,
  ContentCard,
  Header,
  Group,
  Gradient,
  List,
  SimpleCell,
  Cell,
  RichCell,
  CellButton,
  CellButtonGroup,
  Avatar,
  HorizontalCell,
  HorizontalCellShowMore,
  Footer,
  InfoRow,
  animate2 as animate,
  Gallery,
  GridAvatar,
  Image,
  Progress,
  Search,
  Tabs,
  TabsItem,
  PullToRefresh,
  Link,
  Mark,
  OnboardingTooltip,
  Counter,
  UsersStack,
  Box,
  Placeholder,
  Banner,
  MiniInfoCell,
  WriteBar,
  WriteBarIcon,
  SubnavigationBar,
  SubnavigationButton,
  usePagination,
  Pagination,
  AccordionContext,
  useAccordionContext,
  Accordion,
  FormItem,
  FormField,
  FormLayoutGroup,
  FormStatus,
  Switch,
  File,
  DropZone,
  Input,
  Chip,
  ChipsInput,
  defaultFilterFn,
  CustomSelectOption,
  ChipsSelect,
  Slider,
  Textarea,
  SelectionControl,
  Radio2 as Radio,
  RadioGroup,
  Checkbox,
  NativeSelect,
  CustomSelect,
  Select,
  SelectMimicry,
  SegmentedControl,
  useTodayDate,
  AdaptivityProvider,
  Calendar,
  CalendarRange,
  DateInput,
  DateRangeInput,
  Skeleton,
  Div,
  PanelSpinner,
  PanelHeaderClose,
  PanelHeaderBack,
  PanelHeaderSubmit,
  PanelHeaderEdit,
  ConfigProvider,
  LocaleProvider,
  DirectionProvider,
  PlatformProvider,
  usePopover,
  Popover,
  withPlatform,
  useLocale,
  useOrientationChange,
  useNavId,
  removeObjectKeys,
  SSRWrapper,
  calcInitialsAvatarColor,
  ViewInfinite,
  ModalPageFooter
};
//# sourceMappingURL=chunk-IH2UPG73.js.map
