"use strict";
var _async_to_generator = require("@swc/helpers/_/_async_to_generator");
var _instanceof = require("@swc/helpers/_/_instanceof");
var _object_spread = require("@swc/helpers/_/_object_spread");
var _object_spread_props = require("@swc/helpers/_/_object_spread_props");
var _sliced_to_array = require("@swc/helpers/_/_sliced_to_array");
var _to_consumable_array = require("@swc/helpers/_/_to_consumable_array");
var _type_of = require("@swc/helpers/_/_type_of");
var _ts_generator = require("@swc/helpers/_/_ts_generator");
(function(global, factory) {
    (typeof exports === "undefined" ? "undefined" : _type_of._(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports, require('@floating-ui/core')) : typeof define === 'function' && define.amd ? define([
        'exports',
        '@floating-ui/core'
    ], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.FloatingUIDOM = {}, global.FloatingUICore));
})(void 0, function(exports1, core) {
    'use strict';
    /**
   * Custom positioning reference element.
   * @see https://floating-ui.com/docs/virtual-elements
   */ var min = Math.min;
    var max = Math.max;
    var round = Math.round;
    var floor = Math.floor;
    var createCoords = function createCoords(v) {
        return {
            x: v,
            y: v
        };
    };
    function hasWindow() {
        return typeof window !== 'undefined';
    }
    function getNodeName(node) {
        if (isNode(node)) {
            return (node.nodeName || '').toLowerCase();
        }
        // Mocked nodes in testing environments may not be instances of Node. By
        // returning `#document` an infinite loop won't occur.
        // https://github.com/floating-ui/floating-ui/issues/2317
        return '#document';
    }
    function getWindow(node) {
        var _node$ownerDocument;
        return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
    }
    function getDocumentElement(node) {
        var _ref;
        return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
    }
    function isNode(value) {
        if (!hasWindow()) {
            return false;
        }
        return _instanceof._(value, Node) || _instanceof._(value, getWindow(value).Node);
    }
    function isElement(value) {
        if (!hasWindow()) {
            return false;
        }
        return _instanceof._(value, Element) || _instanceof._(value, getWindow(value).Element);
    }
    function isHTMLElement(value) {
        if (!hasWindow()) {
            return false;
        }
        return _instanceof._(value, HTMLElement) || _instanceof._(value, getWindow(value).HTMLElement);
    }
    function isShadowRoot(value) {
        if (!hasWindow() || typeof ShadowRoot === 'undefined') {
            return false;
        }
        return _instanceof._(value, ShadowRoot) || _instanceof._(value, getWindow(value).ShadowRoot);
    }
    var invalidOverflowDisplayValues = /*#__PURE__*/ new Set([
        'inline',
        'contents'
    ]);
    function isOverflowElement(element) {
        var _getComputedStyle$1 = getComputedStyle$1(element), overflow = _getComputedStyle$1.overflow, overflowX = _getComputedStyle$1.overflowX, overflowY = _getComputedStyle$1.overflowY, display = _getComputedStyle$1.display;
        return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
    }
    var tableElements = /*#__PURE__*/ new Set([
        'table',
        'td',
        'th'
    ]);
    function isTableElement(element) {
        return tableElements.has(getNodeName(element));
    }
    var topLayerSelectors = [
        ':popover-open',
        ':modal'
    ];
    function isTopLayer(element) {
        return topLayerSelectors.some(function(selector) {
            try {
                return element.matches(selector);
            } catch (_e) {
                return false;
            }
        });
    }
    var transformProperties = [
        'transform',
        'translate',
        'scale',
        'rotate',
        'perspective'
    ];
    var willChangeValues = [
        'transform',
        'translate',
        'scale',
        'rotate',
        'perspective',
        'filter'
    ];
    var containValues = [
        'paint',
        'layout',
        'strict',
        'content'
    ];
    function isContainingBlock(elementOrCss) {
        var webkit = isWebKit();
        var css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
        // https://drafts.csswg.org/css-transforms-2/#individual-transforms
        return transformProperties.some(function(value) {
            return css[value] ? css[value] !== 'none' : false;
        }) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || willChangeValues.some(function(value) {
            return (css.willChange || '').includes(value);
        }) || containValues.some(function(value) {
            return (css.contain || '').includes(value);
        });
    }
    function getContainingBlock(element) {
        var currentNode = getParentNode(element);
        while(isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)){
            if (isContainingBlock(currentNode)) {
                return currentNode;
            } else if (isTopLayer(currentNode)) {
                return null;
            }
            currentNode = getParentNode(currentNode);
        }
        return null;
    }
    function isWebKit() {
        if (typeof CSS === 'undefined' || !CSS.supports) return false;
        return CSS.supports('-webkit-backdrop-filter', 'none');
    }
    var lastTraversableNodeNames = /*#__PURE__*/ new Set([
        'html',
        'body',
        '#document'
    ]);
    function isLastTraversableNode(node) {
        return lastTraversableNodeNames.has(getNodeName(node));
    }
    function getComputedStyle$1(element) {
        return getWindow(element).getComputedStyle(element);
    }
    function getNodeScroll(element) {
        if (isElement(element)) {
            return {
                scrollLeft: element.scrollLeft,
                scrollTop: element.scrollTop
            };
        }
        return {
            scrollLeft: element.scrollX,
            scrollTop: element.scrollY
        };
    }
    function getParentNode(node) {
        if (getNodeName(node) === 'html') {
            return node;
        }
        var result = // Step into the shadow DOM of the parent of a slotted node.
        node.assignedSlot || // DOM Element detected.
        node.parentNode || // ShadowRoot detected.
        isShadowRoot(node) && node.host || // Fallback.
        getDocumentElement(node);
        return isShadowRoot(result) ? result.host : result;
    }
    function getNearestOverflowAncestor(node) {
        var parentNode = getParentNode(node);
        if (isLastTraversableNode(parentNode)) {
            return node.ownerDocument ? node.ownerDocument.body : node.body;
        }
        if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
            return parentNode;
        }
        return getNearestOverflowAncestor(parentNode);
    }
    function getOverflowAncestors(node, list, traverseIframes) {
        var _node$ownerDocument2;
        if (list === void 0) {
            list = [];
        }
        if (traverseIframes === void 0) {
            traverseIframes = true;
        }
        var scrollableAncestor = getNearestOverflowAncestor(node);
        var isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
        var win = getWindow(scrollableAncestor);
        if (isBody) {
            var frameElement = getFrameElement(win);
            return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
        }
        return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
    }
    function getFrameElement(win) {
        return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
    }
    function getCssDimensions(element) {
        var css = getComputedStyle$1(element);
        // In testing environments, the `width` and `height` properties are empty
        // strings for SVG elements, returning NaN. Fallback to `0` in this case.
        var width = parseFloat(css.width) || 0;
        var height = parseFloat(css.height) || 0;
        var hasOffset = isHTMLElement(element);
        var offsetWidth = hasOffset ? element.offsetWidth : width;
        var offsetHeight = hasOffset ? element.offsetHeight : height;
        var shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
        if (shouldFallback) {
            width = offsetWidth;
            height = offsetHeight;
        }
        return {
            width: width,
            height: height,
            $: shouldFallback
        };
    }
    function unwrapElement(element) {
        return !isElement(element) ? element.contextElement : element;
    }
    function getScale(element) {
        var domElement = unwrapElement(element);
        if (!isHTMLElement(domElement)) {
            return createCoords(1);
        }
        var rect = domElement.getBoundingClientRect();
        var _getCssDimensions = getCssDimensions(domElement), width = _getCssDimensions.width, height = _getCssDimensions.height, $ = _getCssDimensions.$;
        var x = ($ ? round(rect.width) : rect.width) / width;
        var y = ($ ? round(rect.height) : rect.height) / height;
        // 0, NaN, or Infinity should always fallback to 1.
        if (!x || !Number.isFinite(x)) {
            x = 1;
        }
        if (!y || !Number.isFinite(y)) {
            y = 1;
        }
        return {
            x: x,
            y: y
        };
    }
    var noOffsets = /*#__PURE__*/ createCoords(0);
    function getVisualOffsets(element) {
        var win = getWindow(element);
        if (!isWebKit() || !win.visualViewport) {
            return noOffsets;
        }
        return {
            x: win.visualViewport.offsetLeft,
            y: win.visualViewport.offsetTop
        };
    }
    function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
        if (isFixed === void 0) {
            isFixed = false;
        }
        if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
            return false;
        }
        return isFixed;
    }
    function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
        if (includeScale === void 0) {
            includeScale = false;
        }
        if (isFixedStrategy === void 0) {
            isFixedStrategy = false;
        }
        var clientRect = element.getBoundingClientRect();
        var domElement = unwrapElement(element);
        var scale = createCoords(1);
        if (includeScale) {
            if (offsetParent) {
                if (isElement(offsetParent)) {
                    scale = getScale(offsetParent);
                }
            } else {
                scale = getScale(element);
            }
        }
        var visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
        var x = (clientRect.left + visualOffsets.x) / scale.x;
        var y = (clientRect.top + visualOffsets.y) / scale.y;
        var width = clientRect.width / scale.x;
        var height = clientRect.height / scale.y;
        if (domElement) {
            var win = getWindow(domElement);
            var offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
            var currentWin = win;
            var currentIFrame = getFrameElement(currentWin);
            while(currentIFrame && offsetParent && offsetWin !== currentWin){
                var iframeScale = getScale(currentIFrame);
                var iframeRect = currentIFrame.getBoundingClientRect();
                var css = getComputedStyle$1(currentIFrame);
                var left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
                var top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
                x *= iframeScale.x;
                y *= iframeScale.y;
                width *= iframeScale.x;
                height *= iframeScale.y;
                x += left;
                y += top;
                currentWin = getWindow(currentIFrame);
                currentIFrame = getFrameElement(currentWin);
            }
        }
        return core.rectToClientRect({
            width: width,
            height: height,
            x: x,
            y: y
        });
    }
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    function getWindowScrollBarX(element, rect) {
        var leftScroll = getNodeScroll(element).scrollLeft;
        if (!rect) {
            return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
        }
        return rect.left + leftScroll;
    }
    function getHTMLOffset(documentElement, scroll) {
        var htmlRect = documentElement.getBoundingClientRect();
        var x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
        var y = htmlRect.top + scroll.scrollTop;
        return {
            x: x,
            y: y
        };
    }
    function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
        var elements = _ref.elements, rect = _ref.rect, offsetParent = _ref.offsetParent, strategy = _ref.strategy;
        var isFixed = strategy === 'fixed';
        var documentElement = getDocumentElement(offsetParent);
        var topLayer = elements ? isTopLayer(elements.floating) : false;
        if (offsetParent === documentElement || topLayer && isFixed) {
            return rect;
        }
        var scroll = {
            scrollLeft: 0,
            scrollTop: 0
        };
        var scale = createCoords(1);
        var offsets = createCoords(0);
        var isOffsetParentAnElement = isHTMLElement(offsetParent);
        if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
            if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
                scroll = getNodeScroll(offsetParent);
            }
            if (isHTMLElement(offsetParent)) {
                var offsetRect = getBoundingClientRect(offsetParent);
                scale = getScale(offsetParent);
                offsets.x = offsetRect.x + offsetParent.clientLeft;
                offsets.y = offsetRect.y + offsetParent.clientTop;
            }
        }
        var htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
        return {
            width: rect.width * scale.x,
            height: rect.height * scale.y,
            x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
            y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
        };
    }
    function getClientRects(element) {
        return Array.from(element.getClientRects());
    }
    // Gets the entire size of the scrollable document area, even extending outside
    // of the `<html>` and `<body>` rect bounds if horizontally scrollable.
    function getDocumentRect(element) {
        var html = getDocumentElement(element);
        var scroll = getNodeScroll(element);
        var body = element.ownerDocument.body;
        var width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
        var height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
        var x = -scroll.scrollLeft + getWindowScrollBarX(element);
        var y = -scroll.scrollTop;
        if (getComputedStyle$1(body).direction === 'rtl') {
            x += max(html.clientWidth, body.clientWidth) - width;
        }
        return {
            width: width,
            height: height,
            x: x,
            y: y
        };
    }
    // Safety check: ensure the scrollbar space is reasonable in case this
    // calculation is affected by unusual styles.
    // Most scrollbars leave 15-18px of space.
    var SCROLLBAR_MAX = 25;
    function getViewportRect(element, strategy) {
        var win = getWindow(element);
        var html = getDocumentElement(element);
        var visualViewport = win.visualViewport;
        var width = html.clientWidth;
        var height = html.clientHeight;
        var x = 0;
        var y = 0;
        if (visualViewport) {
            width = visualViewport.width;
            height = visualViewport.height;
            var visualViewportBased = isWebKit();
            if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
                x = visualViewport.offsetLeft;
                y = visualViewport.offsetTop;
            }
        }
        var windowScrollbarX = getWindowScrollBarX(html);
        // <html> `overflow: hidden` + `scrollbar-gutter: stable` reduces the
        // visual width of the <html> but this is not considered in the size
        // of `html.clientWidth`.
        if (windowScrollbarX <= 0) {
            var doc = html.ownerDocument;
            var body = doc.body;
            var bodyStyles = getComputedStyle(body);
            var bodyMarginInline = doc.compatMode === 'CSS1Compat' ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
            var clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
            if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
                width -= clippingStableScrollbarWidth;
            }
        } else if (windowScrollbarX <= SCROLLBAR_MAX) {
            // If the <body> scrollbar is on the left, the width needs to be extended
            // by the scrollbar amount so there isn't extra space on the right.
            width += windowScrollbarX;
        }
        return {
            width: width,
            height: height,
            x: x,
            y: y
        };
    }
    var absoluteOrFixed = /*#__PURE__*/ new Set([
        'absolute',
        'fixed'
    ]);
    // Returns the inner client rect, subtracting scrollbars if present.
    function getInnerBoundingClientRect(element, strategy) {
        var clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
        var top = clientRect.top + element.clientTop;
        var left = clientRect.left + element.clientLeft;
        var scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
        var width = element.clientWidth * scale.x;
        var height = element.clientHeight * scale.y;
        var x = left * scale.x;
        var y = top * scale.y;
        return {
            width: width,
            height: height,
            x: x,
            y: y
        };
    }
    function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
        var rect;
        if (clippingAncestor === 'viewport') {
            rect = getViewportRect(element, strategy);
        } else if (clippingAncestor === 'document') {
            rect = getDocumentRect(getDocumentElement(element));
        } else if (isElement(clippingAncestor)) {
            rect = getInnerBoundingClientRect(clippingAncestor, strategy);
        } else {
            var visualOffsets = getVisualOffsets(element);
            rect = {
                x: clippingAncestor.x - visualOffsets.x,
                y: clippingAncestor.y - visualOffsets.y,
                width: clippingAncestor.width,
                height: clippingAncestor.height
            };
        }
        return core.rectToClientRect(rect);
    }
    function hasFixedPositionAncestor(element, stopNode) {
        var parentNode = getParentNode(element);
        if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
            return false;
        }
        return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
    }
    // A "clipping ancestor" is an `overflow` element with the characteristic of
    // clipping (or hiding) child elements. This returns all clipping ancestors
    // of the given element up the tree.
    function getClippingElementAncestors(element, cache) {
        var cachedResult = cache.get(element);
        if (cachedResult) {
            return cachedResult;
        }
        var result = getOverflowAncestors(element, [], false).filter(function(el) {
            return isElement(el) && getNodeName(el) !== 'body';
        });
        var currentContainingBlockComputedStyle = null;
        var elementIsFixed = getComputedStyle$1(element).position === 'fixed';
        var currentNode = elementIsFixed ? getParentNode(element) : element;
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
        while(isElement(currentNode) && !isLastTraversableNode(currentNode)){
            var computedStyle = getComputedStyle$1(currentNode);
            var currentNodeIsContaining = isContainingBlock(currentNode);
            if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
                currentContainingBlockComputedStyle = null;
            }
            var shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
            if (shouldDropCurrentNode) {
                // Drop non-containing blocks.
                result = result.filter(function(ancestor) {
                    return ancestor !== currentNode;
                });
            } else {
                // Record last containing block for next iteration.
                currentContainingBlockComputedStyle = computedStyle;
            }
            currentNode = getParentNode(currentNode);
        }
        cache.set(element, result);
        return result;
    }
    // Gets the maximum area that the element is visible in due to any number of
    // clipping ancestors.
    function getClippingRect(_ref) {
        var element = _ref.element, boundary = _ref.boundary, rootBoundary = _ref.rootBoundary, strategy = _ref.strategy;
        var elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
        var clippingAncestors = _to_consumable_array._(elementClippingAncestors).concat([
            rootBoundary
        ]);
        var firstClippingAncestor = clippingAncestors[0];
        var clippingRect = clippingAncestors.reduce(function(accRect, clippingAncestor) {
            var rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
            accRect.top = max(rect.top, accRect.top);
            accRect.right = min(rect.right, accRect.right);
            accRect.bottom = min(rect.bottom, accRect.bottom);
            accRect.left = max(rect.left, accRect.left);
            return accRect;
        }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
        return {
            width: clippingRect.right - clippingRect.left,
            height: clippingRect.bottom - clippingRect.top,
            x: clippingRect.left,
            y: clippingRect.top
        };
    }
    function getDimensions(element) {
        var _getCssDimensions = getCssDimensions(element), width = _getCssDimensions.width, height = _getCssDimensions.height;
        return {
            width: width,
            height: height
        };
    }
    function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
        var isOffsetParentAnElement = isHTMLElement(offsetParent);
        var documentElement = getDocumentElement(offsetParent);
        var isFixed = strategy === 'fixed';
        var rect = getBoundingClientRect(element, true, isFixed, offsetParent);
        var scroll = {
            scrollLeft: 0,
            scrollTop: 0
        };
        var offsets = createCoords(0);
        // If the <body> scrollbar appears on the left (e.g. RTL systems). Use
        // Firefox with layout.scrollbar.side = 3 in about:config to test this.
        function setLeftRTLScrollbarOffset() {
            offsets.x = getWindowScrollBarX(documentElement);
        }
        if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
            if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
                scroll = getNodeScroll(offsetParent);
            }
            if (isOffsetParentAnElement) {
                var offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
                offsets.x = offsetRect.x + offsetParent.clientLeft;
                offsets.y = offsetRect.y + offsetParent.clientTop;
            } else if (documentElement) {
                setLeftRTLScrollbarOffset();
            }
        }
        if (isFixed && !isOffsetParentAnElement && documentElement) {
            setLeftRTLScrollbarOffset();
        }
        var htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
        var x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
        var y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
        return {
            x: x,
            y: y,
            width: rect.width,
            height: rect.height
        };
    }
    function isStaticPositioned(element) {
        return getComputedStyle$1(element).position === 'static';
    }
    function getTrueOffsetParent(element, polyfill) {
        if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {
            return null;
        }
        if (polyfill) {
            return polyfill(element);
        }
        var rawOffsetParent = element.offsetParent;
        // Firefox returns the <html> element as the offsetParent if it's non-static,
        // while Chrome and Safari return the <body> element. The <body> element must
        // be used to perform the correct calculations even if the <html> element is
        // non-static.
        if (getDocumentElement(element) === rawOffsetParent) {
            rawOffsetParent = rawOffsetParent.ownerDocument.body;
        }
        return rawOffsetParent;
    }
    // Gets the closest ancestor positioned element. Handles some edge cases,
    // such as table ancestors and cross browser bugs.
    function getOffsetParent(element, polyfill) {
        var win = getWindow(element);
        if (isTopLayer(element)) {
            return win;
        }
        if (!isHTMLElement(element)) {
            var svgOffsetParent = getParentNode(element);
            while(svgOffsetParent && !isLastTraversableNode(svgOffsetParent)){
                if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
                    return svgOffsetParent;
                }
                svgOffsetParent = getParentNode(svgOffsetParent);
            }
            return win;
        }
        var offsetParent = getTrueOffsetParent(element, polyfill);
        while(offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)){
            offsetParent = getTrueOffsetParent(offsetParent, polyfill);
        }
        if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
            return win;
        }
        return offsetParent || getContainingBlock(element) || win;
    }
    var getElementRects = function getElementRects(data) {
        return _async_to_generator._(function() {
            var getOffsetParentFn, getDimensionsFn, floatingDimensions, _tmp, _tmp1;
            return _ts_generator._(this, function(_state) {
                switch(_state.label){
                    case 0:
                        getOffsetParentFn = this.getOffsetParent || getOffsetParent;
                        getDimensionsFn = this.getDimensions;
                        return [
                            4,
                            getDimensionsFn(data.floating)
                        ];
                    case 1:
                        floatingDimensions = _state.sent();
                        _tmp = {};
                        _tmp1 = [
                            data.reference
                        ];
                        return [
                            4,
                            getOffsetParentFn(data.floating)
                        ];
                    case 2:
                        return [
                            2,
                            (_tmp.reference = getRectRelativeToOffsetParent.apply(void 0, _tmp1.concat([
                                _state.sent(),
                                data.strategy
                            ])), _tmp.floating = {
                                x: 0,
                                y: 0,
                                width: floatingDimensions.width,
                                height: floatingDimensions.height
                            }, _tmp)
                        ];
                }
            });
        }).call(this);
    };
    function isRTL(element) {
        return getComputedStyle$1(element).direction === 'rtl';
    }
    var platform = {
        convertOffsetParentRelativeRectToViewportRelativeRect: convertOffsetParentRelativeRectToViewportRelativeRect,
        getDocumentElement: getDocumentElement,
        getClippingRect: getClippingRect,
        getOffsetParent: getOffsetParent,
        getElementRects: getElementRects,
        getClientRects: getClientRects,
        getDimensions: getDimensions,
        getScale: getScale,
        isElement: isElement,
        isRTL: isRTL
    };
    function rectsAreEqual(a, b) {
        return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
    }
    // https://samthor.au/2021/observing-dom/
    function observeMove(element, onMove) {
        var io = null;
        var timeoutId;
        var root = getDocumentElement(element);
        function cleanup() {
            var _io;
            clearTimeout(timeoutId);
            (_io = io) == null || _io.disconnect();
            io = null;
        }
        function refresh(skip, threshold) {
            if (skip === void 0) {
                skip = false;
            }
            if (threshold === void 0) {
                threshold = 1;
            }
            cleanup();
            var elementRectForRootMargin = element.getBoundingClientRect();
            var left = elementRectForRootMargin.left, top = elementRectForRootMargin.top, width = elementRectForRootMargin.width, height = elementRectForRootMargin.height;
            if (!skip) {
                onMove();
            }
            if (!width || !height) {
                return;
            }
            var insetTop = floor(top);
            var insetRight = floor(root.clientWidth - (left + width));
            var insetBottom = floor(root.clientHeight - (top + height));
            var insetLeft = floor(left);
            var rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
            var options = {
                rootMargin: rootMargin,
                threshold: max(0, min(1, threshold)) || 1
            };
            var isFirstUpdate = true;
            function handleObserve(entries) {
                var ratio = entries[0].intersectionRatio;
                if (ratio !== threshold) {
                    if (!isFirstUpdate) {
                        return refresh();
                    }
                    if (!ratio) {
                        // If the reference is clipped, the ratio is 0. Throttle the refresh
                        // to prevent an infinite loop of updates.
                        timeoutId = setTimeout(function() {
                            refresh(false, 1e-7);
                        }, 1000);
                    } else {
                        refresh(false, ratio);
                    }
                }
                if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
                    // It's possible that even though the ratio is reported as 1, the
                    // element is not actually fully within the IntersectionObserver's root
                    // area anymore. This can happen under performance constraints. This may
                    // be a bug in the browser's IntersectionObserver implementation. To
                    // work around this, we compare the element's bounding rect now with
                    // what it was at the time we created the IntersectionObserver. If they
                    // are not equal then the element moved, so we refresh.
                    refresh();
                }
                isFirstUpdate = false;
            }
            // Older browsers don't support a `document` as the root and will throw an
            // error.
            try {
                io = new IntersectionObserver(handleObserve, _object_spread_props._(_object_spread._({}, options), {
                    // Handle <iframe>s
                    root: root.ownerDocument
                }));
            } catch (_e) {
                io = new IntersectionObserver(handleObserve, options);
            }
            io.observe(element);
        }
        refresh(true);
        return cleanup;
    }
    /**
   * Automatically updates the position of the floating element when necessary.
   * Should only be called when the floating element is mounted on the DOM or
   * visible on the screen.
   * @returns cleanup function that should be invoked when the floating element is
   * removed from the DOM or hidden from the screen.
   * @see https://floating-ui.com/docs/autoUpdate
   */ function autoUpdate(reference, floating, update, options) {
        if (options === void 0) {
            options = {};
        }
        var _options_ancestorScroll = options.ancestorScroll, ancestorScroll = _options_ancestorScroll === void 0 ? true : _options_ancestorScroll, _options_ancestorResize = options.ancestorResize, ancestorResize = _options_ancestorResize === void 0 ? true : _options_ancestorResize, _options_elementResize = options.elementResize, elementResize = _options_elementResize === void 0 ? typeof ResizeObserver === 'function' : _options_elementResize, _options_layoutShift = options.layoutShift, layoutShift = _options_layoutShift === void 0 ? typeof IntersectionObserver === 'function' : _options_layoutShift, _options_animationFrame = options.animationFrame, animationFrame = _options_animationFrame === void 0 ? false : _options_animationFrame;
        var referenceEl = unwrapElement(reference);
        var ancestors = ancestorScroll || ancestorResize ? _to_consumable_array._(referenceEl ? getOverflowAncestors(referenceEl) : []).concat(_to_consumable_array._(getOverflowAncestors(floating))) : [];
        ancestors.forEach(function(ancestor) {
            ancestorScroll && ancestor.addEventListener('scroll', update, {
                passive: true
            });
            ancestorResize && ancestor.addEventListener('resize', update);
        });
        var cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
        var reobserveFrame = -1;
        var resizeObserver = null;
        if (elementResize) {
            resizeObserver = new ResizeObserver(function(_ref) {
                var _$_ref = _sliced_to_array._(_ref, 1), firstEntry = _$_ref[0];
                if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
                    // Prevent update loops when using the `size` middleware.
                    // https://github.com/floating-ui/floating-ui/issues/1740
                    resizeObserver.unobserve(floating);
                    cancelAnimationFrame(reobserveFrame);
                    reobserveFrame = requestAnimationFrame(function() {
                        var _resizeObserver;
                        (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
                    });
                }
                update();
            });
            if (referenceEl && !animationFrame) {
                resizeObserver.observe(referenceEl);
            }
            resizeObserver.observe(floating);
        }
        var frameId;
        var prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
        if (animationFrame) {
            frameLoop();
        }
        function frameLoop() {
            var nextRefRect = getBoundingClientRect(reference);
            if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
                update();
            }
            prevRefRect = nextRefRect;
            frameId = requestAnimationFrame(frameLoop);
        }
        update();
        return function() {
            var _resizeObserver2;
            ancestors.forEach(function(ancestor) {
                ancestorScroll && ancestor.removeEventListener('scroll', update);
                ancestorResize && ancestor.removeEventListener('resize', update);
            });
            cleanupIo == null || cleanupIo();
            (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
            resizeObserver = null;
            if (animationFrame) {
                cancelAnimationFrame(frameId);
            }
        };
    }
    /**
   * Resolves with an object of overflow side offsets that determine how much the
   * element is overflowing a given clipping boundary on each side.
   * - positive = overflowing the boundary by that number of pixels
   * - negative = how many pixels left before it will overflow
   * - 0 = lies flush with the boundary
   * @see https://floating-ui.com/docs/detectOverflow
   */ var detectOverflow = core.detectOverflow;
    /**
   * Modifies the placement by translating the floating element along the
   * specified axes.
   * A number (shorthand for `mainAxis` or distance), or an axes configuration
   * object may be passed.
   * @see https://floating-ui.com/docs/offset
   */ var offset = core.offset;
    /**
   * Optimizes the visibility of the floating element by choosing the placement
   * that has the most space available automatically, without needing to specify a
   * preferred placement. Alternative to `flip`.
   * @see https://floating-ui.com/docs/autoPlacement
   */ var autoPlacement = core.autoPlacement;
    /**
   * Optimizes the visibility of the floating element by shifting it in order to
   * keep it in view when it will overflow the clipping boundary.
   * @see https://floating-ui.com/docs/shift
   */ var shift = core.shift;
    /**
   * Optimizes the visibility of the floating element by flipping the `placement`
   * in order to keep it in view when the preferred placement(s) will overflow the
   * clipping boundary. Alternative to `autoPlacement`.
   * @see https://floating-ui.com/docs/flip
   */ var flip = core.flip;
    /**
   * Provides data that allows you to change the size of the floating element â€”
   * for instance, prevent it from overflowing the clipping boundary or match the
   * width of the reference element.
   * @see https://floating-ui.com/docs/size
   */ var size = core.size;
    /**
   * Provides data to hide the floating element in applicable situations, such as
   * when it is not in the same clipping context as the reference element.
   * @see https://floating-ui.com/docs/hide
   */ var hide = core.hide;
    /**
   * Provides data to position an inner element of the floating element so that it
   * appears centered to the reference element.
   * @see https://floating-ui.com/docs/arrow
   */ var arrow = core.arrow;
    /**
   * Provides improved positioning for inline reference elements that can span
   * over multiple lines, such as hyperlinks or range selections.
   * @see https://floating-ui.com/docs/inline
   */ var inline = core.inline;
    /**
   * Built-in `limiter` that will stop `shift()` at a certain point.
   */ var limitShift = core.limitShift;
    /**
   * Computes the `x` and `y` coordinates that will place the floating element
   * next to a given reference element.
   */ var computePosition = function computePosition(reference, floating, options) {
        // This caches the expensive `getClippingElementAncestors` function so that
        // multiple lifecycle resets re-use the same result. It only lives for a
        // single call. If other functions become expensive, we can add them as well.
        var cache = new Map();
        var mergedOptions = _object_spread._({
            platform: platform
        }, options);
        var platformWithCache = _object_spread_props._(_object_spread._({}, mergedOptions.platform), {
            _c: cache
        });
        return core.computePosition(reference, floating, _object_spread_props._(_object_spread._({}, mergedOptions), {
            platform: platformWithCache
        }));
    };
    exports1.arrow = arrow;
    exports1.autoPlacement = autoPlacement;
    exports1.autoUpdate = autoUpdate;
    exports1.computePosition = computePosition;
    exports1.detectOverflow = detectOverflow;
    exports1.flip = flip;
    exports1.getOverflowAncestors = getOverflowAncestors;
    exports1.hide = hide;
    exports1.inline = inline;
    exports1.limitShift = limitShift;
    exports1.offset = offset;
    exports1.platform = platform;
    exports1.shift = shift;
    exports1.size = size;
});
