{"version":3,"sources":["../../../src/lib/animation/useCSSTransition.ts"],"sourcesContent":["import { type TransitionEvent, type TransitionEventHandler, useRef, useState } from 'react';\nimport { noop } from '@vkontakte/vkjs';\nimport { useStableCallback } from '../../hooks/useStableCallback';\nimport { millisecondsInSecond } from '../date';\nimport { useIsomorphicLayoutEffect } from '../useIsomorphicLayoutEffect';\n\n/* istanbul ignore next: особенность рендера в браузере когда меняется className, в Vitest не воспроизвести */\nconst forceReflowForFixNewMountedElement = (node: Element | null) => void node?.scrollTop;\n\nexport type UseCSSTransitionState =\n  | 'appear'\n  | 'appearing'\n  | 'appeared'\n  | 'enter'\n  | 'entering'\n  | 'entered'\n  | 'exit'\n  | 'exiting'\n  | 'exited';\n\nexport type UseCSSTransitionOptions = {\n  enableAppear?: boolean;\n  enableEnter?: boolean;\n  enableExit?: boolean;\n  onEnter?: (appear?: boolean) => void;\n  onEntering?: (appear?: boolean) => void;\n  onEntered?: (propertyName?: string, appear?: boolean) => void;\n  onExit?: () => void;\n  onExiting?: () => void;\n  onExited?: (propertyName?: string) => void;\n};\n\nexport type UseCSSTransition<Ref extends Element = Element> = [\n  state: UseCSSTransitionState,\n  {\n    ref: React.RefObject<Ref | null>;\n    onTransitionEnd?: TransitionEventHandler;\n  },\n];\n\nconst TRANSITION_FALLBACK_DELAY = 100;\n\n/**\n * Хук основан на компоненте `CSSTransition` из библиотеки `react-transition-group`.\n *\n * @link https://reactcommunity.org/react-transition-group/css-transition\n *\n * @private\n */\nexport const useCSSTransition = <Ref extends Element = Element>(\n  inProp?: boolean,\n  {\n    enableAppear = false,\n    enableEnter = true,\n    enableExit = true,\n    onEnter: onEnterProp,\n    onEntering: onEnteringProp,\n    onEntered: onEnteredProp,\n    onExit: onExitProp,\n    onExiting: onExitingProp,\n    onExited: onExitedProp,\n  }: UseCSSTransitionOptions = {},\n): UseCSSTransition<Ref> => {\n  const onEnter = useStableCallback(onEnterProp || noop);\n  const onEntering = useStableCallback(onEnteringProp || noop);\n  const onEntered = useStableCallback(onEnteredProp || noop);\n  const onExit = useStableCallback(onExitProp || noop);\n  const onExiting = useStableCallback(onExitingProp || noop);\n  const onExited = useStableCallback(onExitedProp || noop);\n  const timerRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  const ref = useRef<Ref | null>(null);\n  const [state, setState] = useState<UseCSSTransitionState>(() => {\n    if (!inProp) {\n      return 'exited';\n    }\n\n    if (enableAppear) {\n      onEnter(true);\n      return 'appear';\n    }\n\n    return 'entered';\n  });\n\n  const clearTimer = () => {\n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n    }\n  };\n\n  useIsomorphicLayoutEffect(\n    function updateState() {\n      if (inProp) {\n        switch (state) {\n          case 'appear':\n            forceReflowForFixNewMountedElement(ref.current);\n            setState('appearing');\n            onEntering(true);\n            break;\n          case 'enter':\n            forceReflowForFixNewMountedElement(ref.current);\n            setState('entering');\n            onEntering();\n            break;\n          case 'exiting':\n            if (enableEnter) {\n              setState('entering');\n              onEntering();\n              break;\n            }\n\n            setState('entered');\n            onEntered();\n            break;\n          case 'exited':\n            if (enableEnter) {\n              setState('enter');\n              onEnter();\n              break;\n            }\n\n            setState('entered');\n            onEntered();\n            break;\n        }\n      } else {\n        switch (state) {\n          case 'exit':\n            forceReflowForFixNewMountedElement(ref.current);\n            setState('exiting');\n            onExiting();\n            break;\n          case 'appearing':\n          case 'entering':\n            if (enableExit) {\n              setState('exiting');\n              onExiting();\n              break;\n            }\n\n            setState('exited');\n            onExited();\n            break;\n          case 'appeared':\n          case 'entered':\n            if (enableExit) {\n              setState('exit');\n              onExit();\n              break;\n            }\n\n            setState('exited');\n            onExited();\n            break;\n        }\n      }\n    },\n    [\n      inProp,\n\n      state,\n      enableAppear,\n      enableEnter,\n      onEnter,\n      onEntering,\n      onEntered,\n\n      enableExit,\n      onExit,\n      onExiting,\n      onExited,\n    ],\n  );\n\n  const completeTransition = useStableCallback((event?: TransitionEvent) => {\n    clearTimer();\n\n    switch (state) {\n      case 'appearing':\n        setState('appeared');\n        onEntered(event?.propertyName, true);\n        break;\n      case 'entering':\n        setState('entered');\n        onEntered(event?.propertyName);\n        break;\n      case 'exiting':\n        setState('exited');\n        onExited(event?.propertyName);\n        break;\n    }\n  });\n\n  useIsomorphicLayoutEffect(\n    function scheduleTransitionCompletionFallback() {\n      const el = ref.current;\n      if (!el) {\n        return;\n      }\n\n      if (state === 'appearing' || state === 'entering' || state === 'exiting') {\n        const style = getComputedStyle(el);\n\n        const parseTime = (s: string) =>\n          s.includes('ms') ? parseFloat(s) : parseFloat(s) * millisecondsInSecond;\n\n        const duration =\n          Math.max(...style.transitionDuration.split(',').map(parseTime)) +\n          Math.max(...style.transitionDelay.split(',').map(parseTime));\n\n        if (duration <= 0) {\n          completeTransition();\n          return;\n        }\n\n        // fallback если onTransitionEnd не пришёл\n        // TRANSITION_FALLBACK_DELAY, чтобы минимизировать вероятность,\n        // что setTimeout сработает раньше onTransitionEnd\n        timerRef.current = setTimeout(completeTransition, duration + TRANSITION_FALLBACK_DELAY);\n\n        return clearTimer;\n      }\n      return;\n    },\n    [completeTransition, state],\n  );\n\n  return [\n    state,\n    {\n      ref,\n      onTransitionEnd:\n        state !== 'appeared' && state !== 'entered' && state !== 'exited'\n          ? completeTransition\n          : undefined,\n    },\n  ];\n};\n"],"names":["useRef","useState","noop","useStableCallback","millisecondsInSecond","useIsomorphicLayoutEffect","forceReflowForFixNewMountedElement","node","scrollTop","TRANSITION_FALLBACK_DELAY","useCSSTransition","inProp","enableAppear","enableEnter","enableExit","onEnter","onEnterProp","onEntering","onEnteringProp","onEntered","onEnteredProp","onExit","onExitProp","onExiting","onExitingProp","onExited","onExitedProp","timerRef","ref","state","setState","clearTimer","current","clearTimeout","updateState","completeTransition","event","propertyName","scheduleTransitionCompletionFallback","el","style","getComputedStyle","parseTime","s","includes","parseFloat","duration","Math","max","transitionDuration","split","map","transitionDelay","setTimeout","onTransitionEnd","undefined"],"mappings":"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"}