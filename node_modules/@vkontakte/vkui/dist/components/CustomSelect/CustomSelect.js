'use client';
import { _ as _object_spread } from "@swc/helpers/_/_object_spread";
import { _ as _object_spread_props } from "@swc/helpers/_/_object_spread_props";
import { _ as _object_without_properties } from "@swc/helpers/_/_object_without_properties";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import * as React from "react";
import { classNames } from "@vkontakte/vkjs";
import { getRequiredValueByKey } from "../../helpers/getValueByKey.js";
import { useAdaptivity } from "../../hooks/useAdaptivity.js";
import { useExternRef } from "../../hooks/useExternRef.js";
import { useMergeProps } from "../../hooks/useMergeProps.js";
import { callMultiple } from "../../lib/callMultiple.js";
import { useDOM } from "../../lib/dom.js";
import { defaultFilterFn } from "../../lib/select.js";
import { useIsomorphicLayoutEffect } from "../../lib/useIsomorphicLayoutEffect.js";
import { preventDefault } from "../../lib/utils.js";
import { CustomSelectDropdown } from "../CustomSelectDropdown/CustomSelectDropdown.js";
import { CustomSelectOption } from "../CustomSelectOption/CustomSelectOption.js";
import { NOT_SELECTED, remapFromNativeValueToSelectValue } from "../NativeSelect/NativeSelect.js";
import { RootComponent } from "../RootComponent/RootComponent.js";
import { Footnote } from "../Typography/Footnote/Footnote.js";
import { VisuallyHidden } from "../VisuallyHidden/VisuallyHidden.js";
import { CustomSelectInput } from "./CustomSelectInput/CustomSelectInput.js";
import { checkDeprecatedProps, checkMixControlledAndUncontrolledState, checkOptionsValueType, filter, findSelectedIndex, getOptionByValue } from "./helpers.js";
import { useAfterItems } from "./hooks/useAfterItems.js";
import { useDropdownOpenedController } from "./hooks/useDropdownOpenedController.js";
import { useFocusedOptionController } from "./hooks/useFocusedOptionController.js";
import { useInputKeyboardController } from "./hooks/useInputKeyboardController.js";
import { useInputValueController } from "./hooks/useInputValueController.js";
import { useScrollListController } from "./hooks/useScrollListController.js";
import { useSelectedOptionController } from "./hooks/useSelectedOptionController.js";
const sizeYClassNames = {
    none: "vkuiCustomSelect__sizeYNone",
    compact: "vkuiCustomSelect__sizeYCompact"
};
function defaultRenderOptionFn(_param) {
    var { option } = _param, props = _object_without_properties(_param, [
        "option"
    ]);
    return /*#__PURE__*/ _jsx(CustomSelectOption, _object_spread({}, props));
}
function isMousePositionChanged(event, prevPosition) {
    return Math.abs(prevPosition.x - event.clientX) >= 1 || Math.abs(prevPosition.y - event.clientY) >= 1;
}
const FETCH_STATUS_RESET_DELAY = 2000;
const FetchingStatus = ({ fetching = false, options, fetchingInProgressLabel = 'Список опций загружается...', fetchingCompletedLabel = `Загружено опций: ${options.length}` })=>{
    const [status, setStatus] = React.useState('none');
    const content = getRequiredValueByKey(status, {
        fetching: fetchingInProgressLabel,
        loaded: typeof fetchingCompletedLabel === 'function' ? fetchingCompletedLabel(options.length) : fetchingCompletedLabel,
        none: ''
    });
    useIsomorphicLayoutEffect(function updateStatus() {
        if (fetching) {
            setStatus('fetching');
        } else {
            if (status === 'fetching') {
                setStatus('loaded');
                setTimeout(()=>setStatus('none'), FETCH_STATUS_RESET_DELAY);
            }
        }
    }, [
        fetching
    ]);
    return /*#__PURE__*/ _jsx(VisuallyHidden, {
        "aria-live": "polite",
        children: content
    });
};
/**
 * @see https://vkui.io/components/custom-select
 */ export function CustomSelect(props) {
    const { style, className, getRootRef, before, name, getRef, popupDirection = 'bottom', onChange, children, 'onInputChange': onInputChangeProp, renderDropdown, onOpen, onClose, fetching, labelTextTestId, multiline, placeholder, status, forceDropdownPortal, align, selectType = 'default', searchable = false, 'renderOption': renderOptionProp = defaultRenderOptionFn, 'options': options, emptyText = 'Ничего не найдено', filterFn = defaultFilterFn, 'icon': iconProp, ClearButton, allowClearButton = false, dropdownOffsetDistance = 0, dropdownAutoWidth = false, noMaxHeight = false, 'aria-labelledby': ariaLabelledBy, clearButtonTestId, nativeSelectTestId, defaultValue, required, getSelectInputRef, overscrollBehavior, 'onInputKeyDown': onInputKeyDownProp, accessible = false, fetchingInProgressLabel, fetchingCompletedLabel, 'value': selectValue, 'onBlur': onSelectBlur, 'onFocus': onSelectFocus, 'onClick': onSelectClick, slotProps } = props, restProps = _object_without_properties(props, [
        "style",
        "className",
        "getRootRef",
        "before",
        "name",
        "getRef",
        "popupDirection",
        "onChange",
        "children",
        'onInputChange',
        "renderDropdown",
        "onOpen",
        "onClose",
        "fetching",
        "labelTextTestId",
        "multiline",
        "placeholder",
        "status",
        "forceDropdownPortal",
        "align",
        "selectType",
        "searchable",
        'renderOption',
        'options',
        "emptyText",
        "filterFn",
        'icon',
        "ClearButton",
        "allowClearButton",
        "dropdownOffsetDistance",
        "dropdownAutoWidth",
        "noMaxHeight",
        'aria-labelledby',
        "clearButtonTestId",
        "nativeSelectTestId",
        "defaultValue",
        "required",
        "getSelectInputRef",
        "overscrollBehavior",
        'onInputKeyDown',
        "accessible",
        "fetchingInProgressLabel",
        "fetchingCompletedLabel",
        'value',
        'onBlur',
        'onFocus',
        'onClick',
        "slotProps"
    ]);
    if (process.env.NODE_ENV === 'development') {
        checkOptionsValueType(options);
        checkDeprecatedProps(props);
    }
    const { sizeY = 'none' } = useAdaptivity();
    const _useMergeProps = useMergeProps({
        style,
        className,
        getRootRef
    }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.root), { onClick: onRootClick, onMouseMove: onRootMouseMove, onMouseDown: onRootMouseDown, getRootRef: rootRef } = _useMergeProps, rootRest = _object_without_properties(_useMergeProps, [
        "onClick",
        "onMouseMove",
        "onMouseDown",
        "getRootRef"
    ]);
    const _useMergeProps1 = useMergeProps({
        getRootRef: getRef,
        onBlur: onSelectBlur,
        onFocus: onSelectFocus,
        onClick: onSelectClick
    }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.select), { getRootRef: getSelectRef } = _useMergeProps1, selectRest = _object_without_properties(_useMergeProps1, [
        "getRootRef"
    ]);
    const _useMergeProps2 = useMergeProps(_object_spread({
        getRootRef: getSelectInputRef,
        onChange: onInputChangeProp
    }, restProps), slotProps === null || slotProps === void 0 ? void 0 : slotProps.input), { getRootRef: getInputRef, onChange: onChangeInput, onFocus: onInputFocus, onBlur: onInputBlur, onKeyDown: onNativeInputKeyDown, onClick: onNativeInputClick, readOnly } = _useMergeProps2, inputRest = _object_without_properties(_useMergeProps2, [
        "getRootRef",
        "onChange",
        "onFocus",
        "onBlur",
        "onKeyDown",
        "onClick",
        "readOnly"
    ]);
    const containerRef = React.useRef(null);
    const handleRootRef = useExternRef(containerRef, rootRef);
    const selectElRef = useExternRef(getSelectRef);
    const selectInputRef = useExternRef(getInputRef);
    const propsValue = React.useMemo(()=>{
        var _getOptionByValue;
        if (selectValue === undefined) {
            return undefined;
        }
        var _getOptionByValue_value;
        return (_getOptionByValue_value = (_getOptionByValue = getOptionByValue(options, selectValue)) === null || _getOptionByValue === void 0 ? void 0 : _getOptionByValue.value) !== null && _getOptionByValue_value !== void 0 ? _getOptionByValue_value : null;
    }, [
        options,
        selectValue
    ]);
    const [isControlledOutside, setIsControlledOutside] = React.useState(selectValue !== undefined);
    const [popperPlacement, setPopperPlacement] = React.useState(popupDirection);
    const { nativeSelectValue, setNativeSelectValue, selectedOptionValue, setSelectedOptionValue, onNativeSelectChange } = useSelectedOptionController({
        value: propsValue,
        defaultValue,
        isControlledOutside,
        allowClearButton,
        onChange
    });
    const selected = React.useMemo(()=>options.find((option)=>option.value === selectedOptionValue), [
        options,
        selectedOptionValue
    ]);
    const { inputValue, onInputChange, resetInputValue, resetInputValueBySelectedOption } = useInputValueController({
        options,
        accessible,
        selectedValue: selectedOptionValue,
        onInputChange: onChangeInput
    });
    const filteredOptions = React.useMemo(()=>filter(options, searchable ? inputValue : '', filterFn), [
        filterFn,
        inputValue,
        options,
        searchable
    ]);
    const { scrollToElement, optionsWrapperRef, scrollBoxRef } = useScrollListController();
    const { focusedOptionValue, setFocusedOptionValue, resetFocusedOption, focusOptionByIndex, focusOption, selectFocusedValue } = useFocusedOptionController({
        selectedOptionValue,
        filteredOptions,
        scrollToElement
    });
    const scrollToSelectedOption = ()=>{
        scrollToElement(findSelectedIndex(filteredOptions, selectedOptionValue), true);
    };
    const { opened, open, close, toggleOpened } = useDropdownOpenedController({
        onOpen: callMultiple(selectFocusedValue, onOpen),
        onOpened: scrollToSelectedOption,
        onClose,
        onClosed: accessible ? resetInputValueBySelectedOption : resetInputValue
    });
    React.useEffect(function updateOptionsValue() {
        const value = propsValue !== undefined ? propsValue : remapFromNativeValueToSelectValue(nativeSelectValue);
        setSelectedOptionValue(value);
        setFocusedOptionValue(value);
    }, [
        propsValue,
        nativeSelectValue,
        setFocusedOptionValue,
        setSelectedOptionValue
    ]);
    React.useEffect(function syncIsControlledState() {
        setIsControlledOutside((oldIsControlled)=>{
            const newIsControlled = propsValue !== undefined;
            checkMixControlledAndUncontrolledState(oldIsControlled, newIsControlled);
            return newIsControlled;
        });
    }, [
        propsValue
    ]);
    useIsomorphicLayoutEffect(()=>{
        if (filteredOptions.some(({ value })=>nativeSelectValue === value) || allowClearButton && nativeSelectValue === NOT_SELECTED.NATIVE) {
            var _selectElRef_current;
            const event = new Event('change', {
                bubbles: true
            });
            (_selectElRef_current = selectElRef.current) === null || _selectElRef_current === void 0 ? void 0 : _selectElRef_current.dispatchEvent(event);
        }
    }, [
        nativeSelectValue
    ]);
    const openedClassNames = React.useMemo(()=>opened && dropdownOffsetDistance === 0 && (popperPlacement.includes('top') ? "vkuiCustomSelect__popUp" : "vkuiCustomSelect__popDown") || undefined, [
        dropdownOffsetDistance,
        opened,
        popperPlacement
    ]);
    const selectOption = React.useCallback((value)=>{
        setNativeSelectValue(value !== null && value !== void 0 ? value : NOT_SELECTED.NATIVE);
        close();
        const shouldTriggerOnChangeWhenControlledAndInnerValueIsOutOfSync = isControlledOutside && propsValue !== nativeSelectValue && nativeSelectValue === value;
        if (shouldTriggerOnChangeWhenControlledAndInnerValueIsOutOfSync) {
            var _selectElRef_current;
            const event = new Event('change', {
                bubbles: true
            });
            (_selectElRef_current = selectElRef.current) === null || _selectElRef_current === void 0 ? void 0 : _selectElRef_current.dispatchEvent(event);
        }
    }, [
        close,
        setNativeSelectValue,
        isControlledOutside,
        propsValue,
        nativeSelectValue,
        selectElRef
    ]);
    const selectFocused = React.useCallback(()=>{
        if (focusedOptionValue === null) {
            return;
        }
        selectOption(focusedOptionValue);
    }, [
        focusedOptionValue,
        selectOption
    ]);
    const handleInputKeyDown = useInputKeyboardController({
        opened,
        open,
        close,
        resetFocusedOption,
        selectFocused,
        focusOption,
        scrollBoxRef,
        onInputKeyDown: onInputKeyDownProp
    });
    const onBlur = React.useCallback(()=>{
        var _selectElRef_current;
        close();
        const event = new Event('focusout', {
            bubbles: true
        });
        (_selectElRef_current = selectElRef.current) === null || _selectElRef_current === void 0 ? void 0 : _selectElRef_current.dispatchEvent(event);
    }, [
        close,
        selectElRef
    ]);
    const onFocus = React.useCallback(()=>{
        var _selectElRef_current;
        const event = new Event('focusin', {
            bubbles: true
        });
        (_selectElRef_current = selectElRef.current) === null || _selectElRef_current === void 0 ? void 0 : _selectElRef_current.dispatchEvent(event);
    }, [
        selectElRef
    ]);
    const handleOptionClick = React.useCallback((e)=>{
        var _e_currentTarget_parentNode;
        const index = Array.prototype.indexOf.call((_e_currentTarget_parentNode = e.currentTarget.parentNode) === null || _e_currentTarget_parentNode === void 0 ? void 0 : _e_currentTarget_parentNode.children, e.currentTarget);
        const option = filteredOptions[index];
        if (option && !option.disabled) {
            selectOption(option.value);
        }
    }, [
        filteredOptions,
        selectOption
    ]);
    const lastMousePositionRef = React.useRef({
        x: 0,
        y: 0
    });
    const focusOptionOnMouseMove = React.useCallback((e, index)=>{
        if (isMousePositionChanged(e, lastMousePositionRef.current)) {
            focusOptionByIndex(index, false);
        }
    }, [
        focusOptionByIndex
    ]);
    const popupAriaId = React.useId();
    const renderOption = React.useCallback((option, index)=>{
        const hovered = option.value === focusedOptionValue;
        const selected = option.value === selectedOptionValue;
        return /*#__PURE__*/ _jsx(React.Fragment, {
            children: renderOptionProp(_object_spread({
                option,
                hovered,
                children: option.label,
                selected,
                disabled: option.disabled,
                onClick: handleOptionClick,
                onMouseDown: preventDefault,
                // Используем `onMouseMove` вместо `onMouseEnter/onMouseOver`.
                // Потому что если при навигации с клавиатуры курсор наведён на
                // список, то при первом автоматическом скролле списка вызывается событие MouseOver/MouseEnter
                // обработчик которого фокусирует опцию под курсором, хотя при навигация с клавиатуры пользователь мог уйти дальше по списку, это путает.
                // Причём координаты события меняются на пару пикселей по сравнению с прошлым вызовом,
                // а значит нельзя на них опираться, чтобы запретить обработку такого события.
                // C mousemove такой проблемы нет, что позволяет реализовать поведение при наведении с клавиатуры и при наведении мышью идентично `<select>`.
                onMouseMove: (e)=>focusOptionOnMouseMove(e, index),
                id: `${popupAriaId}-${option.value}`
            }, option))
        }, `${typeof option.value}-${option.value}`);
    }, [
        focusedOptionValue,
        selectedOptionValue,
        renderOptionProp,
        handleOptionClick,
        popupAriaId,
        focusOptionOnMouseMove
    ]);
    const resolvedContent = React.useMemo(()=>{
        const defaultDropdownContent = filteredOptions.length > 0 ? /*#__PURE__*/ _jsx("div", {
            ref: optionsWrapperRef,
            children: filteredOptions.map(renderOption)
        }) : /*#__PURE__*/ _jsx(Footnote, {
            className: "vkuiCustomSelect__empty",
            children: emptyText
        });
        if (typeof renderDropdown === 'function') {
            return renderDropdown({
                defaultDropdownContent
            });
        } else {
            return defaultDropdownContent;
        }
    }, [
        emptyText,
        filteredOptions,
        optionsWrapperRef,
        renderDropdown,
        renderOption
    ]);
    const afterItems = useAfterItems({
        value: propsValue,
        nativeSelectValue,
        isControlledOutside,
        opened,
        allowClearButton,
        ClearButton,
        onClearButtonClick: ()=>{
            setNativeSelectValue(NOT_SELECTED.NATIVE);
            resetInputValue();
            selectInputRef.current && selectInputRef.current.focus();
        },
        clearButtonTestId,
        disabled: restProps.disabled,
        readOnly,
        icon: iconProp
    });
    const { document } = useDOM();
    const passClickAndFocusToInputOnClick = React.useCallback((e)=>{
        // Раньше внешней оберткой CustomSelect был <label>, что позволяло по клику в любую область CustomSelect,
        // даже где нету интерактивного элемента, фокусировать <input> и передавать на него событие клика.
        // Так как мы больше не оборачиваем CustomSelect в <label>, то для обертки CustomSelect мы симулируем работу <label>.
        // передаем фокус и клик по <input>, если пользователь кликнул в зоне обертки.
        // В <label> мы не больше не оборачиваем, потому что это заставляет скринридер
        // дважды произносить текст выбранной опции при фокусе, если CustomSelect связан с внешним <label>.
        // Воспроизводится в некоторых версиях Chrome, при навигации по странице с помощью стрелок.
        // Договорились со специалистом по доступности убрать <label>-обёртки из Select и CustomSelect
        if (!selectInputRef.current || !document) {
            return;
        }
        const clickTargetIsNotAnInput = e.target !== selectInputRef.current;
        if (clickTargetIsNotAnInput) {
            selectInputRef.current.click();
            const inputIsNotFocused = document.activeElement !== selectInputRef.current;
            if (inputIsNotFocused) {
                selectInputRef.current.focus();
            }
        }
    }, [
        document,
        selectInputRef
    ]);
    const preventInputBlurWhenClickInsideFocusedSelectArea = (e)=>{
        // Так как инпут больше не оборачивается пустым лэйблом, то клик внутри обертки,
        // но вне инпута (например по иконке дропдауна), будет убирать фокус с инпута.
        // Чтобы в такой ситуации отключить blur инпута мы превентим mousedown событие обёртки
        const isInputFocused = document && document.activeElement === selectInputRef.current;
        if (isInputFocused) {
            e.preventDefault();
        }
    };
    const ariaActiveDescendantId = focusedOptionValue !== null ? focusedOptionValue : undefined;
    const selectInputAriaProps = {
        'role': 'combobox',
        'aria-controls': popupAriaId,
        'aria-expanded': opened,
        'aria-activedescendant': ariaActiveDescendantId && opened ? `${popupAriaId}-${ariaActiveDescendantId}` : undefined,
        'aria-labelledby': ariaLabelledBy,
        'aria-haspopup': 'listbox',
        'aria-autocomplete': 'none'
    };
    const resetOptionFocusOnMouseLeave = React.useCallback((event)=>{
        // В Хроме eсли мышка пользователя находится над инпутом селекта,
        // и он с клавиатуры открывает опции, причём одна из опций
        // уже выбрана, то видно, как выбранная опция получает фокус,
        // но потом сразу же его теряет.
        // Связано это с тем, что в этот момент вызывается onMouseLeave, на который у нас
        // завязан сброс состония фокуса у опции. По хорошему фокус должен оставаться.
        // Нам не интересен вызов onMouseLeave если мышка при этом не двигалась.
        if (isMousePositionChanged(event, lastMousePositionRef.current)) {
            resetFocusedOption();
        }
    }, [
        resetFocusedOption
    ]);
    const updateLastMousePosition = (e)=>{
        lastMousePositionRef.current = {
            x: e.clientX,
            y: e.clientY
        };
    };
    return /*#__PURE__*/ _jsxs(RootComponent, _object_spread_props(_object_spread({
        baseClassName: classNames("vkuiCustomSelect__host", sizeY !== 'regular' && sizeYClassNames[sizeY]),
        getRootRef: handleRootRef,
        onClick: callMultiple(onRootClick, passClickAndFocusToInputOnClick),
        onMouseDown: callMultiple(onRootMouseDown, preventInputBlurWhenClickInsideFocusedSelectArea),
        onMouseMove: callMultiple(onRootMouseMove, updateLastMousePosition)
    }, rootRest), {
        children: [
            /*#__PURE__*/ _jsx(CustomSelectInput, {
                autoComplete: "off",
                autoCapitalize: "none",
                autoCorrect: "off",
                spellCheck: "false",
                fetching: fetching,
                searchable: searchable,
                accessible: accessible,
                before: before,
                after: afterItems,
                selectType: selectType,
                align: align,
                status: status,
                placeholder: placeholder,
                multiline: multiline,
                labelTextTestId: labelTextTestId,
                slotProps: {
                    root: {
                        className: openedClassNames
                    },
                    input: _object_spread({
                        getRootRef: selectInputRef,
                        onChange: onInputChange,
                        onFocus: callMultiple(onFocus, onInputFocus),
                        onBlur: callMultiple(onBlur, onInputBlur),
                        onKeyDown: !readOnly ? callMultiple(handleInputKeyDown, onNativeInputKeyDown) : onNativeInputKeyDown,
                        onClick: !readOnly ? callMultiple(toggleOpened, onNativeInputClick) : onNativeInputClick,
                        value: inputValue,
                        readOnly: readOnly || !searchable
                    }, selectInputAriaProps, inputRest)
                },
                children: selected === null || selected === void 0 ? void 0 : selected.label
            }),
            /*#__PURE__*/ _jsx(FetchingStatus, {
                fetching: fetching,
                options: filteredOptions,
                fetchingInProgressLabel: fetchingInProgressLabel,
                fetchingCompletedLabel: fetchingCompletedLabel
            }),
            /*#__PURE__*/ _jsxs(RootComponent, _object_spread_props(_object_spread({
                Component: "select",
                baseClassName: "vkuiCustomSelect__control",
                tabIndex: -1,
                name: name,
                value: nativeSelectValue,
                "aria-hidden": true,
                "data-testid": nativeSelectTestId,
                required: required,
                onChange: onNativeSelectChange,
                getRootRef: selectElRef
            }, selectRest), {
                children: [
                    (allowClearButton || nativeSelectValue === NOT_SELECTED.NATIVE) && /*#__PURE__*/ _jsx("option", {
                        value: NOT_SELECTED.NATIVE
                    }, NOT_SELECTED.NATIVE),
                    options.map((item)=>/*#__PURE__*/ _jsx("option", {
                            value: item.value
                        }, `${item.value}`))
                ]
            })),
            opened && /*#__PURE__*/ _jsx(CustomSelectDropdown, {
                targetRef: containerRef,
                placement: popperPlacement,
                scrollBoxRef: scrollBoxRef,
                onPlacementChange: setPopperPlacement,
                onMouseLeave: resetOptionFocusOnMouseLeave,
                fetching: fetching,
                overscrollBehavior: overscrollBehavior,
                offsetDistance: dropdownOffsetDistance,
                autoWidth: dropdownAutoWidth,
                forcePortal: forceDropdownPortal,
                noMaxHeight: noMaxHeight,
                role: "listbox",
                id: popupAriaId,
                "aria-labelledby": ariaLabelledBy,
                tabIndex: -1,
                children: resolvedContent
            })
        ]
    }));
}

//# sourceMappingURL=CustomSelect.js.map