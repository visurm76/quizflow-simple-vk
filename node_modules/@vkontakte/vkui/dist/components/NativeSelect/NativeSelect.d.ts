import { type ChangeEvent } from 'react';
import * as React from 'react';
import type { HasAlign, HasDataAttribute, HasRootRef } from '../../types';
import { type FormFieldProps } from '../FormField/FormField';
import type { SelectType } from '../Select/Select';
export type SelectValue = Exclude<React.SelectHTMLAttributes<HTMLSelectElement>['value'], undefined> | null;
export type NativeSelectValue = Exclude<SelectValue, null>;
export declare const NOT_SELECTED: {
    NATIVE: string;
    CUSTOM: null;
};
/**
 * @visibleName NativeSelect
 */
export declare const remapFromSelectValueToNativeValue: (value: SelectValue) => NativeSelectValue;
export declare const remapFromNativeValueToSelectValue: (value: NativeSelectValue) => SelectValue;
export type NativeHTMLSelectProps = Omit<React.SelectHTMLAttributes<HTMLSelectElement>, 'multiple' | 'value' | 'defaultValue' | 'onChange'>;
export interface NativeSelectProps extends NativeHTMLSelectProps, HasRootRef<HTMLDivElement>, HasAlign, Pick<FormFieldProps, 'before' | 'status'> {
    /**
     * Свойства, которые можно прокинуть внутрь компонента:
     * - `root`: свойства для прокидывания в корень компонента;
     * - `select`: свойства для прокидывания в нативный `select`.
     */
    slotProps?: {
        root?: Omit<React.HTMLAttributes<HTMLDivElement>, 'children'> & HasDataAttribute & HasRootRef<HTMLDivElement>;
        select?: NativeHTMLSelectProps & HasRootRef<HTMLSelectElement> & HasDataAttribute;
    };
    /**
     * @deprecated Since 7.9.0. Вместо этого используйте `slotProps={ select: { getRootRef: ... } }`.
     */
    getRef?: React.Ref<HTMLSelectElement>;
    /**
     * Выбранное значение.
     *
     * > ⚠️  Важно: При прокидывании `undefined` компонент будет считаться `Uncontrolled`.
     * >
     * > Не используйте `undefined`, чтобы показать невыбранное состояние. Вместо этого используйте `null`.
     */
    value?: SelectValue;
    /**
     * См. `value`.
     */
    defaultValue?: SelectValue;
    /**
     * Обработчик, срабатывающий при изменении выбранного значения.
     * Вторым параметром прокидывается новое значение.
     *
     * > ⚠️ Лучше использовать второй параметр при работе с компонентом.
     */
    onChange?: (e: ChangeEvent<HTMLSelectElement>, newValue: SelectValue) => void;
    /**
     * Текст-подсказка при отсутствии выбранного значения.
     */
    placeholder?: string;
    /**
     * Флаг для включения многострочного режима.
     */
    multiline?: boolean;
    /**
     * Тип селекта, влияющий на отображение.
     */
    selectType?: SelectType;
    /**
     * Иконка раскрывающегося списка.
     */
    icon?: React.ReactNode;
}
/**
 * @see https://vkui.io/components/native-select
 */
export declare const NativeSelect: ({ style: rootStyle, className: rootClassName, getRootRef: rootGetRootRef, align, placeholder, children, getRef, multiline, selectType, status, icon, before, onChange, value, defaultValue, slotProps, ...restProps }: NativeSelectProps) => React.ReactNode;
//# sourceMappingURL=NativeSelect.d.ts.map