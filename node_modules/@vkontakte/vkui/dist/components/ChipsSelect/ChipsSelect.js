'use client';
import { _ as _object_spread } from "@swc/helpers/_/_object_spread";
import { _ as _object_spread_props } from "@swc/helpers/_/_object_spread_props";
import { _ as _object_without_properties } from "@swc/helpers/_/_object_without_properties";
import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import * as React from "react";
import { classNames } from "@vkontakte/vkjs";
import { useExternRef } from "../../hooks/useExternRef.js";
import { useGlobalOnEventOutside } from "../../hooks/useGlobalOnClickOutside.js";
import { useMergeProps } from "../../hooks/useMergeProps.js";
import { Keys } from "../../lib/accessibility.js";
import { defaultFilterFn } from "../../lib/select.js";
import { ChipsInputBase } from "../ChipsInputBase/ChipsInputBase.js";
import { getNewOptionDataDefault, getOptionLabelDefault, getOptionValueDefault, renderChipDefault } from "../ChipsInputBase/constants.js";
import { CustomSelectDropdown } from "../CustomSelectDropdown/CustomSelectDropdown.js";
import { CustomSelectOption } from "../CustomSelectOption/CustomSelectOption.js";
import { DropdownIcon } from "../DropdownIcon/DropdownIcon.js";
import { Footnote } from "../Typography/Footnote/Footnote.js";
import { DEFAULT_EMPTY_TEXT, DEFAULT_SELECTED_BEHAVIOR, FOCUS_ACTION_NEXT, FOCUS_ACTION_PREV, isCreateNewOptionPreset, isEmptyOptionPreset, isNotServicePreset, renderOptionDefault } from "./constants.js";
import { useChipsSelect } from "./useChipsSelect.js";
const findIndexAfter = (options = [], startIndex = -1)=>{
    if (startIndex >= options.length - 1) {
        return -1;
    }
    return options.findIndex((option, i)=>i > startIndex && (!isNotServicePreset(option) || !option.disabled));
};
const findIndexBefore = (options = [], endIndex = options.length)=>{
    let result = -1;
    if (endIndex <= 0) {
        return result;
    }
    for(let i = endIndex - 1; i >= 0; i--){
        let option = options[i];
        if (!isNotServicePreset(option) || !option.disabled) {
            result = i;
            break;
        }
    }
    return result;
};
/**
 * @see https://vkui.io/components/chips-select
 */ export const ChipsSelect = (_param)=>{
    var { // FormFieldProps
    getRootRef, className, status = 'default', icon: dropdownIconProp, onChangeStart, // CustomSelectDropdownProps
    options: optionsProp, placement: placementProp = 'bottom', closeAfterSelect = true, selectedBehavior = DEFAULT_SELECTED_BEHAVIOR, emptyText = DEFAULT_EMPTY_TEXT, creatable = false, fetching = false, dropdownAutoWidth, forceDropdownPortal, noMaxHeight = false, filterFn = defaultFilterFn, sortFn = false, dropdownTestId, onClose, onOpen, overscrollBehavior, renderDropdown, // ChipsInputProps
    getRef, value: valueProp, defaultValue, inputValue: inputValueProp, defaultInputValue: defaultInputValueProp, getOptionValue = getOptionValueDefault, getOptionLabel = getOptionLabelDefault, getNewOptionData = getNewOptionDataDefault, renderChip = renderChipDefault, renderOption = renderOptionDefault, onChange, onInputChange: onInputChangeProp, dropdownOffsetDistance = 0, allowClearButton, clearButtonTestId, delimiter, // a11y
    chipsListLabel, // input native props
    disabled: disabledProp, readOnly: readOnlyProp, id: idProp, onFocus: onFocusProp, onBlur: onBlurProp, onKeyDown: onKeyDownProp, slotProps } = _param, restProps = _object_without_properties(_param, [
        "getRootRef",
        "className",
        "status",
        "icon",
        "onChangeStart",
        "options",
        "placement",
        "closeAfterSelect",
        "selectedBehavior",
        "emptyText",
        "creatable",
        "fetching",
        "dropdownAutoWidth",
        "forceDropdownPortal",
        "noMaxHeight",
        "filterFn",
        "sortFn",
        "dropdownTestId",
        "onClose",
        "onOpen",
        "overscrollBehavior",
        "renderDropdown",
        "getRef",
        "value",
        "defaultValue",
        "inputValue",
        "defaultInputValue",
        "getOptionValue",
        "getOptionLabel",
        "getNewOptionData",
        "renderChip",
        "renderOption",
        "onChange",
        "onInputChange",
        "dropdownOffsetDistance",
        "allowClearButton",
        "clearButtonTestId",
        "delimiter",
        "chipsListLabel",
        "disabled",
        "readOnly",
        "id",
        "onFocus",
        "onBlur",
        "onKeyDown",
        "slotProps"
    ]);
    const _useMergeProps = useMergeProps({
        getRootRef: getRef,
        value: inputValueProp,
        defaultValue: defaultInputValueProp,
        onChange: onInputChangeProp,
        disabled: disabledProp,
        readOnly: readOnlyProp,
        id: idProp,
        onFocus: onFocusProp,
        onBlur: onBlurProp,
        onKeyDown: onKeyDownProp
    }, slotProps === null || slotProps === void 0 ? void 0 : slotProps.input), { getRootRef: getInputRef, value: resolvedInputValue, defaultValue: resolvedDefaultInputValue, onChange: resolvedOnInputChange, disabled, readOnly, id: labelledbyId, onFocus, onBlur, onKeyDown } = _useMergeProps, inputRest = _object_without_properties(_useMergeProps, [
        "getRootRef",
        "value",
        "defaultValue",
        "onChange",
        "disabled",
        "readOnly",
        "id",
        "onFocus",
        "onBlur",
        "onKeyDown"
    ]);
    const { // Связано с ChipsInputProps
    // option
    value, addOptionFromInput, addOption, removeOption, clearOptions, // input
    inputRef: inputRefHook, inputValue, clearInput, onInputChange, // Связано с CustomSelectDropdownProps
    options, opened, setOpened, focusedOption, focusedOptionIndex, setFocusedOption, setFocusedOptionIndex } = useChipsSelect({
        // option
        value: valueProp,
        defaultValue,
        onChange,
        getOptionValue,
        getOptionLabel,
        getNewOptionData,
        // input
        inputValue: resolvedInputValue,
        defaultInputValue: resolvedDefaultInputValue,
        onInputChange: resolvedOnInputChange,
        // dropdown
        options: optionsProp,
        emptyText,
        creatable,
        filterFn,
        sortFn,
        selectedBehavior,
        onClose,
        onOpen,
        // other
        disabled,
        delimiter
    });
    // Связано с ChipsInputProps
    const rootRef = useExternRef(getRootRef);
    const inputRef = useExternRef(getInputRef, inputRefHook);
    // Связано с CustomSelectDropdownProps
    const [dropdownVerticalPlacement, setDropdownVerticalPlacement] = React.useState(placementProp);
    const onDropdownPlacementChange = React.useCallback((placement)=>{
        if (placement.startsWith('top')) {
            setDropdownVerticalPlacement('top');
        } else if (placement.startsWith('bottom')) {
            setDropdownVerticalPlacement('bottom');
        }
    }, []);
    const dropdownId = React.useId();
    const dropdownCurrentItemId = focusedOptionIndex !== null ? `${dropdownId}-${focusedOptionIndex}` : undefined;
    const dropdownScrollBoxRef = React.useRef(null);
    const handleFocus = (event)=>{
        if (onFocus) {
            onFocus(event);
        }
        if (!readOnly) {
            setOpened(true);
            setFocusedOptionIndex(null);
        }
    };
    const handleBlur = (event)=>{
        if (onBlur) {
            onBlur(event);
        }
        // Не добавляем значение, если его нужно выбрать строго из списка
        if (!readOnly && !event.defaultPrevented && !creatable) {
            event.preventDefault();
        }
    };
    const chipsSelectOptions = React.useRef([]).current;
    const scrollToElement = (index, center = false)=>{
        const dropdown = dropdownScrollBoxRef.current;
        const item = chipsSelectOptions[index];
        /* istanbul ignore if: невозможный кейс (в SSR вызова этой функции не будет) */ if (!item || !dropdown) {
            return;
        }
        const dropdownHeight = dropdown.offsetHeight;
        const scrollTop = dropdown.scrollTop;
        const itemTop = item.offsetTop;
        const itemHeight = item.offsetHeight;
        /* istanbul ignore next: нет представления как воспроизвести */ if (center) {
            dropdown.scrollTop = itemTop - dropdownHeight / 2 + itemHeight / 2;
        } else if (itemTop + itemHeight > dropdownHeight + scrollTop) {
            dropdown.scrollTop = itemTop - dropdownHeight + itemHeight;
        } else if (itemTop < scrollTop) {
            dropdown.scrollTop = itemTop;
        }
    };
    const focusOptionByIndex = (index, oldIndex)=>{
        if (index === oldIndex) {
            /* istanbul ignore next: нет представления как воспроизвести */ return;
        }
        const option = options[index];
        if (isNotServicePreset(option) && option.disabled) {
            return;
        }
        scrollToElement(index);
        setFocusedOptionIndex(index);
    };
    const focusOption = (nextIndex, type)=>{
        let index = nextIndex === null ? -1 : nextIndex;
        if (type === FOCUS_ACTION_NEXT) {
            const nextIndex = findIndexAfter(options, index);
            index = nextIndex === -1 ? findIndexAfter(options) : nextIndex; // Следующий за index или первый валидный до index
        } else if (type === FOCUS_ACTION_PREV) {
            const beforeIndex = findIndexBefore(options, index);
            index = beforeIndex === -1 ? findIndexBefore(options) : beforeIndex; // Предшествующий index или последний валидный после index
        }
        focusOptionByIndex(index, focusedOptionIndex);
    };
    const handleKeyDown = (event)=>{
        if (onKeyDown) {
            onKeyDown(event);
        }
        if (event.defaultPrevented || readOnly) {
            return;
        }
        switch(event.key){
            case Keys.ARROW_UP:
            case Keys.ARROW_DOWN:
                event.preventDefault();
                if (!opened) {
                    setOpened(true);
                    focusOption(null, FOCUS_ACTION_NEXT);
                } else {
                    focusOption(focusedOptionIndex, event.key === Keys.ARROW_UP ? FOCUS_ACTION_PREV : FOCUS_ACTION_NEXT);
                }
                break;
            case Keys.ENTER:
                {
                    if (!opened) {
                        break;
                    }
                    if (focusedOptionIndex != null) {
                        const foundOption = options[focusedOptionIndex];
                        if (foundOption && isNotServicePreset(foundOption)) {
                            event.preventDefault();
                            if (onChangeStart) {
                                onChangeStart(event, foundOption);
                            }
                            addOption(foundOption);
                            setFocusedOptionIndex(null);
                            clearInput();
                            if (closeAfterSelect) {
                                setOpened(false);
                            }
                            break;
                        }
                    }
                    if (!creatable) {
                        event.preventDefault();
                    }
                    break;
                }
            case Keys.ESCAPE:
            case Keys.TAB:
                if (opened) {
                    setOpened(false);
                }
        }
    };
    React.useEffect(()=>{
        if (focusedOptionIndex === null) {
            setFocusedOption(null);
        } else {
            const foundFocusedOptionIndex = options[focusedOptionIndex];
            if (foundFocusedOptionIndex && isNotServicePreset(foundFocusedOptionIndex)) {
                setFocusedOption(foundFocusedOptionIndex);
            }
        }
    }, [
        options,
        focusedOptionIndex,
        setFocusedOption
    ]);
    const onDropdownMouseLeave = React.useCallback(()=>{
        setFocusedOptionIndex(null);
    }, [
        setFocusedOptionIndex
    ]);
    const handleClickOutside = React.useCallback(()=>{
        setOpened(false);
    }, [
        setOpened
    ]);
    useGlobalOnEventOutside('mousedown', handleClickOutside, opened ? rootRef : null, opened ? dropdownScrollBoxRef : null);
    const onDropdownIconClick = React.useCallback((e)=>{
        e.preventDefault();
        setOpened(!opened);
    }, [
        opened,
        setOpened
    ]);
    const dropdownContent = React.useMemo(()=>{
        const defaultDropdownContent = options.map((option, index)=>{
            const dropdownItemId = `${dropdownId}-${index}`;
            if (isEmptyOptionPreset(option)) {
                return /*#__PURE__*/ _jsx(Footnote, {
                    className: "vkuiChipsSelect__empty",
                    children: option.placeholder
                }, "empty-text");
            }
            if (isCreateNewOptionPreset(option)) {
                return /*#__PURE__*/ _jsx(CustomSelectOption, {
                    id: dropdownItemId,
                    hovered: focusedOptionIndex === index,
                    onMouseDown: ()=>addOptionFromInput(inputValue),
                    onMouseEnter: ()=>setFocusedOptionIndex(index),
                    children: option.actionText
                }, "create-new-option");
            }
            return /*#__PURE__*/ _jsx(React.Fragment, {
                children: renderOption({
                    id: dropdownItemId,
                    disabled: option.disabled,
                    hovered: focusedOption ? getOptionValue(option) === getOptionValue(focusedOption) : false,
                    children: option.label,
                    selected: !!value.find((selectedOption)=>getOptionValue(selectedOption) === getOptionValue(option)),
                    getRootRef (node) {
                        if (node) {
                            chipsSelectOptions[index] = node;
                        }
                    },
                    onMouseDown (event) {
                        if (option.disabled) {
                            return;
                        }
                        if (onChangeStart) {
                            onChangeStart(event, option);
                        }
                        if (!event.defaultPrevented) {
                            closeAfterSelect && setOpened(false);
                            addOption(option);
                            clearInput();
                        }
                    },
                    onMouseEnter () {
                        setFocusedOptionIndex(index);
                    }
                }, option)
            }, `${typeof option.value}-${option.value}`);
        });
        if (renderDropdown) {
            return renderDropdown({
                defaultDropdownContent
            });
        }
        return defaultDropdownContent;
    }, [
        addOption,
        addOptionFromInput,
        chipsSelectOptions,
        clearInput,
        closeAfterSelect,
        dropdownId,
        focusedOption,
        focusedOptionIndex,
        getOptionValue,
        inputValue,
        onChangeStart,
        options,
        renderDropdown,
        renderOption,
        setFocusedOptionIndex,
        setOpened,
        value
    ]);
    const openedClassNames = React.useMemo(()=>opened && dropdownOffsetDistance === 0 && (dropdownVerticalPlacement.includes('top') ? "vkuiChipsSelect__popUp" : "vkuiChipsSelect__popDown") || undefined, [
        dropdownOffsetDistance,
        opened,
        dropdownVerticalPlacement
    ]);
    const clearButtonShown = allowClearButton && (!!value.length || !!inputValue.length);
    return /*#__PURE__*/ _jsxs(_Fragment, {
        children: [
            /*#__PURE__*/ _jsx(ChipsInputBase, _object_spread({
                clearButtonShown: clearButtonShown,
                clearButtonTestId: clearButtonTestId,
                // FormFieldProps
                getRootRef: rootRef,
                className: classNames("vkuiChipsSelect__host", openedClassNames, className),
                status: status,
                after: dropdownIconProp || /*#__PURE__*/ _jsx(DropdownIcon, {
                    opened: opened,
                    onClick: onDropdownIconClick,
                    className: classNames("vkuiChipsSelect__dropdownIcon", clearButtonShown && "vkuiChipsSelect__dropdownIconWithOffset")
                }),
                // option
                value: value,
                onAddChipOption: addOptionFromInput,
                onRemoveChipOption: removeOption,
                renderChip: renderChip,
                onClear: clearOptions,
                // a11y
                chipsListLabel: chipsListLabel,
                slotProps: _object_spread_props(_object_spread({}, slotProps), {
                    input: _object_spread({
                        'role': 'combobox',
                        'aria-expanded': opened,
                        'aria-autocomplete': 'list',
                        'aria-activedescendant': opened ? dropdownCurrentItemId : undefined,
                        'aria-haspopup': 'listbox',
                        'getRootRef': inputRef,
                        'value': inputValue,
                        'onChange': onInputChange,
                        disabled,
                        readOnly,
                        'id': labelledbyId,
                        'onFocus': handleFocus,
                        'onBlur': handleBlur,
                        'onKeyDown': handleKeyDown
                    }, inputRest)
                })
            }, restProps)),
            opened && /*#__PURE__*/ _jsx(CustomSelectDropdown, {
                "data-testid": dropdownTestId,
                targetRef: rootRef,
                placement: dropdownVerticalPlacement,
                scrollBoxRef: dropdownScrollBoxRef,
                onPlacementChange: onDropdownPlacementChange,
                onMouseLeave: onDropdownMouseLeave,
                fetching: fetching,
                autoWidth: dropdownAutoWidth,
                forcePortal: forceDropdownPortal,
                noMaxHeight: noMaxHeight,
                offsetDistance: dropdownOffsetDistance,
                overscrollBehavior: overscrollBehavior,
                // a11y
                id: dropdownId,
                role: "listbox",
                "aria-labelledby": labelledbyId,
                children: dropdownContent
            })
        ]
    });
};

//# sourceMappingURL=ChipsSelect.js.map